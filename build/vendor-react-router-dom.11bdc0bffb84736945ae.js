"use strict";(self.webpackChunkquil=self.webpackChunkquil||[]).push([[191],{781:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\nvar react_dom__WEBPACK_IMPORTED_MODULE_1___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortedDeferredError: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.X3),\n/* harmony export */   Await: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.KP),\n/* harmony export */   BrowserRouter: () => (/* binding */ BrowserRouter),\n/* harmony export */   Form: () => (/* binding */ Form),\n/* harmony export */   HashRouter: () => (/* binding */ HashRouter),\n/* harmony export */   Link: () => (/* binding */ Link),\n/* harmony export */   MemoryRouter: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.VA),\n/* harmony export */   NavLink: () => (/* binding */ NavLink),\n/* harmony export */   Navigate: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.Fg),\n/* harmony export */   NavigationType: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.aU),\n/* harmony export */   Outlet: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.j3),\n/* harmony export */   Route: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.AW),\n/* harmony export */   Router: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.F0),\n/* harmony export */   RouterProvider: () => (/* binding */ RouterProvider),\n/* harmony export */   Routes: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.Z5),\n/* harmony export */   ScrollRestoration: () => (/* binding */ ScrollRestoration),\n/* harmony export */   UNSAFE_DataRouterContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.w3),\n/* harmony export */   UNSAFE_DataRouterStateContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.FR),\n/* harmony export */   UNSAFE_FetchersContext: () => (/* binding */ FetchersContext),\n/* harmony export */   UNSAFE_LocationContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.gd),\n/* harmony export */   UNSAFE_NavigationContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.Us),\n/* harmony export */   UNSAFE_RouteContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.pW),\n/* harmony export */   UNSAFE_ViewTransitionContext: () => (/* binding */ ViewTransitionContext),\n/* harmony export */   UNSAFE_useRouteId: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.Yi),\n/* harmony export */   UNSAFE_useScrollRestoration: () => (/* binding */ useScrollRestoration),\n/* harmony export */   createBrowserRouter: () => (/* binding */ createBrowserRouter),\n/* harmony export */   createHashRouter: () => (/* binding */ createHashRouter),\n/* harmony export */   createMemoryRouter: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.bi),\n/* harmony export */   createPath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Ep),\n/* harmony export */   createRoutesFromChildren: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.is),\n/* harmony export */   createRoutesFromElements: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.i7),\n/* harmony export */   createSearchParams: () => (/* binding */ createSearchParams),\n/* harmony export */   defer: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.PQ),\n/* harmony export */   generatePath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Gn),\n/* harmony export */   isRouteErrorResponse: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.WK),\n/* harmony export */   json: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.AV),\n/* harmony export */   matchPath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.LX),\n/* harmony export */   matchRoutes: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.fp),\n/* harmony export */   parsePath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.cP),\n/* harmony export */   redirect: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.uX),\n/* harmony export */   redirectDocument: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.fZ),\n/* harmony export */   renderMatches: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.Oe),\n/* harmony export */   resolvePath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.i3),\n/* harmony export */   unstable_HistoryRouter: () => (/* binding */ HistoryRouter),\n/* harmony export */   unstable_usePrompt: () => (/* binding */ usePrompt),\n/* harmony export */   unstable_useViewTransitionState: () => (/* binding */ useViewTransitionState),\n/* harmony export */   useActionData: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.nA),\n/* harmony export */   useAsyncError: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.iG),\n/* harmony export */   useAsyncValue: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.qv),\n/* harmony export */   useBeforeUnload: () => (/* binding */ useBeforeUnload),\n/* harmony export */   useBlocker: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__._Z),\n/* harmony export */   useFetcher: () => (/* binding */ useFetcher),\n/* harmony export */   useFetchers: () => (/* binding */ useFetchers),\n/* harmony export */   useFormAction: () => (/* binding */ useFormAction),\n/* harmony export */   useHref: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.oQ),\n/* harmony export */   useInRouterContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.GV),\n/* harmony export */   useLinkClickHandler: () => (/* binding */ useLinkClickHandler),\n/* harmony export */   useLoaderData: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.f_),\n/* harmony export */   useLocation: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.TH),\n/* harmony export */   useMatch: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.bS),\n/* harmony export */   useMatches: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.SN),\n/* harmony export */   useNavigate: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.s0),\n/* harmony export */   useNavigation: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.HJ),\n/* harmony export */   useNavigationType: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.ur),\n/* harmony export */   useOutlet: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.pC),\n/* harmony export */   useOutletContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.bx),\n/* harmony export */   useParams: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.UO),\n/* harmony export */   useResolvedPath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.WU),\n/* harmony export */   useRevalidator: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.xW),\n/* harmony export */   useRouteError: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.lk),\n/* harmony export */   useRouteLoaderData: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.V4),\n/* harmony export */   useRoutes: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.V$),\n/* harmony export */   useSearchParams: () => (/* binding */ useSearchParams),\n/* harmony export */   useSubmit: () => (/* binding */ useSubmit)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(709);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(169);\n/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(564);\n/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(194);\nfunction _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }\nfunction _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a \'" + n + "\' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n/**\n * React Router DOM v6.19.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n\n\n\n\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nvar defaultMethod = "get";\nvar defaultEncType = "application/x-www-form-urlencoded";\nfunction isHtmlElement(object) {\n  return object != null && typeof object.tagName === "string";\n}\nfunction isButtonElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === "button";\n}\nfunction isFormElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === "form";\n}\nfunction isInputElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === "input";\n}\nfunction isModifiedEvent(event) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\nfunction shouldProcessLinkClick(event, target) {\n  return event.button === 0 && (\n  // Ignore everything but left clicks\n  !target || target === "_self") &&\n  // Let browser handle "target=_blank" etc.\n  !isModifiedEvent(event) // Ignore clicks with modifier keys\n  ;\n}\n/**\n * Creates a URLSearchParams object using the given initializer.\n *\n * This is identical to `new URLSearchParams(init)` except it also\n * supports arrays as values in the object form of the initializer\n * instead of just strings. This is convenient when you need multiple\n * values for a given key, but don\'t want to use an array initializer.\n *\n * For example, instead of:\n *\n *   let searchParams = new URLSearchParams([\n *     [\'sort\', \'name\'],\n *     [\'sort\', \'price\']\n *   ]);\n *\n * you can do:\n *\n *   let searchParams = createSearchParams({\n *     sort: [\'name\', \'price\']\n *   });\n */\nfunction createSearchParams(init) {\n  if (init === void 0) {\n    init = "";\n  }\n  return new URLSearchParams(typeof init === "string" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce(function (memo, key) {\n    var value = init[key];\n    return memo.concat(Array.isArray(value) ? value.map(function (v) {\n      return [key, v];\n    }) : [[key, value]]);\n  }, []));\n}\nfunction getSearchParamsForLocation(locationSearch, defaultSearchParams) {\n  var searchParams = createSearchParams(locationSearch);\n  if (defaultSearchParams) {\n    // Use `defaultSearchParams.forEach(...)` here instead of iterating of\n    // `defaultSearchParams.keys()` to work-around a bug in Firefox related to\n    // web extensions. Relevant Bugzilla tickets:\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1414602\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1023984\n    defaultSearchParams.forEach(function (_, key) {\n      if (!searchParams.has(key)) {\n        defaultSearchParams.getAll(key).forEach(function (value) {\n          searchParams.append(key, value);\n        });\n      }\n    });\n  }\n  return searchParams;\n}\n// One-time check for submitter support\nvar _formDataSupportsSubmitter = null;\nfunction isFormDataSubmitterSupported() {\n  if (_formDataSupportsSubmitter === null) {\n    try {\n      new FormData(document.createElement("form"),\n      // @ts-expect-error if FormData supports the submitter parameter, this will throw\n      0);\n      _formDataSupportsSubmitter = false;\n    } catch (e) {\n      _formDataSupportsSubmitter = true;\n    }\n  }\n  return _formDataSupportsSubmitter;\n}\nvar supportedFormEncTypes = new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);\nfunction getFormEncType(encType) {\n  if (encType != null && !supportedFormEncTypes.has(encType)) {\n     false ? 0 : void 0;\n    return null;\n  }\n  return encType;\n}\nfunction getFormSubmissionInfo(target, basename) {\n  var method;\n  var action;\n  var encType;\n  var formData;\n  var body;\n  if (isFormElement(target)) {\n    // When grabbing the action from the element, it will have had the basename\n    // prefixed to ensure non-JS scenarios work, so strip it since we\'ll\n    // re-prefix in the router\n    var attr = target.getAttribute("action");\n    action = attr ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__/* .stripBasename */ .Zn)(attr, basename) : null;\n    method = target.getAttribute("method") || defaultMethod;\n    encType = getFormEncType(target.getAttribute("enctype")) || defaultEncType;\n    formData = new FormData(target);\n  } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {\n    var form = target.form;\n    if (form == null) {\n      throw new Error("Cannot submit a <button> or <input type=\\"submit\\"> without a <form>");\n    }\n    // <button>/<input type="submit"> may override attributes of <form>\n    // When grabbing the action from the element, it will have had the basename\n    // prefixed to ensure non-JS scenarios work, so strip it since we\'ll\n    // re-prefix in the router\n    var _attr = target.getAttribute("formaction") || form.getAttribute("action");\n    action = _attr ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__/* .stripBasename */ .Zn)(_attr, basename) : null;\n    method = target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;\n    encType = getFormEncType(target.getAttribute("formenctype")) || getFormEncType(form.getAttribute("enctype")) || defaultEncType;\n    // Build a FormData object populated from a form and submitter\n    formData = new FormData(form, target);\n    // If this browser doesn\'t support the `FormData(el, submitter)` format,\n    // then tack on the submitter value at the end.  This is a lightweight\n    // solution that is not 100% spec compliant.  For complete support in older\n    // browsers, consider using the `formdata-submitter-polyfill` package\n    if (!isFormDataSubmitterSupported()) {\n      var name = target.name,\n        type = target.type,\n        value = target.value;\n      if (type === "image") {\n        var prefix = name ? name + "." : "";\n        formData.append(prefix + "x", "0");\n        formData.append(prefix + "y", "0");\n      } else if (name) {\n        formData.append(name, value);\n      }\n    }\n  } else if (isHtmlElement(target)) {\n    throw new Error("Cannot submit element that is not <form>, <button>, or " + "<input type=\\"submit|image\\">");\n  } else {\n    method = defaultMethod;\n    action = null;\n    encType = defaultEncType;\n    body = target;\n  }\n  // Send body for <Form encType="text/plain" so we encode it into text\n  if (formData && encType === "text/plain") {\n    body = formData;\n    formData = undefined;\n  }\n  return {\n    action: action,\n    method: method.toLowerCase(),\n    encType: encType,\n    formData: formData,\n    body: body\n  };\n}\nvar _excluded = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "unstable_viewTransition"],\n  _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "unstable_viewTransition", "children"],\n  _excluded3 = ["fetcherKey", "navigate", "reloadDocument", "replace", "state", "method", "action", "onSubmit", "relative", "preventScrollReset", "unstable_viewTransition"];\nfunction createBrowserRouter(routes, opts) {\n  return (0,react_router__WEBPACK_IMPORTED_MODULE_2__/* .createRouter */ .p7)({\n    basename: opts == null ? void 0 : opts.basename,\n    future: _extends({}, opts == null ? void 0 : opts.future, {\n      v7_prependBasename: true\n    }),\n    history: (0,react_router__WEBPACK_IMPORTED_MODULE_2__/* .createBrowserHistory */ .lX)({\n      window: opts == null ? void 0 : opts.window\n    }),\n    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n    routes: routes,\n    mapRouteProperties: react_router__WEBPACK_IMPORTED_MODULE_3__/* .UNSAFE_mapRouteProperties */ .us,\n    window: opts == null ? void 0 : opts.window\n  }).initialize();\n}\nfunction createHashRouter(routes, opts) {\n  return (0,react_router__WEBPACK_IMPORTED_MODULE_2__/* .createRouter */ .p7)({\n    basename: opts == null ? void 0 : opts.basename,\n    future: _extends({}, opts == null ? void 0 : opts.future, {\n      v7_prependBasename: true\n    }),\n    history: (0,react_router__WEBPACK_IMPORTED_MODULE_2__/* .createHashHistory */ .q_)({\n      window: opts == null ? void 0 : opts.window\n    }),\n    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n    routes: routes,\n    mapRouteProperties: react_router__WEBPACK_IMPORTED_MODULE_3__/* .UNSAFE_mapRouteProperties */ .us,\n    window: opts == null ? void 0 : opts.window\n  }).initialize();\n}\nfunction parseHydrationData() {\n  var _window;\n  var state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;\n  if (state && state.errors) {\n    state = _extends({}, state, {\n      errors: deserializeErrors(state.errors)\n    });\n  }\n  return state;\n}\nfunction deserializeErrors(errors) {\n  if (!errors) return null;\n  var entries = Object.entries(errors);\n  var serialized = {};\n  for (var _i = 0, _entries = entries; _i < _entries.length; _i++) {\n    var _entries$_i = _slicedToArray(_entries[_i], 2),\n      key = _entries$_i[0],\n      val = _entries$_i[1];\n    // Hey you!  If you change this, please change the corresponding logic in\n    // serializeErrors in react-router-dom/server.tsx :)\n    if (val && val.__type === "RouteErrorResponse") {\n      serialized[key] = new react_router__WEBPACK_IMPORTED_MODULE_2__/* .UNSAFE_ErrorResponseImpl */ .OF(val.status, val.statusText, val.data, val.internal === true);\n    } else if (val && val.__type === "Error") {\n      // Attempt to reconstruct the right type of Error (i.e., ReferenceError)\n      if (val.__subType) {\n        var ErrorConstructor = window[val.__subType];\n        if (typeof ErrorConstructor === "function") {\n          try {\n            // @ts-expect-error\n            var error = new ErrorConstructor(val.message);\n            // Wipe away the client-side stack trace.  Nothing to fill it in with\n            // because we don\'t serialize SSR stack traces for security reasons\n            error.stack = "";\n            serialized[key] = error;\n          } catch (e) {\n            // no-op - fall through and create a normal Error\n          }\n        }\n      }\n      if (serialized[key] == null) {\n        var _error = new Error(val.message);\n        // Wipe away the client-side stack trace.  Nothing to fill it in with\n        // because we don\'t serialize SSR stack traces for security reasons\n        _error.stack = "";\n        serialized[key] = _error;\n      }\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\nvar ViewTransitionContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n  isTransitioning: false\n});\nif (false) {}\nvar FetchersContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(new Map());\nif (false) {}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Components\n////////////////////////////////////////////////////////////////////////////////\n/**\n  Webpack + React 17 fails to compile on any of the following because webpack\n  complains that `startTransition` doesn\'t exist in `React`:\n  * import { startTransition } from "react"\n  * import * as React from from "react";\n    "startTransition" in React ? React.startTransition(() => setState()) : setState()\n  * import * as React from from "react";\n    "startTransition" in React ? React["startTransition"](() => setState()) : setState()\n\n  Moving it to a constant such as the following solves the Webpack/React 17 issue:\n  * import * as React from from "react";\n    const START_TRANSITION = "startTransition";\n    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n  However, that introduces webpack/terser minification issues in production builds\n  in React 18 where minification/obfuscation ends up removing the call of\n  React.startTransition entirely from the first half of the ternary.  Grabbing\n  this exported reference once up front resolves that issue.\n\n  See https://github.com/remix-run/react-router/issues/10579\n*/\nvar START_TRANSITION = "startTransition";\nvar startTransitionImpl = /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)))[START_TRANSITION];\nvar FLUSH_SYNC = "flushSync";\nvar flushSyncImpl = /*#__PURE__*/ (react_dom__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (react_dom__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(react_dom__WEBPACK_IMPORTED_MODULE_1__, 2)))[FLUSH_SYNC];\nfunction startTransitionSafe(cb) {\n  if (startTransitionImpl) {\n    startTransitionImpl(cb);\n  } else {\n    cb();\n  }\n}\nfunction flushSyncSafe(cb) {\n  if (flushSyncImpl) {\n    flushSyncImpl(cb);\n  } else {\n    cb();\n  }\n}\nvar Deferred = /*#__PURE__*/_createClass(function Deferred() {\n  var _this = this;\n  _classCallCheck(this, Deferred);\n  this.status = "pending";\n  this.promise = new Promise(function (resolve, reject) {\n    _this.resolve = function (value) {\n      if (_this.status === "pending") {\n        _this.status = "resolved";\n        resolve(value);\n      }\n    };\n    _this.reject = function (reason) {\n      if (_this.status === "pending") {\n        _this.status = "rejected";\n        reject(reason);\n      }\n    };\n  });\n});\n/**\n * Given a Remix Router instance, render the appropriate UI\n */\nfunction RouterProvider(_ref) {\n  var fallbackElement = _ref.fallbackElement,\n    router = _ref.router,\n    future = _ref.future;\n  var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(router.state),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    state = _React$useState2[0],\n    setStateImpl = _React$useState2[1];\n  var _React$useState3 = react__WEBPACK_IMPORTED_MODULE_0__.useState(),\n    _React$useState4 = _slicedToArray(_React$useState3, 2),\n    pendingState = _React$useState4[0],\n    setPendingState = _React$useState4[1];\n  var _React$useState5 = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n      isTransitioning: false\n    }),\n    _React$useState6 = _slicedToArray(_React$useState5, 2),\n    vtContext = _React$useState6[0],\n    setVtContext = _React$useState6[1];\n  var _React$useState7 = react__WEBPACK_IMPORTED_MODULE_0__.useState(),\n    _React$useState8 = _slicedToArray(_React$useState7, 2),\n    renderDfd = _React$useState8[0],\n    setRenderDfd = _React$useState8[1];\n  var _React$useState9 = react__WEBPACK_IMPORTED_MODULE_0__.useState(),\n    _React$useState10 = _slicedToArray(_React$useState9, 2),\n    transition = _React$useState10[0],\n    setTransition = _React$useState10[1];\n  var _React$useState11 = react__WEBPACK_IMPORTED_MODULE_0__.useState(),\n    _React$useState12 = _slicedToArray(_React$useState11, 2),\n    interruption = _React$useState12[0],\n    setInterruption = _React$useState12[1];\n  var fetcherData = react__WEBPACK_IMPORTED_MODULE_0__.useRef(new Map());\n  var _ref13 = future || {},\n    v7_startTransition = _ref13.v7_startTransition;\n  var optInStartTransition = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (cb) {\n    if (v7_startTransition) {\n      startTransitionSafe(cb);\n    } else {\n      cb();\n    }\n  }, [v7_startTransition]);\n  var setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (newState, _ref2) {\n    var deletedFetchers = _ref2.deletedFetchers,\n      flushSync = _ref2.unstable_flushSync,\n      viewTransitionOpts = _ref2.unstable_viewTransitionOpts;\n    deletedFetchers.forEach(function (key) {\n      return fetcherData.current["delete"](key);\n    });\n    newState.fetchers.forEach(function (fetcher, key) {\n      if (fetcher.data !== undefined) {\n        fetcherData.current.set(key, fetcher.data);\n      }\n    });\n    var isViewTransitionUnavailable = router.window == null || typeof router.window.document.startViewTransition !== "function";\n    // If this isn\'t a view transition or it\'s not available in this browser,\n    // just update and be done with it\n    if (!viewTransitionOpts || isViewTransitionUnavailable) {\n      if (flushSync) {\n        flushSyncSafe(function () {\n          return setStateImpl(newState);\n        });\n      } else {\n        optInStartTransition(function () {\n          return setStateImpl(newState);\n        });\n      }\n      return;\n    }\n    // flushSync + startViewTransition\n    if (flushSync) {\n      // Flush through the context to mark DOM elements as transition=ing\n      flushSyncSafe(function () {\n        // Cancel any pending transitions\n        if (transition) {\n          renderDfd && renderDfd.resolve();\n          transition.skipTransition();\n        }\n        setVtContext({\n          isTransitioning: true,\n          flushSync: true,\n          currentLocation: viewTransitionOpts.currentLocation,\n          nextLocation: viewTransitionOpts.nextLocation\n        });\n      });\n      // Update the DOM\n      var t = router.window.document.startViewTransition(function () {\n        flushSyncSafe(function () {\n          return setStateImpl(newState);\n        });\n      });\n      // Clean up after the animation completes\n      t.finished["finally"](function () {\n        flushSyncSafe(function () {\n          setRenderDfd(undefined);\n          setTransition(undefined);\n          setPendingState(undefined);\n          setVtContext({\n            isTransitioning: false\n          });\n        });\n      });\n      flushSyncSafe(function () {\n        return setTransition(t);\n      });\n      return;\n    }\n    // startTransition + startViewTransition\n    if (transition) {\n      // Interrupting an in-progress transition, cancel and let everything flush\n      // out, and then kick off a new transition from the interruption state\n      renderDfd && renderDfd.resolve();\n      transition.skipTransition();\n      setInterruption({\n        state: newState,\n        currentLocation: viewTransitionOpts.currentLocation,\n        nextLocation: viewTransitionOpts.nextLocation\n      });\n    } else {\n      // Completed navigation update with opted-in view transitions, let \'er rip\n      setPendingState(newState);\n      setVtContext({\n        isTransitioning: true,\n        flushSync: false,\n        currentLocation: viewTransitionOpts.currentLocation,\n        nextLocation: viewTransitionOpts.nextLocation\n      });\n    }\n  }, [router.window, transition, renderDfd, fetcherData, optInStartTransition]);\n  // Need to use a layout effect here so we are subscribed early enough to\n  // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\n  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(function () {\n    return router.subscribe(setState);\n  }, [router, setState]);\n  // When we start a view transition, create a Deferred we can use for the\n  // eventual "completed" render\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    if (vtContext.isTransitioning && !vtContext.flushSync) {\n      setRenderDfd(new Deferred());\n    }\n  }, [vtContext]);\n  // Once the deferred is created, kick off startViewTransition() to update the\n  // DOM and then wait on the Deferred to resolve (indicating the DOM update has\n  // happened)\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    if (renderDfd && pendingState && router.window) {\n      var newState = pendingState;\n      var renderPromise = renderDfd.promise;\n      var _transition = router.window.document.startViewTransition( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              optInStartTransition(function () {\n                return setStateImpl(newState);\n              });\n              _context.next = 3;\n              return renderPromise;\n            case 3:\n            case "end":\n              return _context.stop();\n          }\n        }, _callee);\n      })));\n      _transition.finished["finally"](function () {\n        setRenderDfd(undefined);\n        setTransition(undefined);\n        setPendingState(undefined);\n        setVtContext({\n          isTransitioning: false\n        });\n      });\n      setTransition(_transition);\n    }\n  }, [optInStartTransition, pendingState, renderDfd, router.window]);\n  // When the new location finally renders and is committed to the DOM, this\n  // effect will run to resolve the transition\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    if (renderDfd && pendingState && state.location.key === pendingState.location.key) {\n      renderDfd.resolve();\n    }\n  }, [renderDfd, transition, state.location, pendingState]);\n  // If we get interrupted with a new navigation during a transition, we skip\n  // the active transition, let it cleanup, then kick it off again here\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    if (!vtContext.isTransitioning && interruption) {\n      setPendingState(interruption.state);\n      setVtContext({\n        isTransitioning: true,\n        flushSync: false,\n        currentLocation: interruption.currentLocation,\n        nextLocation: interruption.nextLocation\n      });\n      setInterruption(undefined);\n    }\n  }, [vtContext.isTransitioning, interruption]);\n  var navigator = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function () {\n    return {\n      createHref: router.createHref,\n      encodeLocation: router.encodeLocation,\n      go: function go(n) {\n        return router.navigate(n);\n      },\n      push: function push(to, state, opts) {\n        return router.navigate(to, {\n          state: state,\n          preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n        });\n      },\n      replace: function replace(to, state, opts) {\n        return router.navigate(to, {\n          replace: true,\n          state: state,\n          preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n        });\n      }\n    };\n  }, [router]);\n  var basename = router.basename || "/";\n  var dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function () {\n    return {\n      router: router,\n      navigator: navigator,\n      "static": false,\n      basename: basename\n    };\n  }, [router, navigator, basename]);\n  // The fragment and {null} here are important!  We need them to keep React 18\'s\n  // useId happy when we are server-rendering since we may have a <script> here\n  // containing the hydrated server-side staticContext (from StaticRouterProvider).\n  // useId relies on the component tree structure to generate deterministic id\'s\n  // so we need to ensure it remains the same on the client even though\n  // we don\'t need the <script> tag\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_3__/* .UNSAFE_DataRouterContext */ .w3.Provider, {\n    value: dataRouterContext\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_3__/* .UNSAFE_DataRouterStateContext */ .FR.Provider, {\n    value: state\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FetchersContext.Provider, {\n    value: fetcherData.current\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(ViewTransitionContext.Provider, {\n    value: vtContext\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_3__/* .Router */ .F0, {\n    basename: basename,\n    location: state.location,\n    navigationType: state.historyAction,\n    navigator: navigator\n  }, state.initialized ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRoutes, {\n    routes: router.routes,\n    state: state\n  }) : fallbackElement))))), null);\n}\nfunction DataRoutes(_ref3) {\n  var routes = _ref3.routes,\n    state = _ref3.state;\n  return (0,react_router__WEBPACK_IMPORTED_MODULE_3__/* .UNSAFE_useRoutesImpl */ .DY)(routes, undefined, state);\n}\n/**\n * A `<Router>` for use in web browsers. Provides the cleanest URLs.\n */\nfunction BrowserRouter(_ref4) {\n  var basename = _ref4.basename,\n    children = _ref4.children,\n    future = _ref4.future,\n    window = _ref4.window;\n  var historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = (0,react_router__WEBPACK_IMPORTED_MODULE_2__/* .createBrowserHistory */ .lX)({\n      window: window,\n      v5Compat: true\n    });\n  }\n  var history = historyRef.current;\n  var _React$useState13 = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n      action: history.action,\n      location: history.location\n    }),\n    _React$useState14 = _slicedToArray(_React$useState13, 2),\n    state = _React$useState14[0],\n    setStateImpl = _React$useState14[1];\n  var _ref15 = future || {},\n    v7_startTransition = _ref15.v7_startTransition;\n  var setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (newState) {\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(function () {\n      return setStateImpl(newState);\n    }) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(function () {\n    return history.listen(setState);\n  }, [history, setState]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_3__/* .Router */ .F0, {\n    basename: basename,\n    children: children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history\n  });\n}\n/**\n * A `<Router>` for use in web browsers. Stores the location in the hash\n * portion of the URL so it is not sent to the server.\n */\nfunction HashRouter(_ref5) {\n  var basename = _ref5.basename,\n    children = _ref5.children,\n    future = _ref5.future,\n    window = _ref5.window;\n  var historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = (0,react_router__WEBPACK_IMPORTED_MODULE_2__/* .createHashHistory */ .q_)({\n      window: window,\n      v5Compat: true\n    });\n  }\n  var history = historyRef.current;\n  var _React$useState15 = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n      action: history.action,\n      location: history.location\n    }),\n    _React$useState16 = _slicedToArray(_React$useState15, 2),\n    state = _React$useState16[0],\n    setStateImpl = _React$useState16[1];\n  var _ref16 = future || {},\n    v7_startTransition = _ref16.v7_startTransition;\n  var setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (newState) {\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(function () {\n      return setStateImpl(newState);\n    }) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(function () {\n    return history.listen(setState);\n  }, [history, setState]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_3__/* .Router */ .F0, {\n    basename: basename,\n    children: children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history\n  });\n}\n/**\n * A `<Router>` that accepts a pre-instantiated history object. It\'s important\n * to note that using your own history object is highly discouraged and may add\n * two versions of the history library to your bundles unless you use the same\n * version of the history library that React Router uses internally.\n */\nfunction HistoryRouter(_ref6) {\n  var basename = _ref6.basename,\n    children = _ref6.children,\n    future = _ref6.future,\n    history = _ref6.history;\n  var _React$useState17 = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n      action: history.action,\n      location: history.location\n    }),\n    _React$useState18 = _slicedToArray(_React$useState17, 2),\n    state = _React$useState18[0],\n    setStateImpl = _React$useState18[1];\n  var _ref17 = future || {},\n    v7_startTransition = _ref17.v7_startTransition;\n  var setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (newState) {\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(function () {\n      return setStateImpl(newState);\n    }) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(function () {\n    return history.listen(setState);\n  }, [history, setState]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_3__/* .Router */ .F0, {\n    basename: basename,\n    children: children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history\n  });\n}\nif (false) {}\nvar isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";\nvar ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\n/**\n * The public API for rendering a history-aware `<a>`.\n */\nvar Link = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function LinkWithRef(_ref7, ref) {\n  var onClick = _ref7.onClick,\n    relative = _ref7.relative,\n    reloadDocument = _ref7.reloadDocument,\n    replace = _ref7.replace,\n    state = _ref7.state,\n    target = _ref7.target,\n    to = _ref7.to,\n    preventScrollReset = _ref7.preventScrollReset,\n    unstable_viewTransition = _ref7.unstable_viewTransition,\n    rest = _objectWithoutPropertiesLoose(_ref7, _excluded);\n  var _React$useContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__/* .UNSAFE_NavigationContext */ .Us),\n    basename = _React$useContext.basename;\n  // Rendered into <a href> for absolute URLs\n  var absoluteHref;\n  var isExternal = false;\n  if (typeof to === "string" && ABSOLUTE_URL_REGEX.test(to)) {\n    // Render the absolute href server- and client-side\n    absoluteHref = to;\n    // Only check for external origins client-side\n    if (isBrowser) {\n      try {\n        var currentUrl = new URL(window.location.href);\n        var targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);\n        var path = (0,react_router__WEBPACK_IMPORTED_MODULE_2__/* .stripBasename */ .Zn)(targetUrl.pathname, basename);\n        if (targetUrl.origin === currentUrl.origin && path != null) {\n          // Strip the protocol/origin/basename for same-origin absolute URLs\n          to = path + targetUrl.search + targetUrl.hash;\n        } else {\n          isExternal = true;\n        }\n      } catch (e) {\n        // We can\'t do external URL detection without a valid URL\n         false ? 0 : void 0;\n      }\n    }\n  }\n  // Rendered into <a href> for relative URLs\n  var href = (0,react_router__WEBPACK_IMPORTED_MODULE_3__/* .useHref */ .oQ)(to, {\n    relative: relative\n  });\n  var internalOnClick = useLinkClickHandler(to, {\n    replace: replace,\n    state: state,\n    target: target,\n    preventScrollReset: preventScrollReset,\n    relative: relative,\n    unstable_viewTransition: unstable_viewTransition\n  });\n  function handleClick(event) {\n    if (onClick) onClick(event);\n    if (!event.defaultPrevented) {\n      internalOnClick(event);\n    }\n  }\n  return /*#__PURE__*/(\n    // eslint-disable-next-line jsx-a11y/anchor-has-content\n    react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", _extends({}, rest, {\n      href: absoluteHref || href,\n      onClick: isExternal || reloadDocument ? onClick : handleClick,\n      ref: ref,\n      target: target\n    }))\n  );\n});\nif (false) {}\n/**\n * A `<Link>` wrapper that knows if it\'s "active" or not.\n */\nvar NavLink = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function NavLinkWithRef(_ref8, ref) {\n  var _ref8$ariaCurrent = _ref8["aria-current"],\n    ariaCurrentProp = _ref8$ariaCurrent === void 0 ? "page" : _ref8$ariaCurrent,\n    _ref8$caseSensitive = _ref8.caseSensitive,\n    caseSensitive = _ref8$caseSensitive === void 0 ? false : _ref8$caseSensitive,\n    _ref8$className = _ref8.className,\n    classNameProp = _ref8$className === void 0 ? "" : _ref8$className,\n    _ref8$end = _ref8.end,\n    end = _ref8$end === void 0 ? false : _ref8$end,\n    styleProp = _ref8.style,\n    to = _ref8.to,\n    unstable_viewTransition = _ref8.unstable_viewTransition,\n    children = _ref8.children,\n    rest = _objectWithoutPropertiesLoose(_ref8, _excluded2);\n  var path = (0,react_router__WEBPACK_IMPORTED_MODULE_3__/* .useResolvedPath */ .WU)(to, {\n    relative: rest.relative\n  });\n  var location = (0,react_router__WEBPACK_IMPORTED_MODULE_3__/* .useLocation */ .TH)();\n  var routerState = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__/* .UNSAFE_DataRouterStateContext */ .FR);\n  var _React$useContext2 = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__/* .UNSAFE_NavigationContext */ .Us),\n    navigator = _React$useContext2.navigator;\n  var isTransitioning = routerState != null &&\n  // Conditional usage is OK here because the usage of a data router is static\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  useViewTransitionState(path) && unstable_viewTransition === true;\n  var toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;\n  var locationPathname = location.pathname;\n  var nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;\n  if (!caseSensitive) {\n    locationPathname = locationPathname.toLowerCase();\n    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;\n    toPathname = toPathname.toLowerCase();\n  }\n  // If the `to` has a trailing slash, look at that exact spot.  Otherwise,\n  // we\'re looking for a slash _after_ what\'s in `to`.  For example:\n  //\n  // <NavLink to="/users"> and <NavLink to="/users/">\n  // both want to look for a / at index 6 to match URL `/users/matt`\n  var endSlashPosition = toPathname !== "/" && toPathname.endsWith("/") ? toPathname.length - 1 : toPathname.length;\n  var isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === "/";\n  var isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");\n  var renderProps = {\n    isActive: isActive,\n    isPending: isPending,\n    isTransitioning: isTransitioning\n  };\n  var ariaCurrent = isActive ? ariaCurrentProp : undefined;\n  var className;\n  if (typeof classNameProp === "function") {\n    className = classNameProp(renderProps);\n  } else {\n    // If the className prop is not a function, we use a default `active`\n    // class for <NavLink />s that are active. In v5 `active` was the default\n    // value for `activeClassName`, but we are removing that API and can still\n    // use the old default behavior for a cleaner upgrade path and keep the\n    // simple styling rules working as they currently do.\n    className = [classNameProp, isActive ? "active" : null, isPending ? "pending" : null, isTransitioning ? "transitioning" : null].filter(Boolean).join(" ");\n  }\n  var style = typeof styleProp === "function" ? styleProp(renderProps) : styleProp;\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Link, _extends({}, rest, {\n    "aria-current": ariaCurrent,\n    className: className,\n    ref: ref,\n    style: style,\n    to: to,\n    unstable_viewTransition: unstable_viewTransition\n  }), typeof children === "function" ? children(renderProps) : children);\n});\nif (false) {}\n/**\n * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except\n * that the interaction with the server is with `fetch` instead of new document\n * requests, allowing components to add nicer UX to the page as the form is\n * submitted and returns with data.\n */\nvar Form = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function (_ref9, forwardedRef) {\n  var fetcherKey = _ref9.fetcherKey,\n    navigate = _ref9.navigate,\n    reloadDocument = _ref9.reloadDocument,\n    replace = _ref9.replace,\n    state = _ref9.state,\n    _ref9$method = _ref9.method,\n    method = _ref9$method === void 0 ? defaultMethod : _ref9$method,\n    action = _ref9.action,\n    onSubmit = _ref9.onSubmit,\n    relative = _ref9.relative,\n    preventScrollReset = _ref9.preventScrollReset,\n    unstable_viewTransition = _ref9.unstable_viewTransition,\n    props = _objectWithoutPropertiesLoose(_ref9, _excluded3);\n  var submit = useSubmit();\n  var formAction = useFormAction(action, {\n    relative: relative\n  });\n  var formMethod = method.toLowerCase() === "get" ? "get" : "post";\n  var submitHandler = function submitHandler(event) {\n    onSubmit && onSubmit(event);\n    if (event.defaultPrevented) return;\n    event.preventDefault();\n    var submitter = event.nativeEvent.submitter;\n    var submitMethod = (submitter == null ? void 0 : submitter.getAttribute("formmethod")) || method;\n    submit(submitter || event.currentTarget, {\n      fetcherKey: fetcherKey,\n      method: submitMethod,\n      navigate: navigate,\n      replace: replace,\n      state: state,\n      relative: relative,\n      preventScrollReset: preventScrollReset,\n      unstable_viewTransition: unstable_viewTransition\n    });\n  };\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("form", _extends({\n    ref: forwardedRef,\n    method: formMethod,\n    action: formAction,\n    onSubmit: reloadDocument ? onSubmit : submitHandler\n  }, props));\n});\nif (false) {}\n/**\n * This component will emulate the browser\'s scroll restoration on location\n * changes.\n */\nfunction ScrollRestoration(_ref10) {\n  var getKey = _ref10.getKey,\n    storageKey = _ref10.storageKey;\n  useScrollRestoration({\n    getKey: getKey,\n    storageKey: storageKey\n  });\n  return null;\n}\nif (false) {}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Hooks\n////////////////////////////////////////////////////////////////////////////////\nvar DataRouterHook;\n(function (DataRouterHook) {\n  DataRouterHook["UseScrollRestoration"] = "useScrollRestoration";\n  DataRouterHook["UseSubmit"] = "useSubmit";\n  DataRouterHook["UseSubmitFetcher"] = "useSubmitFetcher";\n  DataRouterHook["UseFetcher"] = "useFetcher";\n  DataRouterHook["useViewTransitionState"] = "useViewTransitionState";\n})(DataRouterHook || (DataRouterHook = {}));\nvar DataRouterStateHook;\n(function (DataRouterStateHook) {\n  DataRouterStateHook["UseFetcher"] = "useFetcher";\n  DataRouterStateHook["UseFetchers"] = "useFetchers";\n  DataRouterStateHook["UseScrollRestoration"] = "useScrollRestoration";\n})(DataRouterStateHook || (DataRouterStateHook = {}));\n// Internal hooks\nfunction getDataRouterConsoleError(hookName) {\n  return hookName + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";\n}\nfunction useDataRouterContext(hookName) {\n  var ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__/* .UNSAFE_DataRouterContext */ .w3);\n  !ctx ?  false ? 0 : (0,react_router__WEBPACK_IMPORTED_MODULE_2__/* .UNSAFE_invariant */ .J0)(false) : void 0;\n  return ctx;\n}\nfunction useDataRouterState(hookName) {\n  var state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__/* .UNSAFE_DataRouterStateContext */ .FR);\n  !state ?  false ? 0 : (0,react_router__WEBPACK_IMPORTED_MODULE_2__/* .UNSAFE_invariant */ .J0)(false) : void 0;\n  return state;\n}\n// External hooks\n/**\n * Handles the click behavior for router `<Link>` components. This is useful if\n * you need to create custom `<Link>` components with the same click behavior we\n * use in our exported `<Link>`.\n */\nfunction useLinkClickHandler(to, _temp) {\n  var _ref18 = _temp === void 0 ? {} : _temp,\n    target = _ref18.target,\n    replaceProp = _ref18.replace,\n    state = _ref18.state,\n    preventScrollReset = _ref18.preventScrollReset,\n    relative = _ref18.relative,\n    unstable_viewTransition = _ref18.unstable_viewTransition;\n  var navigate = (0,react_router__WEBPACK_IMPORTED_MODULE_3__/* .useNavigate */ .s0)();\n  var location = (0,react_router__WEBPACK_IMPORTED_MODULE_3__/* .useLocation */ .TH)();\n  var path = (0,react_router__WEBPACK_IMPORTED_MODULE_3__/* .useResolvedPath */ .WU)(to, {\n    relative: relative\n  });\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (event) {\n    if (shouldProcessLinkClick(event, target)) {\n      event.preventDefault();\n      // If the URL hasn\'t changed, a regular <a> will do a replace instead of\n      // a push, so do the same here unless the replace prop is explicitly set\n      var replace = replaceProp !== undefined ? replaceProp : (0,react_router__WEBPACK_IMPORTED_MODULE_2__/* .createPath */ .Ep)(location) === (0,react_router__WEBPACK_IMPORTED_MODULE_2__/* .createPath */ .Ep)(path);\n      navigate(to, {\n        replace: replace,\n        state: state,\n        preventScrollReset: preventScrollReset,\n        relative: relative,\n        unstable_viewTransition: unstable_viewTransition\n      });\n    }\n  }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative, unstable_viewTransition]);\n}\n/**\n * A convenient wrapper for reading and writing search parameters via the\n * URLSearchParams interface.\n */\nfunction useSearchParams(defaultInit) {\n   false ? 0 : void 0;\n  var defaultSearchParamsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(createSearchParams(defaultInit));\n  var hasSetSearchParamsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  var location = (0,react_router__WEBPACK_IMPORTED_MODULE_3__/* .useLocation */ .TH)();\n  var searchParams = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function () {\n    return (\n      // Only merge in the defaults if we haven\'t yet called setSearchParams.\n      // Once we call that we want those to take precedence, otherwise you can\'t\n      // remove a param with setSearchParams({}) if it has an initial value\n      getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current)\n    );\n  }, [location.search]);\n  var navigate = (0,react_router__WEBPACK_IMPORTED_MODULE_3__/* .useNavigate */ .s0)();\n  var setSearchParams = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (nextInit, navigateOptions) {\n    var newSearchParams = createSearchParams(typeof nextInit === "function" ? nextInit(searchParams) : nextInit);\n    hasSetSearchParamsRef.current = true;\n    navigate("?" + newSearchParams, navigateOptions);\n  }, [navigate, searchParams]);\n  return [searchParams, setSearchParams];\n}\nfunction validateClientSideSubmission() {\n  if (typeof document === "undefined") {\n    throw new Error("You are calling submit during the server render. " + "Try calling submit within a `useEffect` or callback instead.");\n  }\n}\nvar fetcherId = 0;\nvar getUniqueFetcherId = function getUniqueFetcherId() {\n  return "__" + String(++fetcherId) + "__";\n};\n/**\n * Returns a function that may be used to programmatically submit a form (or\n * some arbitrary data) to the server.\n */\nfunction useSubmit() {\n  var _useDataRouterContext = useDataRouterContext(DataRouterHook.UseSubmit),\n    router = _useDataRouterContext.router;\n  var _React$useContext3 = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__/* .UNSAFE_NavigationContext */ .Us),\n    basename = _React$useContext3.basename;\n  var currentRouteId = (0,react_router__WEBPACK_IMPORTED_MODULE_3__/* .UNSAFE_useRouteId */ .Yi)();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (target, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    validateClientSideSubmission();\n    var _getFormSubmissionInf = getFormSubmissionInfo(target, basename),\n      action = _getFormSubmissionInf.action,\n      method = _getFormSubmissionInf.method,\n      encType = _getFormSubmissionInf.encType,\n      formData = _getFormSubmissionInf.formData,\n      body = _getFormSubmissionInf.body;\n    if (options.navigate === false) {\n      var key = options.fetcherKey || getUniqueFetcherId();\n      router.fetch(key, currentRouteId, options.action || action, {\n        preventScrollReset: options.preventScrollReset,\n        formData: formData,\n        body: body,\n        formMethod: options.method || method,\n        formEncType: options.encType || encType,\n        unstable_flushSync: options.unstable_flushSync\n      });\n    } else {\n      router.navigate(options.action || action, {\n        preventScrollReset: options.preventScrollReset,\n        formData: formData,\n        body: body,\n        formMethod: options.method || method,\n        formEncType: options.encType || encType,\n        replace: options.replace,\n        state: options.state,\n        fromRouteId: currentRouteId,\n        unstable_flushSync: options.unstable_flushSync,\n        unstable_viewTransition: options.unstable_viewTransition\n      });\n    }\n  }, [router, basename, currentRouteId]);\n}\n// v7: Eventually we should deprecate this entirely in favor of using the\n// router method directly?\nfunction useFormAction(action, _temp2) {\n  var _ref19 = _temp2 === void 0 ? {} : _temp2,\n    relative = _ref19.relative;\n  var _React$useContext4 = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__/* .UNSAFE_NavigationContext */ .Us),\n    basename = _React$useContext4.basename;\n  var routeContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__/* .UNSAFE_RouteContext */ .pW);\n  !routeContext ?  false ? 0 : (0,react_router__WEBPACK_IMPORTED_MODULE_2__/* .UNSAFE_invariant */ .J0)(false) : void 0;\n  var _routeContext$matches = routeContext.matches.slice(-1),\n    _routeContext$matches2 = _slicedToArray(_routeContext$matches, 1),\n    match = _routeContext$matches2[0];\n  // Shallow clone path so we can modify it below, otherwise we modify the\n  // object referenced by useMemo inside useResolvedPath\n  var path = _extends({}, (0,react_router__WEBPACK_IMPORTED_MODULE_3__/* .useResolvedPath */ .WU)(action ? action : ".", {\n    relative: relative\n  }));\n  // If no action was specified, browsers will persist current search params\n  // when determining the path, so match that behavior\n  // https://github.com/remix-run/remix/issues/927\n  var location = (0,react_router__WEBPACK_IMPORTED_MODULE_3__/* .useLocation */ .TH)();\n  if (action == null) {\n    // Safe to write to this directly here since if action was undefined, we\n    // would have called useResolvedPath(".") which will never include a search\n    path.search = location.search;\n    // When grabbing search params from the URL, remove any included ?index param\n    // since it might not apply to our contextual route.  We add it back based\n    // on match.route.index below\n    var params = new URLSearchParams(path.search);\n    if (params.has("index") && params.get("index") === "") {\n      params["delete"]("index");\n      path.search = params.toString() ? "?" + params.toString() : "";\n    }\n  }\n  if ((!action || action === ".") && match.route.index) {\n    path.search = path.search ? path.search.replace(/^\\?/, "?index&") : "?index";\n  }\n  // If we\'re operating within a basename, prepend it to the pathname prior\n  // to creating the form action.  If this is a root navigation, then just use\n  // the raw basename which allows the basename to have full control over the\n  // presence of a trailing slash on root actions\n  if (basename !== "/") {\n    path.pathname = path.pathname === "/" ? basename : (0,react_router__WEBPACK_IMPORTED_MODULE_2__/* .joinPaths */ .RQ)([basename, path.pathname]);\n  }\n  return (0,react_router__WEBPACK_IMPORTED_MODULE_2__/* .createPath */ .Ep)(path);\n}\n// TODO: (v7) Change the useFetcher generic default from `any` to `unknown`\n/**\n * Interacts with route loaders and actions without causing a navigation. Great\n * for any interaction that stays on the same page.\n */\nfunction useFetcher(_temp3) {\n  var _route$matches;\n  var _ref20 = _temp3 === void 0 ? {} : _temp3,\n    key = _ref20.key;\n  var _useDataRouterContext2 = useDataRouterContext(DataRouterHook.UseFetcher),\n    router = _useDataRouterContext2.router;\n  var state = useDataRouterState(DataRouterStateHook.UseFetcher);\n  var fetcherData = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FetchersContext);\n  var route = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__/* .UNSAFE_RouteContext */ .pW);\n  var routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;\n  !fetcherData ?  false ? 0 : (0,react_router__WEBPACK_IMPORTED_MODULE_2__/* .UNSAFE_invariant */ .J0)(false) : void 0;\n  !route ?  false ? 0 : (0,react_router__WEBPACK_IMPORTED_MODULE_2__/* .UNSAFE_invariant */ .J0)(false) : void 0;\n  !(routeId != null) ?  false ? 0 : (0,react_router__WEBPACK_IMPORTED_MODULE_2__/* .UNSAFE_invariant */ .J0)(false) : void 0;\n  // Fetcher key handling\n  var _React$useState19 = react__WEBPACK_IMPORTED_MODULE_0__.useState(key || ""),\n    _React$useState20 = _slicedToArray(_React$useState19, 2),\n    fetcherKey = _React$useState20[0],\n    setFetcherKey = _React$useState20[1];\n  if (key && key !== fetcherKey) {\n    setFetcherKey(key);\n  } else if (!fetcherKey) {\n    setFetcherKey(getUniqueFetcherId());\n  }\n  // Registration/cleanup\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    router.getFetcher(fetcherKey);\n    return function () {\n      // Tell the router we\'ve unmounted - if v7_fetcherPersist is enabled this\n      // will not delete immediately but instead queue up a delete after the\n      // fetcher returns to an `idle` state\n      router.deleteFetcher(fetcherKey);\n    };\n  }, [router, fetcherKey]);\n  // Fetcher additions\n  var load = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (href, opts) {\n    !routeId ?  false ? 0 : (0,react_router__WEBPACK_IMPORTED_MODULE_2__/* .UNSAFE_invariant */ .J0)(false) : void 0;\n    router.fetch(fetcherKey, routeId, href, opts);\n  }, [fetcherKey, routeId, router]);\n  var submitImpl = useSubmit();\n  var submit = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (target, opts) {\n    submitImpl(target, _extends({}, opts, {\n      navigate: false,\n      fetcherKey: fetcherKey\n    }));\n  }, [fetcherKey, submitImpl]);\n  var FetcherForm = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function () {\n    var FetcherForm = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function (props, ref) {\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Form, _extends({}, props, {\n        navigate: false,\n        fetcherKey: fetcherKey,\n        ref: ref\n      }));\n    });\n    if (false) {}\n    return FetcherForm;\n  }, [fetcherKey]);\n  // Exposed FetcherWithComponents\n  var fetcher = state.fetchers.get(fetcherKey) || react_router__WEBPACK_IMPORTED_MODULE_2__/* .IDLE_FETCHER */ .ov;\n  var data = fetcherData.get(fetcherKey);\n  var fetcherWithComponents = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function () {\n    return _extends({\n      Form: FetcherForm,\n      submit: submit,\n      load: load\n    }, fetcher, {\n      data: data\n    });\n  }, [FetcherForm, submit, load, fetcher, data]);\n  return fetcherWithComponents;\n}\n/**\n * Provides all fetchers currently on the page. Useful for layouts and parent\n * routes that need to provide pending/optimistic UI regarding the fetch.\n */\nfunction useFetchers() {\n  var state = useDataRouterState(DataRouterStateHook.UseFetchers);\n  return Array.from(state.fetchers.entries()).map(function (_ref11) {\n    var _ref21 = _slicedToArray(_ref11, 2),\n      key = _ref21[0],\n      fetcher = _ref21[1];\n    return _extends({}, fetcher, {\n      key: key\n    });\n  });\n}\nvar SCROLL_RESTORATION_STORAGE_KEY = "react-router-scroll-positions";\nvar savedScrollPositions = {};\n/**\n * When rendered inside a RouterProvider, will restore scroll positions on navigations\n */\nfunction useScrollRestoration(_temp4) {\n  var _ref22 = _temp4 === void 0 ? {} : _temp4,\n    getKey = _ref22.getKey,\n    storageKey = _ref22.storageKey;\n  var _useDataRouterContext3 = useDataRouterContext(DataRouterHook.UseScrollRestoration),\n    router = _useDataRouterContext3.router;\n  var _useDataRouterState = useDataRouterState(DataRouterStateHook.UseScrollRestoration),\n    restoreScrollPosition = _useDataRouterState.restoreScrollPosition,\n    preventScrollReset = _useDataRouterState.preventScrollReset;\n  var _React$useContext5 = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__/* .UNSAFE_NavigationContext */ .Us),\n    basename = _React$useContext5.basename;\n  var location = (0,react_router__WEBPACK_IMPORTED_MODULE_3__/* .useLocation */ .TH)();\n  var matches = (0,react_router__WEBPACK_IMPORTED_MODULE_3__/* .useMatches */ .SN)();\n  var navigation = (0,react_router__WEBPACK_IMPORTED_MODULE_3__/* .useNavigation */ .HJ)();\n  // Trigger manual scroll restoration while we\'re active\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    window.history.scrollRestoration = "manual";\n    return function () {\n      window.history.scrollRestoration = "auto";\n    };\n  }, []);\n  // Save positions on pagehide\n  usePageHide(react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function () {\n    if (navigation.state === "idle") {\n      var key = (getKey ? getKey(location, matches) : null) || location.key;\n      savedScrollPositions[key] = window.scrollY;\n    }\n    try {\n      sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));\n    } catch (error) {\n       false ? 0 : void 0;\n    }\n    window.history.scrollRestoration = "auto";\n  }, [storageKey, getKey, navigation.state, location, matches]));\n  // Read in any saved scroll locations\n  if (typeof document !== "undefined") {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(function () {\n      try {\n        var sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);\n        if (sessionPositions) {\n          savedScrollPositions = JSON.parse(sessionPositions);\n        }\n      } catch (e) {\n        // no-op, use default empty object\n      }\n    }, [storageKey]);\n    // Enable scroll restoration in the router\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(function () {\n      var getKeyWithoutBasename = getKey && basename !== "/" ? function (location, matches) {\n        return getKey(\n        // Strip the basename to match useLocation()\n        _extends({}, location, {\n          pathname: (0,react_router__WEBPACK_IMPORTED_MODULE_2__/* .stripBasename */ .Zn)(location.pathname, basename) || location.pathname\n        }), matches);\n      } : getKey;\n      var disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration(savedScrollPositions, function () {\n        return window.scrollY;\n      }, getKeyWithoutBasename);\n      return function () {\n        return disableScrollRestoration && disableScrollRestoration();\n      };\n    }, [router, basename, getKey]);\n    // Restore scrolling when state.restoreScrollPosition changes\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(function () {\n      // Explicit false means don\'t do anything (used for submissions)\n      if (restoreScrollPosition === false) {\n        return;\n      }\n      // been here before, scroll to it\n      if (typeof restoreScrollPosition === "number") {\n        window.scrollTo(0, restoreScrollPosition);\n        return;\n      }\n      // try to scroll to the hash\n      if (location.hash) {\n        var el = document.getElementById(decodeURIComponent(location.hash.slice(1)));\n        if (el) {\n          el.scrollIntoView();\n          return;\n        }\n      }\n      // Don\'t reset if this navigation opted out\n      if (preventScrollReset === true) {\n        return;\n      }\n      // otherwise go to the top on new locations\n      window.scrollTo(0, 0);\n    }, [location, restoreScrollPosition, preventScrollReset]);\n  }\n}\n/**\n * Setup a callback to be fired on the window\'s `beforeunload` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */\nfunction useBeforeUnload(callback, options) {\n  var _ref23 = options || {},\n    capture = _ref23.capture;\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    var opts = capture != null ? {\n      capture: capture\n    } : undefined;\n    window.addEventListener("beforeunload", callback, opts);\n    return function () {\n      window.removeEventListener("beforeunload", callback, opts);\n    };\n  }, [callback, capture]);\n}\n/**\n * Setup a callback to be fired on the window\'s `pagehide` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.  This event is better supported than beforeunload across browsers.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */\nfunction usePageHide(callback, options) {\n  var _ref24 = options || {},\n    capture = _ref24.capture;\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    var opts = capture != null ? {\n      capture: capture\n    } : undefined;\n    window.addEventListener("pagehide", callback, opts);\n    return function () {\n      window.removeEventListener("pagehide", callback, opts);\n    };\n  }, [callback, capture]);\n}\n/**\n * Wrapper around useBlocker to show a window.confirm prompt to users instead\n * of building a custom UI with useBlocker.\n *\n * Warning: This has *a lot of rough edges* and behaves very differently (and\n * very incorrectly in some cases) across browsers if user click addition\n * back/forward navigations while the confirm is open.  Use at your own risk.\n */\nfunction usePrompt(_ref12) {\n  var when = _ref12.when,\n    message = _ref12.message;\n  var blocker = (0,react_router__WEBPACK_IMPORTED_MODULE_3__/* .useBlocker */ ._Z)(when);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    if (blocker.state === "blocked") {\n      var proceed = window.confirm(message);\n      if (proceed) {\n        // This timeout is needed to avoid a weird "race" on POP navigations\n        // between the `window.history` revert navigation and the result of\n        // `window.confirm`\n        setTimeout(blocker.proceed, 0);\n      } else {\n        blocker.reset();\n      }\n    }\n  }, [blocker, message]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    if (blocker.state === "blocked" && !when) {\n      blocker.reset();\n    }\n  }, [blocker, when]);\n}\n/**\n * Return a boolean indicating if there is an active view transition to the\n * given href.  You can use this value to render CSS classes or viewTransitionName\n * styles onto your elements\n *\n * @param href The destination href\n * @param [opts.relative] Relative routing type ("route" | "path")\n */\nfunction useViewTransitionState(to, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  var vtContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ViewTransitionContext);\n  !(vtContext != null) ?  false ? 0 : (0,react_router__WEBPACK_IMPORTED_MODULE_2__/* .UNSAFE_invariant */ .J0)(false) : void 0;\n  var _useDataRouterContext4 = useDataRouterContext(DataRouterHook.useViewTransitionState),\n    basename = _useDataRouterContext4.basename;\n  var path = (0,react_router__WEBPACK_IMPORTED_MODULE_3__/* .useResolvedPath */ .WU)(to, {\n    relative: opts.relative\n  });\n  if (!vtContext.isTransitioning) {\n    return false;\n  }\n  var currentPath = (0,react_router__WEBPACK_IMPORTED_MODULE_2__/* .stripBasename */ .Zn)(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;\n  var nextPath = (0,react_router__WEBPACK_IMPORTED_MODULE_2__/* .stripBasename */ .Zn)(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;\n  // Transition is active if we\'re going to or coming from the indicated\n  // destination.  This ensures that other PUSH navigations that reverse\n  // an indicated transition apply.  I.e., on the list view you have:\n  //\n  //   <NavLink to="/details/1" unstable_viewTransition>\n  //\n  // If you click the breadcrumb back to the list view:\n  //\n  //   <NavLink to="/list" unstable_viewTransition>\n  //\n  // We should apply the transition because it\'s indicated as active going\n  // from /list -> /details/1 and therefore should be active on the reverse\n  // (even though this isn\'t strictly a POP reverse)\n  return (0,react_router__WEBPACK_IMPORTED_MODULE_2__/* .matchPath */ .LX)(path.pathname, nextPath) != null || (0,react_router__WEBPACK_IMPORTED_MODULE_2__/* .matchPath */ .LX)(path.pathname, currentPath) != null;\n}\n//#endregion\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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dkVBLHdFQUFTO0VBTVQsSUFBQWlILHNCQUFBLEdBQW1Cbkgsb0JBQW9CLENBQ3JDSixjQUFjLENBQUN2QyxzQkFBc0IsQ0FDdEM7SUFGS25QLFFBQUEsR0FBQWlaLHNCQUFBLENBQUFqWixRQUFBO0VBR04sSUFBSXNOLElBQUksR0FBR3lCLHVFQUFlLENBQUNyRixFQUFFLEVBQUU7SUFBRTBDLFFBQVEsRUFBRXBMLElBQUksQ0FBQ29MO0VBQVEsQ0FBRSxDQUFDO0VBQzNELElBQUksQ0FBQ3hHLFNBQVMsQ0FBQ25DLGVBQWUsRUFBRTtJQUM5QixPQUFPLEtBQUs7RUFDYjtFQUVELElBQUl5VixXQUFXLEdBQ2IzWSxxRUFBYSxDQUFDcUYsU0FBUyxDQUFDbUMsZUFBZSxDQUFDd0YsUUFBUSxFQUFFdk4sUUFBUSxDQUFDLElBQzNENEYsU0FBUyxDQUFDbUMsZUFBZSxDQUFDd0YsUUFBUTtFQUNwQyxJQUFJNEwsUUFBUSxHQUNWNVkscUVBQWEsQ0FBQ3FGLFNBQVMsQ0FBQ29DLFlBQVksQ0FBQ3VGLFFBQVEsRUFBRXZOLFFBQVEsQ0FBQyxJQUN4RDRGLFNBQVMsQ0FBQ29DLFlBQVksQ0FBQ3VGLFFBQVE7RUFFakM7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQSxPQUNFNkwsaUVBQVMsQ0FBQzlMLElBQUksQ0FBQ0MsUUFBUSxFQUFFNEwsUUFBUSxDQUFDLElBQUksSUFBSSxJQUMxQ0MsaUVBQVMsQ0FBQzlMLElBQUksQ0FBQ0MsUUFBUSxFQUFFMkwsV0FBVyxDQUFDLElBQUksSUFBSTtBQUVqRDtBQUlBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVpbC8uLi9kb20udHM/NjcxYSIsIndlYnBhY2s6Ly9xdWlsLy4uL2luZGV4LnRzeD80NWViIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHtcbiAgRm9ybUVuY1R5cGUsXG4gIEhUTUxGb3JtTWV0aG9kLFxuICBSZWxhdGl2ZVJvdXRpbmdUeXBlLFxufSBmcm9tIFwiQHJlbWl4LXJ1bi9yb3V0ZXJcIjtcbmltcG9ydCB7IHN0cmlwQmFzZW5hbWUsIFVOU0FGRV93YXJuaW5nIGFzIHdhcm5pbmcgfSBmcm9tIFwiQHJlbWl4LXJ1bi9yb3V0ZXJcIjtcblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRNZXRob2Q6IEhUTUxGb3JtTWV0aG9kID0gXCJnZXRcIjtcbmNvbnN0IGRlZmF1bHRFbmNUeXBlOiBGb3JtRW5jVHlwZSA9IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0h0bWxFbGVtZW50KG9iamVjdDogYW55KTogb2JqZWN0IGlzIEhUTUxFbGVtZW50IHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIHR5cGVvZiBvYmplY3QudGFnTmFtZSA9PT0gXCJzdHJpbmdcIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQnV0dG9uRWxlbWVudChvYmplY3Q6IGFueSk6IG9iamVjdCBpcyBIVE1MQnV0dG9uRWxlbWVudCB7XG4gIHJldHVybiBpc0h0bWxFbGVtZW50KG9iamVjdCkgJiYgb2JqZWN0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJidXR0b25cIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRm9ybUVsZW1lbnQob2JqZWN0OiBhbnkpOiBvYmplY3QgaXMgSFRNTEZvcm1FbGVtZW50IHtcbiAgcmV0dXJuIGlzSHRtbEVsZW1lbnQob2JqZWN0KSAmJiBvYmplY3QudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImZvcm1cIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzSW5wdXRFbGVtZW50KG9iamVjdDogYW55KTogb2JqZWN0IGlzIEhUTUxJbnB1dEVsZW1lbnQge1xuICByZXR1cm4gaXNIdG1sRWxlbWVudChvYmplY3QpICYmIG9iamVjdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIjtcbn1cblxudHlwZSBMaW1pdGVkTW91c2VFdmVudCA9IFBpY2s8XG4gIE1vdXNlRXZlbnQsXG4gIFwiYnV0dG9uXCIgfCBcIm1ldGFLZXlcIiB8IFwiYWx0S2V5XCIgfCBcImN0cmxLZXlcIiB8IFwic2hpZnRLZXlcIlxuPjtcblxuZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50OiBMaW1pdGVkTW91c2VFdmVudCkge1xuICByZXR1cm4gISEoZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRQcm9jZXNzTGlua0NsaWNrKFxuICBldmVudDogTGltaXRlZE1vdXNlRXZlbnQsXG4gIHRhcmdldD86IHN0cmluZ1xuKSB7XG4gIHJldHVybiAoXG4gICAgZXZlbnQuYnV0dG9uID09PSAwICYmIC8vIElnbm9yZSBldmVyeXRoaW5nIGJ1dCBsZWZ0IGNsaWNrc1xuICAgICghdGFyZ2V0IHx8IHRhcmdldCA9PT0gXCJfc2VsZlwiKSAmJiAvLyBMZXQgYnJvd3NlciBoYW5kbGUgXCJ0YXJnZXQ9X2JsYW5rXCIgZXRjLlxuICAgICFpc01vZGlmaWVkRXZlbnQoZXZlbnQpIC8vIElnbm9yZSBjbGlja3Mgd2l0aCBtb2RpZmllciBrZXlzXG4gICk7XG59XG5cbmV4cG9ydCB0eXBlIFBhcmFtS2V5VmFsdWVQYWlyID0gW3N0cmluZywgc3RyaW5nXTtcblxuZXhwb3J0IHR5cGUgVVJMU2VhcmNoUGFyYW1zSW5pdCA9XG4gIHwgc3RyaW5nXG4gIHwgUGFyYW1LZXlWYWx1ZVBhaXJbXVxuICB8IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHN0cmluZ1tdPlxuICB8IFVSTFNlYXJjaFBhcmFtcztcblxuLyoqXG4gKiBDcmVhdGVzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCB1c2luZyB0aGUgZ2l2ZW4gaW5pdGlhbGl6ZXIuXG4gKlxuICogVGhpcyBpcyBpZGVudGljYWwgdG8gYG5ldyBVUkxTZWFyY2hQYXJhbXMoaW5pdClgIGV4Y2VwdCBpdCBhbHNvXG4gKiBzdXBwb3J0cyBhcnJheXMgYXMgdmFsdWVzIGluIHRoZSBvYmplY3QgZm9ybSBvZiB0aGUgaW5pdGlhbGl6ZXJcbiAqIGluc3RlYWQgb2YganVzdCBzdHJpbmdzLiBUaGlzIGlzIGNvbnZlbmllbnQgd2hlbiB5b3UgbmVlZCBtdWx0aXBsZVxuICogdmFsdWVzIGZvciBhIGdpdmVuIGtleSwgYnV0IGRvbid0IHdhbnQgdG8gdXNlIGFuIGFycmF5IGluaXRpYWxpemVyLlxuICpcbiAqIEZvciBleGFtcGxlLCBpbnN0ZWFkIG9mOlxuICpcbiAqICAgbGV0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoW1xuICogICAgIFsnc29ydCcsICduYW1lJ10sXG4gKiAgICAgWydzb3J0JywgJ3ByaWNlJ11cbiAqICAgXSk7XG4gKlxuICogeW91IGNhbiBkbzpcbiAqXG4gKiAgIGxldCBzZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXMoe1xuICogICAgIHNvcnQ6IFsnbmFtZScsICdwcmljZSddXG4gKiAgIH0pO1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VhcmNoUGFyYW1zKFxuICBpbml0OiBVUkxTZWFyY2hQYXJhbXNJbml0ID0gXCJcIlxuKTogVVJMU2VhcmNoUGFyYW1zIHtcbiAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXMoXG4gICAgdHlwZW9mIGluaXQgPT09IFwic3RyaW5nXCIgfHxcbiAgICBBcnJheS5pc0FycmF5KGluaXQpIHx8XG4gICAgaW5pdCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtc1xuICAgICAgPyBpbml0XG4gICAgICA6IE9iamVjdC5rZXlzKGluaXQpLnJlZHVjZSgobWVtbywga2V5KSA9PiB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gaW5pdFtrZXldO1xuICAgICAgICAgIHJldHVybiBtZW1vLmNvbmNhdChcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKCh2KSA9PiBba2V5LCB2XSkgOiBbW2tleSwgdmFsdWVdXVxuICAgICAgICAgICk7XG4gICAgICAgIH0sIFtdIGFzIFBhcmFtS2V5VmFsdWVQYWlyW10pXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWFyY2hQYXJhbXNGb3JMb2NhdGlvbihcbiAgbG9jYXRpb25TZWFyY2g6IHN0cmluZyxcbiAgZGVmYXVsdFNlYXJjaFBhcmFtczogVVJMU2VhcmNoUGFyYW1zIHwgbnVsbFxuKSB7XG4gIGxldCBzZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXMobG9jYXRpb25TZWFyY2gpO1xuXG4gIGlmIChkZWZhdWx0U2VhcmNoUGFyYW1zKSB7XG4gICAgLy8gVXNlIGBkZWZhdWx0U2VhcmNoUGFyYW1zLmZvckVhY2goLi4uKWAgaGVyZSBpbnN0ZWFkIG9mIGl0ZXJhdGluZyBvZlxuICAgIC8vIGBkZWZhdWx0U2VhcmNoUGFyYW1zLmtleXMoKWAgdG8gd29yay1hcm91bmQgYSBidWcgaW4gRmlyZWZveCByZWxhdGVkIHRvXG4gICAgLy8gd2ViIGV4dGVuc2lvbnMuIFJlbGV2YW50IEJ1Z3ppbGxhIHRpY2tldHM6XG4gICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQxNDYwMlxuICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEwMjM5ODRcbiAgICBkZWZhdWx0U2VhcmNoUGFyYW1zLmZvckVhY2goKF8sIGtleSkgPT4ge1xuICAgICAgaWYgKCFzZWFyY2hQYXJhbXMuaGFzKGtleSkpIHtcbiAgICAgICAgZGVmYXVsdFNlYXJjaFBhcmFtcy5nZXRBbGwoa2V5KS5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHNlYXJjaFBhcmFtcztcbn1cblxuLy8gVGhhbmtzIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvdHlwZS1mZXN0IVxudHlwZSBKc29uT2JqZWN0ID0geyBbS2V5IGluIHN0cmluZ106IEpzb25WYWx1ZSB9ICYge1xuICBbS2V5IGluIHN0cmluZ10/OiBKc29uVmFsdWUgfCB1bmRlZmluZWQ7XG59O1xudHlwZSBKc29uQXJyYXkgPSBKc29uVmFsdWVbXSB8IHJlYWRvbmx5IEpzb25WYWx1ZVtdO1xudHlwZSBKc29uUHJpbWl0aXZlID0gc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IG51bGw7XG50eXBlIEpzb25WYWx1ZSA9IEpzb25QcmltaXRpdmUgfCBKc29uT2JqZWN0IHwgSnNvbkFycmF5O1xuXG5leHBvcnQgdHlwZSBTdWJtaXRUYXJnZXQgPVxuICB8IEhUTUxGb3JtRWxlbWVudFxuICB8IEhUTUxCdXR0b25FbGVtZW50XG4gIHwgSFRNTElucHV0RWxlbWVudFxuICB8IEZvcm1EYXRhXG4gIHwgVVJMU2VhcmNoUGFyYW1zXG4gIHwgSnNvblZhbHVlXG4gIHwgbnVsbDtcblxuLy8gT25lLXRpbWUgY2hlY2sgZm9yIHN1Ym1pdHRlciBzdXBwb3J0XG5sZXQgX2Zvcm1EYXRhU3VwcG9ydHNTdWJtaXR0ZXI6IGJvb2xlYW4gfCBudWxsID0gbnVsbDtcblxuZnVuY3Rpb24gaXNGb3JtRGF0YVN1Ym1pdHRlclN1cHBvcnRlZCgpIHtcbiAgaWYgKF9mb3JtRGF0YVN1cHBvcnRzU3VibWl0dGVyID09PSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBGb3JtRGF0YShcbiAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZvcm1cIiksXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgaWYgRm9ybURhdGEgc3VwcG9ydHMgdGhlIHN1Ym1pdHRlciBwYXJhbWV0ZXIsIHRoaXMgd2lsbCB0aHJvd1xuICAgICAgICAwXG4gICAgICApO1xuICAgICAgX2Zvcm1EYXRhU3VwcG9ydHNTdWJtaXR0ZXIgPSBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlciA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdWJtaXRPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBIVFRQIG1ldGhvZCB1c2VkIHRvIHN1Ym1pdCB0aGUgZm9ybS4gT3ZlcnJpZGVzIGA8Zm9ybSBtZXRob2Q+YC5cbiAgICogRGVmYXVsdHMgdG8gXCJHRVRcIi5cbiAgICovXG4gIG1ldGhvZD86IEhUTUxGb3JtTWV0aG9kO1xuXG4gIC8qKlxuICAgKiBUaGUgYWN0aW9uIFVSTCBwYXRoIHVzZWQgdG8gc3VibWl0IHRoZSBmb3JtLiBPdmVycmlkZXMgYDxmb3JtIGFjdGlvbj5gLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgcGF0aCBvZiB0aGUgY3VycmVudCByb3V0ZS5cbiAgICovXG4gIGFjdGlvbj86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGVuY29kaW5nIHVzZWQgdG8gc3VibWl0IHRoZSBmb3JtLiBPdmVycmlkZXMgYDxmb3JtIGVuY1R5cGU+YC5cbiAgICogRGVmYXVsdHMgdG8gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIi5cbiAgICovXG4gIGVuY1R5cGU/OiBGb3JtRW5jVHlwZTtcblxuICAvKipcbiAgICogSW5kaWNhdGUgYSBzcGVjaWZpYyBmZXRjaGVyS2V5IHRvIHVzZSB3aGVuIHVzaW5nIG5hdmlnYXRlPWZhbHNlXG4gICAqL1xuICBmZXRjaGVyS2V5Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBuYXZpZ2F0ZT1mYWxzZSB3aWxsIHVzZSBhIGZldGNoZXIgaW5zdGVhZCBvZiBhIG5hdmlnYXRpb25cbiAgICovXG4gIG5hdmlnYXRlPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogU2V0IGB0cnVlYCB0byByZXBsYWNlIHRoZSBjdXJyZW50IGVudHJ5IGluIHRoZSBicm93c2VyJ3MgaGlzdG9yeSBzdGFja1xuICAgKiBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgbmV3IG9uZSAoaS5lLiBzdGF5IG9uIFwidGhlIHNhbWUgcGFnZVwiKS4gRGVmYXVsdHNcbiAgICogdG8gYGZhbHNlYC5cbiAgICovXG4gIHJlcGxhY2U/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBTdGF0ZSBvYmplY3QgdG8gYWRkIHRvIHRoZSBoaXN0b3J5IHN0YWNrIGVudHJ5IGZvciB0aGlzIG5hdmlnYXRpb25cbiAgICovXG4gIHN0YXRlPzogYW55O1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGZvcm0gYWN0aW9uIGlzIHJlbGF0aXZlIHRvIHRoZSByb3V0ZSBoaWVyYXJjaHkgb3JcbiAgICogdGhlIHBhdGhuYW1lLiAgVXNlIHRoaXMgaWYgeW91IHdhbnQgdG8gb3B0IG91dCBvZiBuYXZpZ2F0aW5nIHRoZSByb3V0ZVxuICAgKiBoaWVyYXJjaHkgYW5kIHdhbnQgdG8gaW5zdGVhZCByb3V0ZSBiYXNlZCBvbiAvLWRlbGltaXRlZCBVUkwgc2VnbWVudHNcbiAgICovXG4gIHJlbGF0aXZlPzogUmVsYXRpdmVSb3V0aW5nVHlwZTtcblxuICAvKipcbiAgICogSW4gYnJvd3Nlci1iYXNlZCBlbnZpcm9ubWVudHMsIHByZXZlbnQgcmVzZXR0aW5nIHNjcm9sbCBhZnRlciB0aGlzXG4gICAqIG5hdmlnYXRpb24gd2hlbiB1c2luZyB0aGUgPFNjcm9sbFJlc3RvcmF0aW9uPiBjb21wb25lbnRcbiAgICovXG4gIHByZXZlbnRTY3JvbGxSZXNldD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEVuYWJsZSBmbHVzaFN5bmMgZm9yIHRoaXMgbmF2aWdhdGlvbidzIHN0YXRlIHVwZGF0ZXNcbiAgICovXG4gIHVuc3RhYmxlX2ZsdXNoU3luYz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEVuYWJsZSB2aWV3IHRyYW5zaXRpb25zIG9uIHRoaXMgc3VibWlzc2lvbiBuYXZpZ2F0aW9uXG4gICAqL1xuICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbj86IGJvb2xlYW47XG59XG5cbmNvbnN0IHN1cHBvcnRlZEZvcm1FbmNUeXBlczogU2V0PEZvcm1FbmNUeXBlPiA9IG5ldyBTZXQoW1xuICBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLFxuICBcIm11bHRpcGFydC9mb3JtLWRhdGFcIixcbiAgXCJ0ZXh0L3BsYWluXCIsXG5dKTtcblxuZnVuY3Rpb24gZ2V0Rm9ybUVuY1R5cGUoZW5jVHlwZTogc3RyaW5nIHwgbnVsbCkge1xuICBpZiAoZW5jVHlwZSAhPSBudWxsICYmICFzdXBwb3J0ZWRGb3JtRW5jVHlwZXMuaGFzKGVuY1R5cGUgYXMgRm9ybUVuY1R5cGUpKSB7XG4gICAgd2FybmluZyhcbiAgICAgIGZhbHNlLFxuICAgICAgYFwiJHtlbmNUeXBlfVwiIGlzIG5vdCBhIHZhbGlkIFxcYGVuY1R5cGVcXGAgZm9yIFxcYDxGb3JtPlxcYC9cXGA8ZmV0Y2hlci5Gb3JtPlxcYCBgICtcbiAgICAgICAgYGFuZCB3aWxsIGRlZmF1bHQgdG8gXCIke2RlZmF1bHRFbmNUeXBlfVwiYFxuICAgICk7XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gZW5jVHlwZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZvcm1TdWJtaXNzaW9uSW5mbyhcbiAgdGFyZ2V0OiBTdWJtaXRUYXJnZXQsXG4gIGJhc2VuYW1lOiBzdHJpbmdcbik6IHtcbiAgYWN0aW9uOiBzdHJpbmcgfCBudWxsO1xuICBtZXRob2Q6IHN0cmluZztcbiAgZW5jVHlwZTogc3RyaW5nO1xuICBmb3JtRGF0YTogRm9ybURhdGEgfCB1bmRlZmluZWQ7XG4gIGJvZHk6IGFueTtcbn0ge1xuICBsZXQgbWV0aG9kOiBzdHJpbmc7XG4gIGxldCBhY3Rpb246IHN0cmluZyB8IG51bGw7XG4gIGxldCBlbmNUeXBlOiBzdHJpbmc7XG4gIGxldCBmb3JtRGF0YTogRm9ybURhdGEgfCB1bmRlZmluZWQ7XG4gIGxldCBib2R5OiBhbnk7XG5cbiAgaWYgKGlzRm9ybUVsZW1lbnQodGFyZ2V0KSkge1xuICAgIC8vIFdoZW4gZ3JhYmJpbmcgdGhlIGFjdGlvbiBmcm9tIHRoZSBlbGVtZW50LCBpdCB3aWxsIGhhdmUgaGFkIHRoZSBiYXNlbmFtZVxuICAgIC8vIHByZWZpeGVkIHRvIGVuc3VyZSBub24tSlMgc2NlbmFyaW9zIHdvcmssIHNvIHN0cmlwIGl0IHNpbmNlIHdlJ2xsXG4gICAgLy8gcmUtcHJlZml4IGluIHRoZSByb3V0ZXJcbiAgICBsZXQgYXR0ciA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJhY3Rpb25cIik7XG4gICAgYWN0aW9uID0gYXR0ciA/IHN0cmlwQmFzZW5hbWUoYXR0ciwgYmFzZW5hbWUpIDogbnVsbDtcbiAgICBtZXRob2QgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwibWV0aG9kXCIpIHx8IGRlZmF1bHRNZXRob2Q7XG4gICAgZW5jVHlwZSA9IGdldEZvcm1FbmNUeXBlKHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJlbmN0eXBlXCIpKSB8fCBkZWZhdWx0RW5jVHlwZTtcblxuICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKHRhcmdldCk7XG4gIH0gZWxzZSBpZiAoXG4gICAgaXNCdXR0b25FbGVtZW50KHRhcmdldCkgfHxcbiAgICAoaXNJbnB1dEVsZW1lbnQodGFyZ2V0KSAmJlxuICAgICAgKHRhcmdldC50eXBlID09PSBcInN1Ym1pdFwiIHx8IHRhcmdldC50eXBlID09PSBcImltYWdlXCIpKVxuICApIHtcbiAgICBsZXQgZm9ybSA9IHRhcmdldC5mb3JtO1xuXG4gICAgaWYgKGZvcm0gPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IHN1Ym1pdCBhIDxidXR0b24+IG9yIDxpbnB1dCB0eXBlPVwic3VibWl0XCI+IHdpdGhvdXQgYSA8Zm9ybT5gXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIDxidXR0b24+LzxpbnB1dCB0eXBlPVwic3VibWl0XCI+IG1heSBvdmVycmlkZSBhdHRyaWJ1dGVzIG9mIDxmb3JtPlxuXG4gICAgLy8gV2hlbiBncmFiYmluZyB0aGUgYWN0aW9uIGZyb20gdGhlIGVsZW1lbnQsIGl0IHdpbGwgaGF2ZSBoYWQgdGhlIGJhc2VuYW1lXG4gICAgLy8gcHJlZml4ZWQgdG8gZW5zdXJlIG5vbi1KUyBzY2VuYXJpb3Mgd29yaywgc28gc3RyaXAgaXQgc2luY2Ugd2UnbGxcbiAgICAvLyByZS1wcmVmaXggaW4gdGhlIHJvdXRlclxuICAgIGxldCBhdHRyID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImZvcm1hY3Rpb25cIikgfHwgZm9ybS5nZXRBdHRyaWJ1dGUoXCJhY3Rpb25cIik7XG4gICAgYWN0aW9uID0gYXR0ciA/IHN0cmlwQmFzZW5hbWUoYXR0ciwgYmFzZW5hbWUpIDogbnVsbDtcblxuICAgIG1ldGhvZCA9XG4gICAgICB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZm9ybW1ldGhvZFwiKSB8fFxuICAgICAgZm9ybS5nZXRBdHRyaWJ1dGUoXCJtZXRob2RcIikgfHxcbiAgICAgIGRlZmF1bHRNZXRob2Q7XG4gICAgZW5jVHlwZSA9XG4gICAgICBnZXRGb3JtRW5jVHlwZSh0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZm9ybWVuY3R5cGVcIikpIHx8XG4gICAgICBnZXRGb3JtRW5jVHlwZShmb3JtLmdldEF0dHJpYnV0ZShcImVuY3R5cGVcIikpIHx8XG4gICAgICBkZWZhdWx0RW5jVHlwZTtcblxuICAgIC8vIEJ1aWxkIGEgRm9ybURhdGEgb2JqZWN0IHBvcHVsYXRlZCBmcm9tIGEgZm9ybSBhbmQgc3VibWl0dGVyXG4gICAgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoZm9ybSwgdGFyZ2V0KTtcblxuICAgIC8vIElmIHRoaXMgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgdGhlIGBGb3JtRGF0YShlbCwgc3VibWl0dGVyKWAgZm9ybWF0LFxuICAgIC8vIHRoZW4gdGFjayBvbiB0aGUgc3VibWl0dGVyIHZhbHVlIGF0IHRoZSBlbmQuICBUaGlzIGlzIGEgbGlnaHR3ZWlnaHRcbiAgICAvLyBzb2x1dGlvbiB0aGF0IGlzIG5vdCAxMDAlIHNwZWMgY29tcGxpYW50LiAgRm9yIGNvbXBsZXRlIHN1cHBvcnQgaW4gb2xkZXJcbiAgICAvLyBicm93c2VycywgY29uc2lkZXIgdXNpbmcgdGhlIGBmb3JtZGF0YS1zdWJtaXR0ZXItcG9seWZpbGxgIHBhY2thZ2VcbiAgICBpZiAoIWlzRm9ybURhdGFTdWJtaXR0ZXJTdXBwb3J0ZWQoKSkge1xuICAgICAgbGV0IHsgbmFtZSwgdHlwZSwgdmFsdWUgfSA9IHRhcmdldDtcbiAgICAgIGlmICh0eXBlID09PSBcImltYWdlXCIpIHtcbiAgICAgICAgbGV0IHByZWZpeCA9IG5hbWUgPyBgJHtuYW1lfS5gIDogXCJcIjtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKGAke3ByZWZpeH14YCwgXCIwXCIpO1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoYCR7cHJlZml4fXlgLCBcIjBcIik7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUpIHtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNIdG1sRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENhbm5vdCBzdWJtaXQgZWxlbWVudCB0aGF0IGlzIG5vdCA8Zm9ybT4sIDxidXR0b24+LCBvciBgICtcbiAgICAgICAgYDxpbnB1dCB0eXBlPVwic3VibWl0fGltYWdlXCI+YFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgbWV0aG9kID0gZGVmYXVsdE1ldGhvZDtcbiAgICBhY3Rpb24gPSBudWxsO1xuICAgIGVuY1R5cGUgPSBkZWZhdWx0RW5jVHlwZTtcbiAgICBib2R5ID0gdGFyZ2V0O1xuICB9XG5cbiAgLy8gU2VuZCBib2R5IGZvciA8Rm9ybSBlbmNUeXBlPVwidGV4dC9wbGFpblwiIHNvIHdlIGVuY29kZSBpdCBpbnRvIHRleHRcbiAgaWYgKGZvcm1EYXRhICYmIGVuY1R5cGUgPT09IFwidGV4dC9wbGFpblwiKSB7XG4gICAgYm9keSA9IGZvcm1EYXRhO1xuICAgIGZvcm1EYXRhID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIHsgYWN0aW9uLCBtZXRob2Q6IG1ldGhvZC50b0xvd2VyQ2FzZSgpLCBlbmNUeXBlLCBmb3JtRGF0YSwgYm9keSB9O1xufVxuIiwiLyoqXG4gKiBOT1RFOiBJZiB5b3UgcmVmYWN0b3IgdGhpcyB0byBzcGxpdCB1cCB0aGUgbW9kdWxlcyBpbnRvIHNlcGFyYXRlIGZpbGVzLFxuICogeW91J2xsIG5lZWQgdG8gdXBkYXRlIHRoZSByb2xsdXAgY29uZmlnIGZvciByZWFjdC1yb3V0ZXItZG9tLXY1LWNvbXBhdC5cbiAqL1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgKiBhcyBSZWFjdERPTSBmcm9tIFwicmVhY3QtZG9tXCI7XG5pbXBvcnQgdHlwZSB7XG4gIERhdGFSb3V0ZU9iamVjdCxcbiAgRnV0dXJlQ29uZmlnLFxuICBMb2NhdGlvbixcbiAgTmF2aWdhdGVPcHRpb25zLFxuICBOYXZpZ2F0aW9uVHlwZSxcbiAgTmF2aWdhdG9yLFxuICBSZWxhdGl2ZVJvdXRpbmdUeXBlLFxuICBSb3V0ZU9iamVjdCxcbiAgUm91dGVyUHJvdmlkZXJQcm9wcyxcbiAgVG8sXG59IGZyb20gXCJyZWFjdC1yb3V0ZXJcIjtcbmltcG9ydCB7XG4gIFJvdXRlcixcbiAgY3JlYXRlUGF0aCxcbiAgdXNlSHJlZixcbiAgdXNlTG9jYXRpb24sXG4gIHVzZU1hdGNoZXMsXG4gIHVzZU5hdmlnYXRlLFxuICB1c2VOYXZpZ2F0aW9uLFxuICB1c2VSZXNvbHZlZFBhdGgsXG4gIHVzZUJsb2NrZXIsXG4gIFVOU0FGRV9EYXRhUm91dGVyQ29udGV4dCBhcyBEYXRhUm91dGVyQ29udGV4dCxcbiAgVU5TQUZFX0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQgYXMgRGF0YVJvdXRlclN0YXRlQ29udGV4dCxcbiAgVU5TQUZFX05hdmlnYXRpb25Db250ZXh0IGFzIE5hdmlnYXRpb25Db250ZXh0LFxuICBVTlNBRkVfUm91dGVDb250ZXh0IGFzIFJvdXRlQ29udGV4dCxcbiAgVU5TQUZFX21hcFJvdXRlUHJvcGVydGllcyBhcyBtYXBSb3V0ZVByb3BlcnRpZXMsXG4gIFVOU0FGRV91c2VSb3V0ZUlkIGFzIHVzZVJvdXRlSWQsXG4gIFVOU0FGRV91c2VSb3V0ZXNJbXBsIGFzIHVzZVJvdXRlc0ltcGwsXG59IGZyb20gXCJyZWFjdC1yb3V0ZXJcIjtcbmltcG9ydCB0eXBlIHtcbiAgQnJvd3Nlckhpc3RvcnksXG4gIEZldGNoZXIsXG4gIEZvcm1FbmNUeXBlLFxuICBGb3JtTWV0aG9kLFxuICBGdXR1cmVDb25maWcgYXMgUm91dGVyRnV0dXJlQ29uZmlnLFxuICBHZXRTY3JvbGxSZXN0b3JhdGlvbktleUZ1bmN0aW9uLFxuICBIYXNoSGlzdG9yeSxcbiAgSGlzdG9yeSxcbiAgSFRNTEZvcm1NZXRob2QsXG4gIEh5ZHJhdGlvblN0YXRlLFxuICBSb3V0ZXIgYXMgUmVtaXhSb3V0ZXIsXG4gIFY3X0Zvcm1NZXRob2QsXG4gIFJvdXRlclN0YXRlLFxuICBSb3V0ZXJTdWJzY3JpYmVyLFxuICBCbG9ja2VyRnVuY3Rpb24sXG59IGZyb20gXCJAcmVtaXgtcnVuL3JvdXRlclwiO1xuaW1wb3J0IHtcbiAgY3JlYXRlUm91dGVyLFxuICBjcmVhdGVCcm93c2VySGlzdG9yeSxcbiAgY3JlYXRlSGFzaEhpc3RvcnksXG4gIGpvaW5QYXRocyxcbiAgc3RyaXBCYXNlbmFtZSxcbiAgVU5TQUZFX0Vycm9yUmVzcG9uc2VJbXBsIGFzIEVycm9yUmVzcG9uc2VJbXBsLFxuICBVTlNBRkVfaW52YXJpYW50IGFzIGludmFyaWFudCxcbiAgVU5TQUZFX3dhcm5pbmcgYXMgd2FybmluZyxcbiAgbWF0Y2hQYXRoLFxuICBJRExFX0ZFVENIRVIsXG59IGZyb20gXCJAcmVtaXgtcnVuL3JvdXRlclwiO1xuXG5pbXBvcnQgdHlwZSB7XG4gIFN1Ym1pdE9wdGlvbnMsXG4gIFBhcmFtS2V5VmFsdWVQYWlyLFxuICBVUkxTZWFyY2hQYXJhbXNJbml0LFxuICBTdWJtaXRUYXJnZXQsXG59IGZyb20gXCIuL2RvbVwiO1xuaW1wb3J0IHtcbiAgY3JlYXRlU2VhcmNoUGFyYW1zLFxuICBkZWZhdWx0TWV0aG9kLFxuICBnZXRGb3JtU3VibWlzc2lvbkluZm8sXG4gIGdldFNlYXJjaFBhcmFtc0ZvckxvY2F0aW9uLFxuICBzaG91bGRQcm9jZXNzTGlua0NsaWNrLFxufSBmcm9tIFwiLi9kb21cIjtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBSZS1leHBvcnRzXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHBvcnQgdHlwZSB7XG4gIEZvcm1FbmNUeXBlLFxuICBGb3JtTWV0aG9kLFxuICBHZXRTY3JvbGxSZXN0b3JhdGlvbktleUZ1bmN0aW9uLFxuICBQYXJhbUtleVZhbHVlUGFpcixcbiAgU3VibWl0T3B0aW9ucyxcbiAgVVJMU2VhcmNoUGFyYW1zSW5pdCxcbiAgVjdfRm9ybU1ldGhvZCxcbn07XG5leHBvcnQgeyBjcmVhdGVTZWFyY2hQYXJhbXMgfTtcblxuLy8gTm90ZTogS2VlcCBpbiBzeW5jIHdpdGggcmVhY3Qtcm91dGVyIGV4cG9ydHMhXG5leHBvcnQgdHlwZSB7XG4gIEFjdGlvbkZ1bmN0aW9uLFxuICBBY3Rpb25GdW5jdGlvbkFyZ3MsXG4gIEF3YWl0UHJvcHMsXG4gIHVuc3RhYmxlX0Jsb2NrZXIsXG4gIHVuc3RhYmxlX0Jsb2NrZXJGdW5jdGlvbixcbiAgRGF0YVJvdXRlTWF0Y2gsXG4gIERhdGFSb3V0ZU9iamVjdCxcbiAgRXJyb3JSZXNwb25zZSxcbiAgRmV0Y2hlcixcbiAgSGFzaCxcbiAgSW5kZXhSb3V0ZU9iamVjdCxcbiAgSW5kZXhSb3V0ZVByb3BzLFxuICBKc29uRnVuY3Rpb24sXG4gIExhenlSb3V0ZUZ1bmN0aW9uLFxuICBMYXlvdXRSb3V0ZVByb3BzLFxuICBMb2FkZXJGdW5jdGlvbixcbiAgTG9hZGVyRnVuY3Rpb25BcmdzLFxuICBMb2NhdGlvbixcbiAgTWVtb3J5Um91dGVyUHJvcHMsXG4gIE5hdmlnYXRlRnVuY3Rpb24sXG4gIE5hdmlnYXRlT3B0aW9ucyxcbiAgTmF2aWdhdGVQcm9wcyxcbiAgTmF2aWdhdGlvbixcbiAgTmF2aWdhdG9yLFxuICBOb25JbmRleFJvdXRlT2JqZWN0LFxuICBPdXRsZXRQcm9wcyxcbiAgUGFyYW1zLFxuICBQYXJhbVBhcnNlS2V5LFxuICBQYXRoLFxuICBQYXRoTWF0Y2gsXG4gIFBhdGhuYW1lLFxuICBQYXRoUGF0dGVybixcbiAgUGF0aFJvdXRlUHJvcHMsXG4gIFJlZGlyZWN0RnVuY3Rpb24sXG4gIFJlbGF0aXZlUm91dGluZ1R5cGUsXG4gIFJvdXRlTWF0Y2gsXG4gIFJvdXRlT2JqZWN0LFxuICBSb3V0ZVByb3BzLFxuICBSb3V0ZXJQcm9wcyxcbiAgUm91dGVyUHJvdmlkZXJQcm9wcyxcbiAgUm91dGVzUHJvcHMsXG4gIFNlYXJjaCxcbiAgU2hvdWxkUmV2YWxpZGF0ZUZ1bmN0aW9uLFxuICBTaG91bGRSZXZhbGlkYXRlRnVuY3Rpb25BcmdzLFxuICBUbyxcbiAgVUlNYXRjaCxcbn0gZnJvbSBcInJlYWN0LXJvdXRlclwiO1xuZXhwb3J0IHtcbiAgQWJvcnRlZERlZmVycmVkRXJyb3IsXG4gIEF3YWl0LFxuICBNZW1vcnlSb3V0ZXIsXG4gIE5hdmlnYXRlLFxuICBOYXZpZ2F0aW9uVHlwZSxcbiAgT3V0bGV0LFxuICBSb3V0ZSxcbiAgUm91dGVyLFxuICBSb3V0ZXMsXG4gIGNyZWF0ZU1lbW9yeVJvdXRlcixcbiAgY3JlYXRlUGF0aCxcbiAgY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuLFxuICBjcmVhdGVSb3V0ZXNGcm9tRWxlbWVudHMsXG4gIGRlZmVyLFxuICBpc1JvdXRlRXJyb3JSZXNwb25zZSxcbiAgZ2VuZXJhdGVQYXRoLFxuICBqc29uLFxuICBtYXRjaFBhdGgsXG4gIG1hdGNoUm91dGVzLFxuICBwYXJzZVBhdGgsXG4gIHJlZGlyZWN0LFxuICByZWRpcmVjdERvY3VtZW50LFxuICByZW5kZXJNYXRjaGVzLFxuICByZXNvbHZlUGF0aCxcbiAgdXNlQWN0aW9uRGF0YSxcbiAgdXNlQXN5bmNFcnJvcixcbiAgdXNlQXN5bmNWYWx1ZSxcbiAgdXNlQmxvY2tlcixcbiAgdXNlSHJlZixcbiAgdXNlSW5Sb3V0ZXJDb250ZXh0LFxuICB1c2VMb2FkZXJEYXRhLFxuICB1c2VMb2NhdGlvbixcbiAgdXNlTWF0Y2gsXG4gIHVzZU1hdGNoZXMsXG4gIHVzZU5hdmlnYXRlLFxuICB1c2VOYXZpZ2F0aW9uLFxuICB1c2VOYXZpZ2F0aW9uVHlwZSxcbiAgdXNlT3V0bGV0LFxuICB1c2VPdXRsZXRDb250ZXh0LFxuICB1c2VQYXJhbXMsXG4gIHVzZVJlc29sdmVkUGF0aCxcbiAgdXNlUmV2YWxpZGF0b3IsXG4gIHVzZVJvdXRlRXJyb3IsXG4gIHVzZVJvdXRlTG9hZGVyRGF0YSxcbiAgdXNlUm91dGVzLFxufSBmcm9tIFwicmVhY3Qtcm91dGVyXCI7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIERBTkdFUiEgUExFQVNFIFJFQUQgTUUhXG4vLyBXZSBwcm92aWRlIHRoZXNlIGV4cG9ydHMgYXMgYW4gZXNjYXBlIGhhdGNoIGluIHRoZSBldmVudCB0aGF0IHlvdSBuZWVkIGFueVxuLy8gcm91dGluZyBkYXRhIHRoYXQgd2UgZG9uJ3QgcHJvdmlkZSBhbiBleHBsaWNpdCBBUEkgZm9yLiBXaXRoIHRoYXQgc2FpZCwgd2Vcbi8vIHdhbnQgdG8gY292ZXIgeW91ciB1c2UgY2FzZSBpZiB3ZSBjYW4sIHNvIGlmIHlvdSBmZWVsIHRoZSBuZWVkIHRvIHVzZSB0aGVzZVxuLy8gd2Ugd2FudCB0byBoZWFyIGZyb20geW91LiBMZXQgdXMga25vdyB3aGF0IHlvdSdyZSBidWlsZGluZyBhbmQgd2UnbGwgZG8gb3VyXG4vLyBiZXN0IHRvIG1ha2Ugc3VyZSB3ZSBjYW4gc3VwcG9ydCB5b3UhXG4vL1xuLy8gV2UgY29uc2lkZXIgdGhlc2UgZXhwb3J0cyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgYW5kIGRvIG5vdCBndWFyYW50ZWVcbi8vIGFnYWluc3QgYW55IGJyZWFraW5nIGNoYW5nZXMsIHJlZ2FyZGxlc3Mgb2YgdGhlIHNlbXZlciByZWxlYXNlLiBVc2Ugd2l0aFxuLy8gZXh0cmVtZSBjYXV0aW9uIGFuZCBvbmx5IGlmIHlvdSB1bmRlcnN0YW5kIHRoZSBjb25zZXF1ZW5jZXMuIEdvZHNwZWVkLlxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKiogQGludGVybmFsICovXG5leHBvcnQge1xuICBVTlNBRkVfRGF0YVJvdXRlckNvbnRleHQsXG4gIFVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0LFxuICBVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQsXG4gIFVOU0FGRV9Mb2NhdGlvbkNvbnRleHQsXG4gIFVOU0FGRV9Sb3V0ZUNvbnRleHQsXG4gIFVOU0FGRV91c2VSb3V0ZUlkLFxufSBmcm9tIFwicmVhY3Qtcm91dGVyXCI7XG4vLyNlbmRyZWdpb25cblxuZGVjbGFyZSBnbG9iYWwge1xuICB2YXIgX19zdGF0aWNSb3V0ZXJIeWRyYXRpb25EYXRhOiBIeWRyYXRpb25TdGF0ZSB8IHVuZGVmaW5lZDtcbiAgaW50ZXJmYWNlIERvY3VtZW50IHtcbiAgICBzdGFydFZpZXdUcmFuc2l0aW9uKGNiOiAoKSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZCk6IFZpZXdUcmFuc2l0aW9uO1xuICB9XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gUm91dGVyc1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuaW50ZXJmYWNlIERPTVJvdXRlck9wdHMge1xuICBiYXNlbmFtZT86IHN0cmluZztcbiAgZnV0dXJlPzogUGFydGlhbDxPbWl0PFJvdXRlckZ1dHVyZUNvbmZpZywgXCJ2N19wcmVwZW5kQmFzZW5hbWVcIj4+O1xuICBoeWRyYXRpb25EYXRhPzogSHlkcmF0aW9uU3RhdGU7XG4gIHdpbmRvdz86IFdpbmRvdztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJSb3V0ZXIoXG4gIHJvdXRlczogUm91dGVPYmplY3RbXSxcbiAgb3B0cz86IERPTVJvdXRlck9wdHNcbik6IFJlbWl4Um91dGVyIHtcbiAgcmV0dXJuIGNyZWF0ZVJvdXRlcih7XG4gICAgYmFzZW5hbWU6IG9wdHM/LmJhc2VuYW1lLFxuICAgIGZ1dHVyZToge1xuICAgICAgLi4ub3B0cz8uZnV0dXJlLFxuICAgICAgdjdfcHJlcGVuZEJhc2VuYW1lOiB0cnVlLFxuICAgIH0sXG4gICAgaGlzdG9yeTogY3JlYXRlQnJvd3Nlckhpc3RvcnkoeyB3aW5kb3c6IG9wdHM/LndpbmRvdyB9KSxcbiAgICBoeWRyYXRpb25EYXRhOiBvcHRzPy5oeWRyYXRpb25EYXRhIHx8IHBhcnNlSHlkcmF0aW9uRGF0YSgpLFxuICAgIHJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMsXG4gICAgd2luZG93OiBvcHRzPy53aW5kb3csXG4gIH0pLmluaXRpYWxpemUoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhhc2hSb3V0ZXIoXG4gIHJvdXRlczogUm91dGVPYmplY3RbXSxcbiAgb3B0cz86IERPTVJvdXRlck9wdHNcbik6IFJlbWl4Um91dGVyIHtcbiAgcmV0dXJuIGNyZWF0ZVJvdXRlcih7XG4gICAgYmFzZW5hbWU6IG9wdHM/LmJhc2VuYW1lLFxuICAgIGZ1dHVyZToge1xuICAgICAgLi4ub3B0cz8uZnV0dXJlLFxuICAgICAgdjdfcHJlcGVuZEJhc2VuYW1lOiB0cnVlLFxuICAgIH0sXG4gICAgaGlzdG9yeTogY3JlYXRlSGFzaEhpc3RvcnkoeyB3aW5kb3c6IG9wdHM/LndpbmRvdyB9KSxcbiAgICBoeWRyYXRpb25EYXRhOiBvcHRzPy5oeWRyYXRpb25EYXRhIHx8IHBhcnNlSHlkcmF0aW9uRGF0YSgpLFxuICAgIHJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMsXG4gICAgd2luZG93OiBvcHRzPy53aW5kb3csXG4gIH0pLmluaXRpYWxpemUoKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VIeWRyYXRpb25EYXRhKCk6IEh5ZHJhdGlvblN0YXRlIHwgdW5kZWZpbmVkIHtcbiAgbGV0IHN0YXRlID0gd2luZG93Py5fX3N0YXRpY1JvdXRlckh5ZHJhdGlvbkRhdGE7XG4gIGlmIChzdGF0ZSAmJiBzdGF0ZS5lcnJvcnMpIHtcbiAgICBzdGF0ZSA9IHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgZXJyb3JzOiBkZXNlcmlhbGl6ZUVycm9ycyhzdGF0ZS5lcnJvcnMpLFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZUVycm9ycyhcbiAgZXJyb3JzOiBSZW1peFJvdXRlcltcInN0YXRlXCJdW1wiZXJyb3JzXCJdXG4pOiBSZW1peFJvdXRlcltcInN0YXRlXCJdW1wiZXJyb3JzXCJdIHtcbiAgaWYgKCFlcnJvcnMpIHJldHVybiBudWxsO1xuICBsZXQgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGVycm9ycyk7XG4gIGxldCBzZXJpYWxpemVkOiBSZW1peFJvdXRlcltcInN0YXRlXCJdW1wiZXJyb3JzXCJdID0ge307XG4gIGZvciAobGV0IFtrZXksIHZhbF0gb2YgZW50cmllcykge1xuICAgIC8vIEhleSB5b3UhICBJZiB5b3UgY2hhbmdlIHRoaXMsIHBsZWFzZSBjaGFuZ2UgdGhlIGNvcnJlc3BvbmRpbmcgbG9naWMgaW5cbiAgICAvLyBzZXJpYWxpemVFcnJvcnMgaW4gcmVhY3Qtcm91dGVyLWRvbS9zZXJ2ZXIudHN4IDopXG4gICAgaWYgKHZhbCAmJiB2YWwuX190eXBlID09PSBcIlJvdXRlRXJyb3JSZXNwb25zZVwiKSB7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSBuZXcgRXJyb3JSZXNwb25zZUltcGwoXG4gICAgICAgIHZhbC5zdGF0dXMsXG4gICAgICAgIHZhbC5zdGF0dXNUZXh0LFxuICAgICAgICB2YWwuZGF0YSxcbiAgICAgICAgdmFsLmludGVybmFsID09PSB0cnVlXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAodmFsICYmIHZhbC5fX3R5cGUgPT09IFwiRXJyb3JcIikge1xuICAgICAgLy8gQXR0ZW1wdCB0byByZWNvbnN0cnVjdCB0aGUgcmlnaHQgdHlwZSBvZiBFcnJvciAoaS5lLiwgUmVmZXJlbmNlRXJyb3IpXG4gICAgICBpZiAodmFsLl9fc3ViVHlwZSkge1xuICAgICAgICBsZXQgRXJyb3JDb25zdHJ1Y3RvciA9IHdpbmRvd1t2YWwuX19zdWJUeXBlXTtcbiAgICAgICAgaWYgKHR5cGVvZiBFcnJvckNvbnN0cnVjdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgbGV0IGVycm9yID0gbmV3IEVycm9yQ29uc3RydWN0b3IodmFsLm1lc3NhZ2UpO1xuICAgICAgICAgICAgLy8gV2lwZSBhd2F5IHRoZSBjbGllbnQtc2lkZSBzdGFjayB0cmFjZS4gIE5vdGhpbmcgdG8gZmlsbCBpdCBpbiB3aXRoXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHdlIGRvbid0IHNlcmlhbGl6ZSBTU1Igc3RhY2sgdHJhY2VzIGZvciBzZWN1cml0eSByZWFzb25zXG4gICAgICAgICAgICBlcnJvci5zdGFjayA9IFwiXCI7XG4gICAgICAgICAgICBzZXJpYWxpemVkW2tleV0gPSBlcnJvcjtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBuby1vcCAtIGZhbGwgdGhyb3VnaCBhbmQgY3JlYXRlIGEgbm9ybWFsIEVycm9yXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzZXJpYWxpemVkW2tleV0gPT0gbnVsbCkge1xuICAgICAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3IodmFsLm1lc3NhZ2UpO1xuICAgICAgICAvLyBXaXBlIGF3YXkgdGhlIGNsaWVudC1zaWRlIHN0YWNrIHRyYWNlLiAgTm90aGluZyB0byBmaWxsIGl0IGluIHdpdGhcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBkb24ndCBzZXJpYWxpemUgU1NSIHN0YWNrIHRyYWNlcyBmb3Igc2VjdXJpdHkgcmVhc29uc1xuICAgICAgICBlcnJvci5zdGFjayA9IFwiXCI7XG4gICAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZXJpYWxpemVkO1xufVxuXG4vLyNlbmRyZWdpb25cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBDb250ZXh0c1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxudHlwZSBWaWV3VHJhbnNpdGlvbkNvbnRleHRPYmplY3QgPVxuICB8IHtcbiAgICAgIGlzVHJhbnNpdGlvbmluZzogZmFsc2U7XG4gICAgfVxuICB8IHtcbiAgICAgIGlzVHJhbnNpdGlvbmluZzogdHJ1ZTtcbiAgICAgIGZsdXNoU3luYzogYm9vbGVhbjtcbiAgICAgIGN1cnJlbnRMb2NhdGlvbjogTG9jYXRpb247XG4gICAgICBuZXh0TG9jYXRpb246IExvY2F0aW9uO1xuICAgIH07XG5cbmNvbnN0IFZpZXdUcmFuc2l0aW9uQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8Vmlld1RyYW5zaXRpb25Db250ZXh0T2JqZWN0Pih7XG4gIGlzVHJhbnNpdGlvbmluZzogZmFsc2UsXG59KTtcbmlmIChfX0RFVl9fKSB7XG4gIFZpZXdUcmFuc2l0aW9uQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiVmlld1RyYW5zaXRpb25cIjtcbn1cblxuZXhwb3J0IHsgVmlld1RyYW5zaXRpb25Db250ZXh0IGFzIFVOU0FGRV9WaWV3VHJhbnNpdGlvbkNvbnRleHQgfTtcblxuLy8gVE9ETzogKHY3KSBDaGFuZ2UgdGhlIHVzZUZldGNoZXIgZGF0YSBmcm9tIGBhbnlgIHRvIGB1bmtub3duYFxudHlwZSBGZXRjaGVyc0NvbnRleHRPYmplY3QgPSBNYXA8c3RyaW5nLCBhbnk+O1xuXG5jb25zdCBGZXRjaGVyc0NvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PEZldGNoZXJzQ29udGV4dE9iamVjdD4obmV3IE1hcCgpKTtcbmlmIChfX0RFVl9fKSB7XG4gIEZldGNoZXJzQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiRmV0Y2hlcnNcIjtcbn1cblxuZXhwb3J0IHsgRmV0Y2hlcnNDb250ZXh0IGFzIFVOU0FGRV9GZXRjaGVyc0NvbnRleHQgfTtcblxuLy8jZW5kcmVnaW9uXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gQ29tcG9uZW50c1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gIFdlYnBhY2sgKyBSZWFjdCAxNyBmYWlscyB0byBjb21waWxlIG9uIGFueSBvZiB0aGUgZm9sbG93aW5nIGJlY2F1c2Ugd2VicGFja1xuICBjb21wbGFpbnMgdGhhdCBgc3RhcnRUcmFuc2l0aW9uYCBkb2Vzbid0IGV4aXN0IGluIGBSZWFjdGA6XG4gICogaW1wb3J0IHsgc3RhcnRUcmFuc2l0aW9uIH0gZnJvbSBcInJlYWN0XCJcbiAgKiBpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIGZyb20gXCJyZWFjdFwiO1xuICAgIFwic3RhcnRUcmFuc2l0aW9uXCIgaW4gUmVhY3QgPyBSZWFjdC5zdGFydFRyYW5zaXRpb24oKCkgPT4gc2V0U3RhdGUoKSkgOiBzZXRTdGF0ZSgpXG4gICogaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBmcm9tIFwicmVhY3RcIjtcbiAgICBcInN0YXJ0VHJhbnNpdGlvblwiIGluIFJlYWN0ID8gUmVhY3RbXCJzdGFydFRyYW5zaXRpb25cIl0oKCkgPT4gc2V0U3RhdGUoKSkgOiBzZXRTdGF0ZSgpXG5cbiAgTW92aW5nIGl0IHRvIGEgY29uc3RhbnQgc3VjaCBhcyB0aGUgZm9sbG93aW5nIHNvbHZlcyB0aGUgV2VicGFjay9SZWFjdCAxNyBpc3N1ZTpcbiAgKiBpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIGZyb20gXCJyZWFjdFwiO1xuICAgIGNvbnN0IFNUQVJUX1RSQU5TSVRJT04gPSBcInN0YXJ0VHJhbnNpdGlvblwiO1xuICAgIFNUQVJUX1RSQU5TSVRJT04gaW4gUmVhY3QgPyBSZWFjdFtTVEFSVF9UUkFOU0lUSU9OXSgoKSA9PiBzZXRTdGF0ZSgpKSA6IHNldFN0YXRlKClcblxuICBIb3dldmVyLCB0aGF0IGludHJvZHVjZXMgd2VicGFjay90ZXJzZXIgbWluaWZpY2F0aW9uIGlzc3VlcyBpbiBwcm9kdWN0aW9uIGJ1aWxkc1xuICBpbiBSZWFjdCAxOCB3aGVyZSBtaW5pZmljYXRpb24vb2JmdXNjYXRpb24gZW5kcyB1cCByZW1vdmluZyB0aGUgY2FsbCBvZlxuICBSZWFjdC5zdGFydFRyYW5zaXRpb24gZW50aXJlbHkgZnJvbSB0aGUgZmlyc3QgaGFsZiBvZiB0aGUgdGVybmFyeS4gIEdyYWJiaW5nXG4gIHRoaXMgZXhwb3J0ZWQgcmVmZXJlbmNlIG9uY2UgdXAgZnJvbnQgcmVzb2x2ZXMgdGhhdCBpc3N1ZS5cblxuICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9yZWFjdC1yb3V0ZXIvaXNzdWVzLzEwNTc5XG4qL1xuY29uc3QgU1RBUlRfVFJBTlNJVElPTiA9IFwic3RhcnRUcmFuc2l0aW9uXCI7XG5jb25zdCBzdGFydFRyYW5zaXRpb25JbXBsID0gUmVhY3RbU1RBUlRfVFJBTlNJVElPTl07XG5jb25zdCBGTFVTSF9TWU5DID0gXCJmbHVzaFN5bmNcIjtcbmNvbnN0IGZsdXNoU3luY0ltcGwgPSBSZWFjdERPTVtGTFVTSF9TWU5DXTtcblxuZnVuY3Rpb24gc3RhcnRUcmFuc2l0aW9uU2FmZShjYjogKCkgPT4gdm9pZCkge1xuICBpZiAoc3RhcnRUcmFuc2l0aW9uSW1wbCkge1xuICAgIHN0YXJ0VHJhbnNpdGlvbkltcGwoY2IpO1xuICB9IGVsc2Uge1xuICAgIGNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hTeW5jU2FmZShjYjogKCkgPT4gdm9pZCkge1xuICBpZiAoZmx1c2hTeW5jSW1wbCkge1xuICAgIGZsdXNoU3luY0ltcGwoY2IpO1xuICB9IGVsc2Uge1xuICAgIGNiKCk7XG4gIH1cbn1cblxuaW50ZXJmYWNlIFZpZXdUcmFuc2l0aW9uIHtcbiAgZmluaXNoZWQ6IFByb21pc2U8dm9pZD47XG4gIHJlYWR5OiBQcm9taXNlPHZvaWQ+O1xuICB1cGRhdGVDYWxsYmFja0RvbmU6IFByb21pc2U8dm9pZD47XG4gIHNraXBUcmFuc2l0aW9uKCk6IHZvaWQ7XG59XG5cbmNsYXNzIERlZmVycmVkPFQ+IHtcbiAgc3RhdHVzOiBcInBlbmRpbmdcIiB8IFwicmVzb2x2ZWRcIiB8IFwicmVqZWN0ZWRcIiA9IFwicGVuZGluZ1wiO1xuICBwcm9taXNlOiBQcm9taXNlPFQ+O1xuICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gbm8gaW5pdGlhbGl6ZXJcbiAgcmVzb2x2ZTogKHZhbHVlOiBUKSA9PiB2b2lkO1xuICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gbm8gaW5pdGlhbGl6ZXJcbiAgcmVqZWN0OiAocmVhc29uPzogdW5rbm93bikgPT4gdm9pZDtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5yZXNvbHZlID0gKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgICB0aGlzLnN0YXR1cyA9IFwicmVzb2x2ZWRcIjtcbiAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMucmVqZWN0ID0gKHJlYXNvbikgPT4ge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgdGhpcy5zdGF0dXMgPSBcInJlamVjdGVkXCI7XG4gICAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhIFJlbWl4IFJvdXRlciBpbnN0YW5jZSwgcmVuZGVyIHRoZSBhcHByb3ByaWF0ZSBVSVxuICovXG5leHBvcnQgZnVuY3Rpb24gUm91dGVyUHJvdmlkZXIoe1xuICBmYWxsYmFja0VsZW1lbnQsXG4gIHJvdXRlcixcbiAgZnV0dXJlLFxufTogUm91dGVyUHJvdmlkZXJQcm9wcyk6IFJlYWN0LlJlYWN0RWxlbWVudCB7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlSW1wbF0gPSBSZWFjdC51c2VTdGF0ZShyb3V0ZXIuc3RhdGUpO1xuICBsZXQgW3BlbmRpbmdTdGF0ZSwgc2V0UGVuZGluZ1N0YXRlXSA9IFJlYWN0LnVzZVN0YXRlPFJvdXRlclN0YXRlPigpO1xuICBsZXQgW3Z0Q29udGV4dCwgc2V0VnRDb250ZXh0XSA9IFJlYWN0LnVzZVN0YXRlPFZpZXdUcmFuc2l0aW9uQ29udGV4dE9iamVjdD4oe1xuICAgIGlzVHJhbnNpdGlvbmluZzogZmFsc2UsXG4gIH0pO1xuICBsZXQgW3JlbmRlckRmZCwgc2V0UmVuZGVyRGZkXSA9IFJlYWN0LnVzZVN0YXRlPERlZmVycmVkPHZvaWQ+PigpO1xuICBsZXQgW3RyYW5zaXRpb24sIHNldFRyYW5zaXRpb25dID0gUmVhY3QudXNlU3RhdGU8Vmlld1RyYW5zaXRpb24+KCk7XG4gIGxldCBbaW50ZXJydXB0aW9uLCBzZXRJbnRlcnJ1cHRpb25dID0gUmVhY3QudXNlU3RhdGU8e1xuICAgIHN0YXRlOiBSb3V0ZXJTdGF0ZTtcbiAgICBjdXJyZW50TG9jYXRpb246IExvY2F0aW9uO1xuICAgIG5leHRMb2NhdGlvbjogTG9jYXRpb247XG4gIH0+KCk7XG4gIGxldCBmZXRjaGVyRGF0YSA9IFJlYWN0LnVzZVJlZjxNYXA8c3RyaW5nLCBhbnk+PihuZXcgTWFwKCkpO1xuICBsZXQgeyB2N19zdGFydFRyYW5zaXRpb24gfSA9IGZ1dHVyZSB8fCB7fTtcblxuICBsZXQgb3B0SW5TdGFydFRyYW5zaXRpb24gPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAoY2I6ICgpID0+IHZvaWQpID0+IHtcbiAgICAgIGlmICh2N19zdGFydFRyYW5zaXRpb24pIHtcbiAgICAgICAgc3RhcnRUcmFuc2l0aW9uU2FmZShjYik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYigpO1xuICAgICAgfVxuICAgIH0sXG4gICAgW3Y3X3N0YXJ0VHJhbnNpdGlvbl1cbiAgKTtcblxuICBsZXQgc2V0U3RhdGUgPSBSZWFjdC51c2VDYWxsYmFjazxSb3V0ZXJTdWJzY3JpYmVyPihcbiAgICAoXG4gICAgICBuZXdTdGF0ZTogUm91dGVyU3RhdGUsXG4gICAgICB7XG4gICAgICAgIGRlbGV0ZWRGZXRjaGVycyxcbiAgICAgICAgdW5zdGFibGVfZmx1c2hTeW5jOiBmbHVzaFN5bmMsXG4gICAgICAgIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uT3B0czogdmlld1RyYW5zaXRpb25PcHRzLFxuICAgICAgfVxuICAgICkgPT4ge1xuICAgICAgZGVsZXRlZEZldGNoZXJzLmZvckVhY2goKGtleSkgPT4gZmV0Y2hlckRhdGEuY3VycmVudC5kZWxldGUoa2V5KSk7XG4gICAgICBuZXdTdGF0ZS5mZXRjaGVycy5mb3JFYWNoKChmZXRjaGVyLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKGZldGNoZXIuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZmV0Y2hlckRhdGEuY3VycmVudC5zZXQoa2V5LCBmZXRjaGVyLmRhdGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgbGV0IGlzVmlld1RyYW5zaXRpb25VbmF2YWlsYWJsZSA9XG4gICAgICAgIHJvdXRlci53aW5kb3cgPT0gbnVsbCB8fFxuICAgICAgICB0eXBlb2Ygcm91dGVyLndpbmRvdy5kb2N1bWVudC5zdGFydFZpZXdUcmFuc2l0aW9uICE9PSBcImZ1bmN0aW9uXCI7XG5cbiAgICAgIC8vIElmIHRoaXMgaXNuJ3QgYSB2aWV3IHRyYW5zaXRpb24gb3IgaXQncyBub3QgYXZhaWxhYmxlIGluIHRoaXMgYnJvd3NlcixcbiAgICAgIC8vIGp1c3QgdXBkYXRlIGFuZCBiZSBkb25lIHdpdGggaXRcbiAgICAgIGlmICghdmlld1RyYW5zaXRpb25PcHRzIHx8IGlzVmlld1RyYW5zaXRpb25VbmF2YWlsYWJsZSkge1xuICAgICAgICBpZiAoZmx1c2hTeW5jKSB7XG4gICAgICAgICAgZmx1c2hTeW5jU2FmZSgoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRJblN0YXJ0VHJhbnNpdGlvbigoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGZsdXNoU3luYyArIHN0YXJ0Vmlld1RyYW5zaXRpb25cbiAgICAgIGlmIChmbHVzaFN5bmMpIHtcbiAgICAgICAgLy8gRmx1c2ggdGhyb3VnaCB0aGUgY29udGV4dCB0byBtYXJrIERPTSBlbGVtZW50cyBhcyB0cmFuc2l0aW9uPWluZ1xuICAgICAgICBmbHVzaFN5bmNTYWZlKCgpID0+IHtcbiAgICAgICAgICAvLyBDYW5jZWwgYW55IHBlbmRpbmcgdHJhbnNpdGlvbnNcbiAgICAgICAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgICAgICAgcmVuZGVyRGZkICYmIHJlbmRlckRmZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICB0cmFuc2l0aW9uLnNraXBUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldFZ0Q29udGV4dCh7XG4gICAgICAgICAgICBpc1RyYW5zaXRpb25pbmc6IHRydWUsXG4gICAgICAgICAgICBmbHVzaFN5bmM6IHRydWUsXG4gICAgICAgICAgICBjdXJyZW50TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5jdXJyZW50TG9jYXRpb24sXG4gICAgICAgICAgICBuZXh0TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5uZXh0TG9jYXRpb24sXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgRE9NXG4gICAgICAgIGxldCB0ID0gcm91dGVyLndpbmRvdyEuZG9jdW1lbnQuc3RhcnRWaWV3VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgICAgZmx1c2hTeW5jU2FmZSgoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ2xlYW4gdXAgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBjb21wbGV0ZXNcbiAgICAgICAgdC5maW5pc2hlZC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICBmbHVzaFN5bmNTYWZlKCgpID0+IHtcbiAgICAgICAgICAgIHNldFJlbmRlckRmZCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgc2V0VHJhbnNpdGlvbih1bmRlZmluZWQpO1xuICAgICAgICAgICAgc2V0UGVuZGluZ1N0YXRlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBzZXRWdENvbnRleHQoeyBpc1RyYW5zaXRpb25pbmc6IGZhbHNlIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBmbHVzaFN5bmNTYWZlKCgpID0+IHNldFRyYW5zaXRpb24odCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHN0YXJ0VHJhbnNpdGlvbiArIHN0YXJ0Vmlld1RyYW5zaXRpb25cbiAgICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICAgIC8vIEludGVycnVwdGluZyBhbiBpbi1wcm9ncmVzcyB0cmFuc2l0aW9uLCBjYW5jZWwgYW5kIGxldCBldmVyeXRoaW5nIGZsdXNoXG4gICAgICAgIC8vIG91dCwgYW5kIHRoZW4ga2ljayBvZmYgYSBuZXcgdHJhbnNpdGlvbiBmcm9tIHRoZSBpbnRlcnJ1cHRpb24gc3RhdGVcbiAgICAgICAgcmVuZGVyRGZkICYmIHJlbmRlckRmZC5yZXNvbHZlKCk7XG4gICAgICAgIHRyYW5zaXRpb24uc2tpcFRyYW5zaXRpb24oKTtcbiAgICAgICAgc2V0SW50ZXJydXB0aW9uKHtcbiAgICAgICAgICBzdGF0ZTogbmV3U3RhdGUsXG4gICAgICAgICAgY3VycmVudExvY2F0aW9uOiB2aWV3VHJhbnNpdGlvbk9wdHMuY3VycmVudExvY2F0aW9uLFxuICAgICAgICAgIG5leHRMb2NhdGlvbjogdmlld1RyYW5zaXRpb25PcHRzLm5leHRMb2NhdGlvbixcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDb21wbGV0ZWQgbmF2aWdhdGlvbiB1cGRhdGUgd2l0aCBvcHRlZC1pbiB2aWV3IHRyYW5zaXRpb25zLCBsZXQgJ2VyIHJpcFxuICAgICAgICBzZXRQZW5kaW5nU3RhdGUobmV3U3RhdGUpO1xuICAgICAgICBzZXRWdENvbnRleHQoe1xuICAgICAgICAgIGlzVHJhbnNpdGlvbmluZzogdHJ1ZSxcbiAgICAgICAgICBmbHVzaFN5bmM6IGZhbHNlLFxuICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbjogdmlld1RyYW5zaXRpb25PcHRzLmN1cnJlbnRMb2NhdGlvbixcbiAgICAgICAgICBuZXh0TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5uZXh0TG9jYXRpb24sXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgW3JvdXRlci53aW5kb3csIHRyYW5zaXRpb24sIHJlbmRlckRmZCwgZmV0Y2hlckRhdGEsIG9wdEluU3RhcnRUcmFuc2l0aW9uXVxuICApO1xuXG4gIC8vIE5lZWQgdG8gdXNlIGEgbGF5b3V0IGVmZmVjdCBoZXJlIHNvIHdlIGFyZSBzdWJzY3JpYmVkIGVhcmx5IGVub3VnaCB0b1xuICAvLyBwaWNrIHVwIG9uIGFueSByZW5kZXItZHJpdmVuIHJlZGlyZWN0cy9uYXZpZ2F0aW9ucyAodXNlRWZmZWN0LzxOYXZpZ2F0ZT4pXG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiByb3V0ZXIuc3Vic2NyaWJlKHNldFN0YXRlKSwgW3JvdXRlciwgc2V0U3RhdGVdKTtcblxuICAvLyBXaGVuIHdlIHN0YXJ0IGEgdmlldyB0cmFuc2l0aW9uLCBjcmVhdGUgYSBEZWZlcnJlZCB3ZSBjYW4gdXNlIGZvciB0aGVcbiAgLy8gZXZlbnR1YWwgXCJjb21wbGV0ZWRcIiByZW5kZXJcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodnRDb250ZXh0LmlzVHJhbnNpdGlvbmluZyAmJiAhdnRDb250ZXh0LmZsdXNoU3luYykge1xuICAgICAgc2V0UmVuZGVyRGZkKG5ldyBEZWZlcnJlZDx2b2lkPigpKTtcbiAgICB9XG4gIH0sIFt2dENvbnRleHRdKTtcblxuICAvLyBPbmNlIHRoZSBkZWZlcnJlZCBpcyBjcmVhdGVkLCBraWNrIG9mZiBzdGFydFZpZXdUcmFuc2l0aW9uKCkgdG8gdXBkYXRlIHRoZVxuICAvLyBET00gYW5kIHRoZW4gd2FpdCBvbiB0aGUgRGVmZXJyZWQgdG8gcmVzb2x2ZSAoaW5kaWNhdGluZyB0aGUgRE9NIHVwZGF0ZSBoYXNcbiAgLy8gaGFwcGVuZWQpXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHJlbmRlckRmZCAmJiBwZW5kaW5nU3RhdGUgJiYgcm91dGVyLndpbmRvdykge1xuICAgICAgbGV0IG5ld1N0YXRlID0gcGVuZGluZ1N0YXRlO1xuICAgICAgbGV0IHJlbmRlclByb21pc2UgPSByZW5kZXJEZmQucHJvbWlzZTtcbiAgICAgIGxldCB0cmFuc2l0aW9uID0gcm91dGVyLndpbmRvdy5kb2N1bWVudC5zdGFydFZpZXdUcmFuc2l0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgICAgb3B0SW5TdGFydFRyYW5zaXRpb24oKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSk7XG4gICAgICAgIGF3YWl0IHJlbmRlclByb21pc2U7XG4gICAgICB9KTtcbiAgICAgIHRyYW5zaXRpb24uZmluaXNoZWQuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIHNldFJlbmRlckRmZCh1bmRlZmluZWQpO1xuICAgICAgICBzZXRUcmFuc2l0aW9uKHVuZGVmaW5lZCk7XG4gICAgICAgIHNldFBlbmRpbmdTdGF0ZSh1bmRlZmluZWQpO1xuICAgICAgICBzZXRWdENvbnRleHQoeyBpc1RyYW5zaXRpb25pbmc6IGZhbHNlIH0pO1xuICAgICAgfSk7XG4gICAgICBzZXRUcmFuc2l0aW9uKHRyYW5zaXRpb24pO1xuICAgIH1cbiAgfSwgW29wdEluU3RhcnRUcmFuc2l0aW9uLCBwZW5kaW5nU3RhdGUsIHJlbmRlckRmZCwgcm91dGVyLndpbmRvd10pO1xuXG4gIC8vIFdoZW4gdGhlIG5ldyBsb2NhdGlvbiBmaW5hbGx5IHJlbmRlcnMgYW5kIGlzIGNvbW1pdHRlZCB0byB0aGUgRE9NLCB0aGlzXG4gIC8vIGVmZmVjdCB3aWxsIHJ1biB0byByZXNvbHZlIHRoZSB0cmFuc2l0aW9uXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKFxuICAgICAgcmVuZGVyRGZkICYmXG4gICAgICBwZW5kaW5nU3RhdGUgJiZcbiAgICAgIHN0YXRlLmxvY2F0aW9uLmtleSA9PT0gcGVuZGluZ1N0YXRlLmxvY2F0aW9uLmtleVxuICAgICkge1xuICAgICAgcmVuZGVyRGZkLnJlc29sdmUoKTtcbiAgICB9XG4gIH0sIFtyZW5kZXJEZmQsIHRyYW5zaXRpb24sIHN0YXRlLmxvY2F0aW9uLCBwZW5kaW5nU3RhdGVdKTtcblxuICAvLyBJZiB3ZSBnZXQgaW50ZXJydXB0ZWQgd2l0aCBhIG5ldyBuYXZpZ2F0aW9uIGR1cmluZyBhIHRyYW5zaXRpb24sIHdlIHNraXBcbiAgLy8gdGhlIGFjdGl2ZSB0cmFuc2l0aW9uLCBsZXQgaXQgY2xlYW51cCwgdGhlbiBraWNrIGl0IG9mZiBhZ2FpbiBoZXJlXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCF2dENvbnRleHQuaXNUcmFuc2l0aW9uaW5nICYmIGludGVycnVwdGlvbikge1xuICAgICAgc2V0UGVuZGluZ1N0YXRlKGludGVycnVwdGlvbi5zdGF0ZSk7XG4gICAgICBzZXRWdENvbnRleHQoe1xuICAgICAgICBpc1RyYW5zaXRpb25pbmc6IHRydWUsXG4gICAgICAgIGZsdXNoU3luYzogZmFsc2UsXG4gICAgICAgIGN1cnJlbnRMb2NhdGlvbjogaW50ZXJydXB0aW9uLmN1cnJlbnRMb2NhdGlvbixcbiAgICAgICAgbmV4dExvY2F0aW9uOiBpbnRlcnJ1cHRpb24ubmV4dExvY2F0aW9uLFxuICAgICAgfSk7XG4gICAgICBzZXRJbnRlcnJ1cHRpb24odW5kZWZpbmVkKTtcbiAgICB9XG4gIH0sIFt2dENvbnRleHQuaXNUcmFuc2l0aW9uaW5nLCBpbnRlcnJ1cHRpb25dKTtcblxuICBsZXQgbmF2aWdhdG9yID0gUmVhY3QudXNlTWVtbygoKTogTmF2aWdhdG9yID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY3JlYXRlSHJlZjogcm91dGVyLmNyZWF0ZUhyZWYsXG4gICAgICBlbmNvZGVMb2NhdGlvbjogcm91dGVyLmVuY29kZUxvY2F0aW9uLFxuICAgICAgZ286IChuKSA9PiByb3V0ZXIubmF2aWdhdGUobiksXG4gICAgICBwdXNoOiAodG8sIHN0YXRlLCBvcHRzKSA9PlxuICAgICAgICByb3V0ZXIubmF2aWdhdGUodG8sIHtcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IG9wdHM/LnByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgICAgfSksXG4gICAgICByZXBsYWNlOiAodG8sIHN0YXRlLCBvcHRzKSA9PlxuICAgICAgICByb3V0ZXIubmF2aWdhdGUodG8sIHtcbiAgICAgICAgICByZXBsYWNlOiB0cnVlLFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogb3B0cz8ucHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICB9KSxcbiAgICB9O1xuICB9LCBbcm91dGVyXSk7XG5cbiAgbGV0IGJhc2VuYW1lID0gcm91dGVyLmJhc2VuYW1lIHx8IFwiL1wiO1xuXG4gIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IFJlYWN0LnVzZU1lbW8oXG4gICAgKCkgPT4gKHtcbiAgICAgIHJvdXRlcixcbiAgICAgIG5hdmlnYXRvcixcbiAgICAgIHN0YXRpYzogZmFsc2UsXG4gICAgICBiYXNlbmFtZSxcbiAgICB9KSxcbiAgICBbcm91dGVyLCBuYXZpZ2F0b3IsIGJhc2VuYW1lXVxuICApO1xuXG4gIC8vIFRoZSBmcmFnbWVudCBhbmQge251bGx9IGhlcmUgYXJlIGltcG9ydGFudCEgIFdlIG5lZWQgdGhlbSB0byBrZWVwIFJlYWN0IDE4J3NcbiAgLy8gdXNlSWQgaGFwcHkgd2hlbiB3ZSBhcmUgc2VydmVyLXJlbmRlcmluZyBzaW5jZSB3ZSBtYXkgaGF2ZSBhIDxzY3JpcHQ+IGhlcmVcbiAgLy8gY29udGFpbmluZyB0aGUgaHlkcmF0ZWQgc2VydmVyLXNpZGUgc3RhdGljQ29udGV4dCAoZnJvbSBTdGF0aWNSb3V0ZXJQcm92aWRlcikuXG4gIC8vIHVzZUlkIHJlbGllcyBvbiB0aGUgY29tcG9uZW50IHRyZWUgc3RydWN0dXJlIHRvIGdlbmVyYXRlIGRldGVybWluaXN0aWMgaWQnc1xuICAvLyBzbyB3ZSBuZWVkIHRvIGVuc3VyZSBpdCByZW1haW5zIHRoZSBzYW1lIG9uIHRoZSBjbGllbnQgZXZlbiB0aG91Z2hcbiAgLy8gd2UgZG9uJ3QgbmVlZCB0aGUgPHNjcmlwdD4gdGFnXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxEYXRhUm91dGVyQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17ZGF0YVJvdXRlckNvbnRleHR9PlxuICAgICAgICA8RGF0YVJvdXRlclN0YXRlQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17c3RhdGV9PlxuICAgICAgICAgIDxGZXRjaGVyc0NvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2ZldGNoZXJEYXRhLmN1cnJlbnR9PlxuICAgICAgICAgICAgPFZpZXdUcmFuc2l0aW9uQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dnRDb250ZXh0fT5cbiAgICAgICAgICAgICAgPFJvdXRlclxuICAgICAgICAgICAgICAgIGJhc2VuYW1lPXtiYXNlbmFtZX1cbiAgICAgICAgICAgICAgICBsb2NhdGlvbj17c3RhdGUubG9jYXRpb259XG4gICAgICAgICAgICAgICAgbmF2aWdhdGlvblR5cGU9e3N0YXRlLmhpc3RvcnlBY3Rpb259XG4gICAgICAgICAgICAgICAgbmF2aWdhdG9yPXtuYXZpZ2F0b3J9XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7c3RhdGUuaW5pdGlhbGl6ZWQgPyAoXG4gICAgICAgICAgICAgICAgICA8RGF0YVJvdXRlcyByb3V0ZXM9e3JvdXRlci5yb3V0ZXN9IHN0YXRlPXtzdGF0ZX0gLz5cbiAgICAgICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICAgICAgZmFsbGJhY2tFbGVtZW50XG4gICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgPC9Sb3V0ZXI+XG4gICAgICAgICAgICA8L1ZpZXdUcmFuc2l0aW9uQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgICA8L0ZldGNoZXJzQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgPC9EYXRhUm91dGVyU3RhdGVDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgPC9EYXRhUm91dGVyQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgIHtudWxsfVxuICAgIDwvPlxuICApO1xufVxuXG5mdW5jdGlvbiBEYXRhUm91dGVzKHtcbiAgcm91dGVzLFxuICBzdGF0ZSxcbn06IHtcbiAgcm91dGVzOiBEYXRhUm91dGVPYmplY3RbXTtcbiAgc3RhdGU6IFJvdXRlclN0YXRlO1xufSk6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICByZXR1cm4gdXNlUm91dGVzSW1wbChyb3V0ZXMsIHVuZGVmaW5lZCwgc3RhdGUpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJyb3dzZXJSb3V0ZXJQcm9wcyB7XG4gIGJhc2VuYW1lPzogc3RyaW5nO1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgZnV0dXJlPzogUGFydGlhbDxGdXR1cmVDb25maWc+O1xuICB3aW5kb3c/OiBXaW5kb3c7XG59XG5cbi8qKlxuICogQSBgPFJvdXRlcj5gIGZvciB1c2UgaW4gd2ViIGJyb3dzZXJzLiBQcm92aWRlcyB0aGUgY2xlYW5lc3QgVVJMcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEJyb3dzZXJSb3V0ZXIoe1xuICBiYXNlbmFtZSxcbiAgY2hpbGRyZW4sXG4gIGZ1dHVyZSxcbiAgd2luZG93LFxufTogQnJvd3NlclJvdXRlclByb3BzKSB7XG4gIGxldCBoaXN0b3J5UmVmID0gUmVhY3QudXNlUmVmPEJyb3dzZXJIaXN0b3J5PigpO1xuICBpZiAoaGlzdG9yeVJlZi5jdXJyZW50ID09IG51bGwpIHtcbiAgICBoaXN0b3J5UmVmLmN1cnJlbnQgPSBjcmVhdGVCcm93c2VySGlzdG9yeSh7IHdpbmRvdywgdjVDb21wYXQ6IHRydWUgfSk7XG4gIH1cblxuICBsZXQgaGlzdG9yeSA9IGhpc3RvcnlSZWYuY3VycmVudDtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVJbXBsXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uLFxuICB9KTtcbiAgbGV0IHsgdjdfc3RhcnRUcmFuc2l0aW9uIH0gPSBmdXR1cmUgfHwge307XG4gIGxldCBzZXRTdGF0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgIChuZXdTdGF0ZTogeyBhY3Rpb246IE5hdmlnYXRpb25UeXBlOyBsb2NhdGlvbjogTG9jYXRpb24gfSkgPT4ge1xuICAgICAgdjdfc3RhcnRUcmFuc2l0aW9uICYmIHN0YXJ0VHJhbnNpdGlvbkltcGxcbiAgICAgICAgPyBzdGFydFRyYW5zaXRpb25JbXBsKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpXG4gICAgICAgIDogc2V0U3RhdGVJbXBsKG5ld1N0YXRlKTtcbiAgICB9LFxuICAgIFtzZXRTdGF0ZUltcGwsIHY3X3N0YXJ0VHJhbnNpdGlvbl1cbiAgKTtcblxuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeSwgc2V0U3RhdGVdKTtcblxuICByZXR1cm4gKFxuICAgIDxSb3V0ZXJcbiAgICAgIGJhc2VuYW1lPXtiYXNlbmFtZX1cbiAgICAgIGNoaWxkcmVuPXtjaGlsZHJlbn1cbiAgICAgIGxvY2F0aW9uPXtzdGF0ZS5sb2NhdGlvbn1cbiAgICAgIG5hdmlnYXRpb25UeXBlPXtzdGF0ZS5hY3Rpb259XG4gICAgICBuYXZpZ2F0b3I9e2hpc3Rvcnl9XG4gICAgLz5cbiAgKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIYXNoUm91dGVyUHJvcHMge1xuICBiYXNlbmFtZT86IHN0cmluZztcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIGZ1dHVyZT86IFBhcnRpYWw8RnV0dXJlQ29uZmlnPjtcbiAgd2luZG93PzogV2luZG93O1xufVxuXG4vKipcbiAqIEEgYDxSb3V0ZXI+YCBmb3IgdXNlIGluIHdlYiBicm93c2Vycy4gU3RvcmVzIHRoZSBsb2NhdGlvbiBpbiB0aGUgaGFzaFxuICogcG9ydGlvbiBvZiB0aGUgVVJMIHNvIGl0IGlzIG5vdCBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBIYXNoUm91dGVyKHtcbiAgYmFzZW5hbWUsXG4gIGNoaWxkcmVuLFxuICBmdXR1cmUsXG4gIHdpbmRvdyxcbn06IEhhc2hSb3V0ZXJQcm9wcykge1xuICBsZXQgaGlzdG9yeVJlZiA9IFJlYWN0LnVzZVJlZjxIYXNoSGlzdG9yeT4oKTtcbiAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgaGlzdG9yeVJlZi5jdXJyZW50ID0gY3JlYXRlSGFzaEhpc3RvcnkoeyB3aW5kb3csIHY1Q29tcGF0OiB0cnVlIH0pO1xuICB9XG5cbiAgbGV0IGhpc3RvcnkgPSBoaXN0b3J5UmVmLmN1cnJlbnQ7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlSW1wbF0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvbixcbiAgfSk7XG4gIGxldCB7IHY3X3N0YXJ0VHJhbnNpdGlvbiB9ID0gZnV0dXJlIHx8IHt9O1xuICBsZXQgc2V0U3RhdGUgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAobmV3U3RhdGU6IHsgYWN0aW9uOiBOYXZpZ2F0aW9uVHlwZTsgbG9jYXRpb246IExvY2F0aW9uIH0pID0+IHtcbiAgICAgIHY3X3N0YXJ0VHJhbnNpdGlvbiAmJiBzdGFydFRyYW5zaXRpb25JbXBsXG4gICAgICAgID8gc3RhcnRUcmFuc2l0aW9uSW1wbCgoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKVxuICAgICAgICA6IHNldFN0YXRlSW1wbChuZXdTdGF0ZSk7XG4gICAgfSxcbiAgICBbc2V0U3RhdGVJbXBsLCB2N19zdGFydFRyYW5zaXRpb25dXG4gICk7XG5cbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnksIHNldFN0YXRlXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8Um91dGVyXG4gICAgICBiYXNlbmFtZT17YmFzZW5hbWV9XG4gICAgICBjaGlsZHJlbj17Y2hpbGRyZW59XG4gICAgICBsb2NhdGlvbj17c3RhdGUubG9jYXRpb259XG4gICAgICBuYXZpZ2F0aW9uVHlwZT17c3RhdGUuYWN0aW9ufVxuICAgICAgbmF2aWdhdG9yPXtoaXN0b3J5fVxuICAgIC8+XG4gICk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGlzdG9yeVJvdXRlclByb3BzIHtcbiAgYmFzZW5hbWU/OiBzdHJpbmc7XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlO1xuICBmdXR1cmU/OiBGdXR1cmVDb25maWc7XG4gIGhpc3Rvcnk6IEhpc3Rvcnk7XG59XG5cbi8qKlxuICogQSBgPFJvdXRlcj5gIHRoYXQgYWNjZXB0cyBhIHByZS1pbnN0YW50aWF0ZWQgaGlzdG9yeSBvYmplY3QuIEl0J3MgaW1wb3J0YW50XG4gKiB0byBub3RlIHRoYXQgdXNpbmcgeW91ciBvd24gaGlzdG9yeSBvYmplY3QgaXMgaGlnaGx5IGRpc2NvdXJhZ2VkIGFuZCBtYXkgYWRkXG4gKiB0d28gdmVyc2lvbnMgb2YgdGhlIGhpc3RvcnkgbGlicmFyeSB0byB5b3VyIGJ1bmRsZXMgdW5sZXNzIHlvdSB1c2UgdGhlIHNhbWVcbiAqIHZlcnNpb24gb2YgdGhlIGhpc3RvcnkgbGlicmFyeSB0aGF0IFJlYWN0IFJvdXRlciB1c2VzIGludGVybmFsbHkuXG4gKi9cbmZ1bmN0aW9uIEhpc3RvcnlSb3V0ZXIoe1xuICBiYXNlbmFtZSxcbiAgY2hpbGRyZW4sXG4gIGZ1dHVyZSxcbiAgaGlzdG9yeSxcbn06IEhpc3RvcnlSb3V0ZXJQcm9wcykge1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZUltcGxdID0gUmVhY3QudXNlU3RhdGUoe1xuICAgIGFjdGlvbjogaGlzdG9yeS5hY3Rpb24sXG4gICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb24sXG4gIH0pO1xuICBsZXQgeyB2N19zdGFydFRyYW5zaXRpb24gfSA9IGZ1dHVyZSB8fCB7fTtcbiAgbGV0IHNldFN0YXRlID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKG5ld1N0YXRlOiB7IGFjdGlvbjogTmF2aWdhdGlvblR5cGU7IGxvY2F0aW9uOiBMb2NhdGlvbiB9KSA9PiB7XG4gICAgICB2N19zdGFydFRyYW5zaXRpb24gJiYgc3RhcnRUcmFuc2l0aW9uSW1wbFxuICAgICAgICA/IHN0YXJ0VHJhbnNpdGlvbkltcGwoKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSlcbiAgICAgICAgOiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpO1xuICAgIH0sXG4gICAgW3NldFN0YXRlSW1wbCwgdjdfc3RhcnRUcmFuc2l0aW9uXVxuICApO1xuXG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5LCBzZXRTdGF0ZV0pO1xuXG4gIHJldHVybiAoXG4gICAgPFJvdXRlclxuICAgICAgYmFzZW5hbWU9e2Jhc2VuYW1lfVxuICAgICAgY2hpbGRyZW49e2NoaWxkcmVufVxuICAgICAgbG9jYXRpb249e3N0YXRlLmxvY2F0aW9ufVxuICAgICAgbmF2aWdhdGlvblR5cGU9e3N0YXRlLmFjdGlvbn1cbiAgICAgIG5hdmlnYXRvcj17aGlzdG9yeX1cbiAgICAvPlxuICApO1xufVxuXG5pZiAoX19ERVZfXykge1xuICBIaXN0b3J5Um91dGVyLmRpc3BsYXlOYW1lID0gXCJ1bnN0YWJsZV9IaXN0b3J5Um91dGVyXCI7XG59XG5cbmV4cG9ydCB7IEhpc3RvcnlSb3V0ZXIgYXMgdW5zdGFibGVfSGlzdG9yeVJvdXRlciB9O1xuXG5leHBvcnQgaW50ZXJmYWNlIExpbmtQcm9wc1xuICBleHRlbmRzIE9taXQ8UmVhY3QuQW5jaG9ySFRNTEF0dHJpYnV0ZXM8SFRNTEFuY2hvckVsZW1lbnQ+LCBcImhyZWZcIj4ge1xuICByZWxvYWREb2N1bWVudD86IGJvb2xlYW47XG4gIHJlcGxhY2U/OiBib29sZWFuO1xuICBzdGF0ZT86IGFueTtcbiAgcHJldmVudFNjcm9sbFJlc2V0PzogYm9vbGVhbjtcbiAgcmVsYXRpdmU/OiBSZWxhdGl2ZVJvdXRpbmdUeXBlO1xuICB0bzogVG87XG4gIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uPzogYm9vbGVhbjtcbn1cblxuY29uc3QgaXNCcm93c2VyID1cbiAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIjtcblxuY29uc3QgQUJTT0xVVEVfVVJMX1JFR0VYID0gL14oPzpbYS16XVthLXowLTkrLi1dKjp8XFwvXFwvKS9pO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciByZW5kZXJpbmcgYSBoaXN0b3J5LWF3YXJlIGA8YT5gLlxuICovXG5leHBvcnQgY29uc3QgTGluayA9IFJlYWN0LmZvcndhcmRSZWY8SFRNTEFuY2hvckVsZW1lbnQsIExpbmtQcm9wcz4oXG4gIGZ1bmN0aW9uIExpbmtXaXRoUmVmKFxuICAgIHtcbiAgICAgIG9uQ2xpY2ssXG4gICAgICByZWxhdGl2ZSxcbiAgICAgIHJlbG9hZERvY3VtZW50LFxuICAgICAgcmVwbGFjZSxcbiAgICAgIHN0YXRlLFxuICAgICAgdGFyZ2V0LFxuICAgICAgdG8sXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbixcbiAgICAgIC4uLnJlc3RcbiAgICB9LFxuICAgIHJlZlxuICApIHtcbiAgICBsZXQgeyBiYXNlbmFtZSB9ID0gUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG5cbiAgICAvLyBSZW5kZXJlZCBpbnRvIDxhIGhyZWY+IGZvciBhYnNvbHV0ZSBVUkxzXG4gICAgbGV0IGFic29sdXRlSHJlZjtcbiAgICBsZXQgaXNFeHRlcm5hbCA9IGZhbHNlO1xuXG4gICAgaWYgKHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiAmJiBBQlNPTFVURV9VUkxfUkVHRVgudGVzdCh0bykpIHtcbiAgICAgIC8vIFJlbmRlciB0aGUgYWJzb2x1dGUgaHJlZiBzZXJ2ZXItIGFuZCBjbGllbnQtc2lkZVxuICAgICAgYWJzb2x1dGVIcmVmID0gdG87XG5cbiAgICAgIC8vIE9ubHkgY2hlY2sgZm9yIGV4dGVybmFsIG9yaWdpbnMgY2xpZW50LXNpZGVcbiAgICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgY3VycmVudFVybCA9IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgIGxldCB0YXJnZXRVcmwgPSB0by5zdGFydHNXaXRoKFwiLy9cIilcbiAgICAgICAgICAgID8gbmV3IFVSTChjdXJyZW50VXJsLnByb3RvY29sICsgdG8pXG4gICAgICAgICAgICA6IG5ldyBVUkwodG8pO1xuICAgICAgICAgIGxldCBwYXRoID0gc3RyaXBCYXNlbmFtZSh0YXJnZXRVcmwucGF0aG5hbWUsIGJhc2VuYW1lKTtcblxuICAgICAgICAgIGlmICh0YXJnZXRVcmwub3JpZ2luID09PSBjdXJyZW50VXJsLm9yaWdpbiAmJiBwYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFN0cmlwIHRoZSBwcm90b2NvbC9vcmlnaW4vYmFzZW5hbWUgZm9yIHNhbWUtb3JpZ2luIGFic29sdXRlIFVSTHNcbiAgICAgICAgICAgIHRvID0gcGF0aCArIHRhcmdldFVybC5zZWFyY2ggKyB0YXJnZXRVcmwuaGFzaDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXNFeHRlcm5hbCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gV2UgY2FuJ3QgZG8gZXh0ZXJuYWwgVVJMIGRldGVjdGlvbiB3aXRob3V0IGEgdmFsaWQgVVJMXG4gICAgICAgICAgd2FybmluZyhcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgYDxMaW5rIHRvPVwiJHt0b31cIj4gY29udGFpbnMgYW4gaW52YWxpZCBVUkwgd2hpY2ggd2lsbCBwcm9iYWJseSBicmVhayBgICtcbiAgICAgICAgICAgICAgYHdoZW4gY2xpY2tlZCAtIHBsZWFzZSB1cGRhdGUgdG8gYSB2YWxpZCBVUkwgcGF0aC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbmRlcmVkIGludG8gPGEgaHJlZj4gZm9yIHJlbGF0aXZlIFVSTHNcbiAgICBsZXQgaHJlZiA9IHVzZUhyZWYodG8sIHsgcmVsYXRpdmUgfSk7XG5cbiAgICBsZXQgaW50ZXJuYWxPbkNsaWNrID0gdXNlTGlua0NsaWNrSGFuZGxlcih0bywge1xuICAgICAgcmVwbGFjZSxcbiAgICAgIHN0YXRlLFxuICAgICAgdGFyZ2V0LFxuICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgcmVsYXRpdmUsXG4gICAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbixcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBoYW5kbGVDbGljayhcbiAgICAgIGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50PEhUTUxBbmNob3JFbGVtZW50LCBNb3VzZUV2ZW50PlxuICAgICkge1xuICAgICAgaWYgKG9uQ2xpY2spIG9uQ2xpY2soZXZlbnQpO1xuICAgICAgaWYgKCFldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIGludGVybmFsT25DbGljayhldmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc3gtYTExeS9hbmNob3ItaGFzLWNvbnRlbnRcbiAgICAgIDxhXG4gICAgICAgIHsuLi5yZXN0fVxuICAgICAgICBocmVmPXthYnNvbHV0ZUhyZWYgfHwgaHJlZn1cbiAgICAgICAgb25DbGljaz17aXNFeHRlcm5hbCB8fCByZWxvYWREb2N1bWVudCA/IG9uQ2xpY2sgOiBoYW5kbGVDbGlja31cbiAgICAgICAgcmVmPXtyZWZ9XG4gICAgICAgIHRhcmdldD17dGFyZ2V0fVxuICAgICAgLz5cbiAgICApO1xuICB9XG4pO1xuXG5pZiAoX19ERVZfXykge1xuICBMaW5rLmRpc3BsYXlOYW1lID0gXCJMaW5rXCI7XG59XG5cbnR5cGUgTmF2TGlua1JlbmRlclByb3BzID0ge1xuICBpc0FjdGl2ZTogYm9vbGVhbjtcbiAgaXNQZW5kaW5nOiBib29sZWFuO1xuICBpc1RyYW5zaXRpb25pbmc6IGJvb2xlYW47XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIE5hdkxpbmtQcm9wc1xuICBleHRlbmRzIE9taXQ8TGlua1Byb3BzLCBcImNsYXNzTmFtZVwiIHwgXCJzdHlsZVwiIHwgXCJjaGlsZHJlblwiPiB7XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlIHwgKChwcm9wczogTmF2TGlua1JlbmRlclByb3BzKSA9PiBSZWFjdC5SZWFjdE5vZGUpO1xuICBjYXNlU2Vuc2l0aXZlPzogYm9vbGVhbjtcbiAgY2xhc3NOYW1lPzogc3RyaW5nIHwgKChwcm9wczogTmF2TGlua1JlbmRlclByb3BzKSA9PiBzdHJpbmcgfCB1bmRlZmluZWQpO1xuICBlbmQ/OiBib29sZWFuO1xuICBzdHlsZT86XG4gICAgfCBSZWFjdC5DU1NQcm9wZXJ0aWVzXG4gICAgfCAoKHByb3BzOiBOYXZMaW5rUmVuZGVyUHJvcHMpID0+IFJlYWN0LkNTU1Byb3BlcnRpZXMgfCB1bmRlZmluZWQpO1xufVxuXG4vKipcbiAqIEEgYDxMaW5rPmAgd3JhcHBlciB0aGF0IGtub3dzIGlmIGl0J3MgXCJhY3RpdmVcIiBvciBub3QuXG4gKi9cbmV4cG9ydCBjb25zdCBOYXZMaW5rID0gUmVhY3QuZm9yd2FyZFJlZjxIVE1MQW5jaG9yRWxlbWVudCwgTmF2TGlua1Byb3BzPihcbiAgZnVuY3Rpb24gTmF2TGlua1dpdGhSZWYoXG4gICAge1xuICAgICAgXCJhcmlhLWN1cnJlbnRcIjogYXJpYUN1cnJlbnRQcm9wID0gXCJwYWdlXCIsXG4gICAgICBjYXNlU2Vuc2l0aXZlID0gZmFsc2UsXG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVByb3AgPSBcIlwiLFxuICAgICAgZW5kID0gZmFsc2UsXG4gICAgICBzdHlsZTogc3R5bGVQcm9wLFxuICAgICAgdG8sXG4gICAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbixcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgLi4ucmVzdFxuICAgIH0sXG4gICAgcmVmXG4gICkge1xuICAgIGxldCBwYXRoID0gdXNlUmVzb2x2ZWRQYXRoKHRvLCB7IHJlbGF0aXZlOiByZXN0LnJlbGF0aXZlIH0pO1xuICAgIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gICAgbGV0IHJvdXRlclN0YXRlID0gUmVhY3QudXNlQ29udGV4dChEYXRhUm91dGVyU3RhdGVDb250ZXh0KTtcbiAgICBsZXQgeyBuYXZpZ2F0b3IgfSA9IFJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICAgIGxldCBpc1RyYW5zaXRpb25pbmcgPVxuICAgICAgcm91dGVyU3RhdGUgIT0gbnVsbCAmJlxuICAgICAgLy8gQ29uZGl0aW9uYWwgdXNhZ2UgaXMgT0sgaGVyZSBiZWNhdXNlIHRoZSB1c2FnZSBvZiBhIGRhdGEgcm91dGVyIGlzIHN0YXRpY1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgICB1c2VWaWV3VHJhbnNpdGlvblN0YXRlKHBhdGgpICYmXG4gICAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbiA9PT0gdHJ1ZTtcblxuICAgIGxldCB0b1BhdGhuYW1lID0gbmF2aWdhdG9yLmVuY29kZUxvY2F0aW9uXG4gICAgICA/IG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbihwYXRoKS5wYXRobmFtZVxuICAgICAgOiBwYXRoLnBhdGhuYW1lO1xuICAgIGxldCBsb2NhdGlvblBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWU7XG4gICAgbGV0IG5leHRMb2NhdGlvblBhdGhuYW1lID1cbiAgICAgIHJvdXRlclN0YXRlICYmIHJvdXRlclN0YXRlLm5hdmlnYXRpb24gJiYgcm91dGVyU3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvblxuICAgICAgICA/IHJvdXRlclN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24ucGF0aG5hbWVcbiAgICAgICAgOiBudWxsO1xuXG4gICAgaWYgKCFjYXNlU2Vuc2l0aXZlKSB7XG4gICAgICBsb2NhdGlvblBhdGhuYW1lID0gbG9jYXRpb25QYXRobmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgbmV4dExvY2F0aW9uUGF0aG5hbWUgPSBuZXh0TG9jYXRpb25QYXRobmFtZVxuICAgICAgICA/IG5leHRMb2NhdGlvblBhdGhuYW1lLnRvTG93ZXJDYXNlKClcbiAgICAgICAgOiBudWxsO1xuICAgICAgdG9QYXRobmFtZSA9IHRvUGF0aG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgYHRvYCBoYXMgYSB0cmFpbGluZyBzbGFzaCwgbG9vayBhdCB0aGF0IGV4YWN0IHNwb3QuICBPdGhlcndpc2UsXG4gICAgLy8gd2UncmUgbG9va2luZyBmb3IgYSBzbGFzaCBfYWZ0ZXJfIHdoYXQncyBpbiBgdG9gLiAgRm9yIGV4YW1wbGU6XG4gICAgLy9cbiAgICAvLyA8TmF2TGluayB0bz1cIi91c2Vyc1wiPiBhbmQgPE5hdkxpbmsgdG89XCIvdXNlcnMvXCI+XG4gICAgLy8gYm90aCB3YW50IHRvIGxvb2sgZm9yIGEgLyBhdCBpbmRleCA2IHRvIG1hdGNoIFVSTCBgL3VzZXJzL21hdHRgXG4gICAgY29uc3QgZW5kU2xhc2hQb3NpdGlvbiA9XG4gICAgICB0b1BhdGhuYW1lICE9PSBcIi9cIiAmJiB0b1BhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKVxuICAgICAgICA/IHRvUGF0aG5hbWUubGVuZ3RoIC0gMVxuICAgICAgICA6IHRvUGF0aG5hbWUubGVuZ3RoO1xuICAgIGxldCBpc0FjdGl2ZSA9XG4gICAgICBsb2NhdGlvblBhdGhuYW1lID09PSB0b1BhdGhuYW1lIHx8XG4gICAgICAoIWVuZCAmJlxuICAgICAgICBsb2NhdGlvblBhdGhuYW1lLnN0YXJ0c1dpdGgodG9QYXRobmFtZSkgJiZcbiAgICAgICAgbG9jYXRpb25QYXRobmFtZS5jaGFyQXQoZW5kU2xhc2hQb3NpdGlvbikgPT09IFwiL1wiKTtcblxuICAgIGxldCBpc1BlbmRpbmcgPVxuICAgICAgbmV4dExvY2F0aW9uUGF0aG5hbWUgIT0gbnVsbCAmJlxuICAgICAgKG5leHRMb2NhdGlvblBhdGhuYW1lID09PSB0b1BhdGhuYW1lIHx8XG4gICAgICAgICghZW5kICYmXG4gICAgICAgICAgbmV4dExvY2F0aW9uUGF0aG5hbWUuc3RhcnRzV2l0aCh0b1BhdGhuYW1lKSAmJlxuICAgICAgICAgIG5leHRMb2NhdGlvblBhdGhuYW1lLmNoYXJBdCh0b1BhdGhuYW1lLmxlbmd0aCkgPT09IFwiL1wiKSk7XG5cbiAgICBsZXQgcmVuZGVyUHJvcHMgPSB7XG4gICAgICBpc0FjdGl2ZSxcbiAgICAgIGlzUGVuZGluZyxcbiAgICAgIGlzVHJhbnNpdGlvbmluZyxcbiAgICB9O1xuXG4gICAgbGV0IGFyaWFDdXJyZW50ID0gaXNBY3RpdmUgPyBhcmlhQ3VycmVudFByb3AgOiB1bmRlZmluZWQ7XG5cbiAgICBsZXQgY2xhc3NOYW1lOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgaWYgKHR5cGVvZiBjbGFzc05hbWVQcm9wID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZVByb3AocmVuZGVyUHJvcHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGUgY2xhc3NOYW1lIHByb3AgaXMgbm90IGEgZnVuY3Rpb24sIHdlIHVzZSBhIGRlZmF1bHQgYGFjdGl2ZWBcbiAgICAgIC8vIGNsYXNzIGZvciA8TmF2TGluayAvPnMgdGhhdCBhcmUgYWN0aXZlLiBJbiB2NSBgYWN0aXZlYCB3YXMgdGhlIGRlZmF1bHRcbiAgICAgIC8vIHZhbHVlIGZvciBgYWN0aXZlQ2xhc3NOYW1lYCwgYnV0IHdlIGFyZSByZW1vdmluZyB0aGF0IEFQSSBhbmQgY2FuIHN0aWxsXG4gICAgICAvLyB1c2UgdGhlIG9sZCBkZWZhdWx0IGJlaGF2aW9yIGZvciBhIGNsZWFuZXIgdXBncmFkZSBwYXRoIGFuZCBrZWVwIHRoZVxuICAgICAgLy8gc2ltcGxlIHN0eWxpbmcgcnVsZXMgd29ya2luZyBhcyB0aGV5IGN1cnJlbnRseSBkby5cbiAgICAgIGNsYXNzTmFtZSA9IFtcbiAgICAgICAgY2xhc3NOYW1lUHJvcCxcbiAgICAgICAgaXNBY3RpdmUgPyBcImFjdGl2ZVwiIDogbnVsbCxcbiAgICAgICAgaXNQZW5kaW5nID8gXCJwZW5kaW5nXCIgOiBudWxsLFxuICAgICAgICBpc1RyYW5zaXRpb25pbmcgPyBcInRyYW5zaXRpb25pbmdcIiA6IG51bGwsXG4gICAgICBdXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgLmpvaW4oXCIgXCIpO1xuICAgIH1cblxuICAgIGxldCBzdHlsZSA9XG4gICAgICB0eXBlb2Ygc3R5bGVQcm9wID09PSBcImZ1bmN0aW9uXCIgPyBzdHlsZVByb3AocmVuZGVyUHJvcHMpIDogc3R5bGVQcm9wO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxMaW5rXG4gICAgICAgIHsuLi5yZXN0fVxuICAgICAgICBhcmlhLWN1cnJlbnQ9e2FyaWFDdXJyZW50fVxuICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZX1cbiAgICAgICAgcmVmPXtyZWZ9XG4gICAgICAgIHN0eWxlPXtzdHlsZX1cbiAgICAgICAgdG89e3RvfVxuICAgICAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbj17dW5zdGFibGVfdmlld1RyYW5zaXRpb259XG4gICAgICA+XG4gICAgICAgIHt0eXBlb2YgY2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIiA/IGNoaWxkcmVuKHJlbmRlclByb3BzKSA6IGNoaWxkcmVufVxuICAgICAgPC9MaW5rPlxuICAgICk7XG4gIH1cbik7XG5cbmlmIChfX0RFVl9fKSB7XG4gIE5hdkxpbmsuZGlzcGxheU5hbWUgPSBcIk5hdkxpbmtcIjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGZXRjaGVyRm9ybVByb3BzXG4gIGV4dGVuZHMgUmVhY3QuRm9ybUhUTUxBdHRyaWJ1dGVzPEhUTUxGb3JtRWxlbWVudD4ge1xuICAvKipcbiAgICogVGhlIEhUVFAgdmVyYiB0byB1c2Ugd2hlbiB0aGUgZm9ybSBpcyBzdWJtaXQuIFN1cHBvcnRzIFwiZ2V0XCIsIFwicG9zdFwiLFxuICAgKiBcInB1dFwiLCBcImRlbGV0ZVwiLCBcInBhdGNoXCIuXG4gICAqL1xuICBtZXRob2Q/OiBIVE1MRm9ybU1ldGhvZDtcblxuICAvKipcbiAgICogYDxmb3JtIGVuY1R5cGU+YCAtIGVuaGFuY2luZyBiZXlvbmQgdGhlIG5vcm1hbCBzdHJpbmcgdHlwZSBhbmQgbGltaXRpbmdcbiAgICogdG8gdGhlIGJ1aWx0LWluIGJyb3dzZXIgc3VwcG9ydGVkIHZhbHVlc1xuICAgKi9cbiAgZW5jVHlwZT86XG4gICAgfCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiXG4gICAgfCBcIm11bHRpcGFydC9mb3JtLWRhdGFcIlxuICAgIHwgXCJ0ZXh0L3BsYWluXCI7XG5cbiAgLyoqXG4gICAqIE5vcm1hbCBgPGZvcm0gYWN0aW9uPmAgYnV0IHN1cHBvcnRzIFJlYWN0IFJvdXRlcidzIHJlbGF0aXZlIHBhdGhzLlxuICAgKi9cbiAgYWN0aW9uPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGZvcm0gYWN0aW9uIGlzIHJlbGF0aXZlIHRvIHRoZSByb3V0ZSBoaWVyYXJjaHkgb3JcbiAgICogdGhlIHBhdGhuYW1lLiAgVXNlIHRoaXMgaWYgeW91IHdhbnQgdG8gb3B0IG91dCBvZiBuYXZpZ2F0aW5nIHRoZSByb3V0ZVxuICAgKiBoaWVyYXJjaHkgYW5kIHdhbnQgdG8gaW5zdGVhZCByb3V0ZSBiYXNlZCBvbiAvLWRlbGltaXRlZCBVUkwgc2VnbWVudHNcbiAgICovXG4gIHJlbGF0aXZlPzogUmVsYXRpdmVSb3V0aW5nVHlwZTtcblxuICAvKipcbiAgICogUHJldmVudCB0aGUgc2Nyb2xsIHBvc2l0aW9uIGZyb20gcmVzZXR0aW5nIHRvIHRoZSB0b3Agb2YgdGhlIHZpZXdwb3J0IG9uXG4gICAqIGNvbXBsZXRpb24gb2YgdGhlIG5hdmlnYXRpb24gd2hlbiB1c2luZyB0aGUgPFNjcm9sbFJlc3RvcmF0aW9uPiBjb21wb25lbnRcbiAgICovXG4gIHByZXZlbnRTY3JvbGxSZXNldD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEEgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBmb3JtIGlzIHN1Ym1pdHRlZC4gSWYgeW91IGNhbGxcbiAgICogYGV2ZW50LnByZXZlbnREZWZhdWx0KClgIHRoZW4gdGhpcyBmb3JtIHdpbGwgbm90IGRvIGFueXRoaW5nLlxuICAgKi9cbiAgb25TdWJtaXQ/OiBSZWFjdC5Gb3JtRXZlbnRIYW5kbGVyPEhUTUxGb3JtRWxlbWVudD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRm9ybVByb3BzIGV4dGVuZHMgRmV0Y2hlckZvcm1Qcm9wcyB7XG4gIC8qKlxuICAgKiBJbmRpY2F0ZSBhIHNwZWNpZmljIGZldGNoZXJLZXkgdG8gdXNlIHdoZW4gdXNpbmcgbmF2aWdhdGU9ZmFsc2VcbiAgICovXG4gIGZldGNoZXJLZXk/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIG5hdmlnYXRlPWZhbHNlIHdpbGwgdXNlIGEgZmV0Y2hlciBpbnN0ZWFkIG9mIGEgbmF2aWdhdGlvblxuICAgKi9cbiAgbmF2aWdhdGU/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBGb3JjZXMgYSBmdWxsIGRvY3VtZW50IG5hdmlnYXRpb24gaW5zdGVhZCBvZiBhIGZldGNoLlxuICAgKi9cbiAgcmVsb2FkRG9jdW1lbnQ/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgY3VycmVudCBlbnRyeSBpbiB0aGUgYnJvd3NlciBoaXN0b3J5IHN0YWNrIHdoZW4gdGhlIGZvcm1cbiAgICogbmF2aWdhdGVzLiBVc2UgdGhpcyBpZiB5b3UgZG9uJ3Qgd2FudCB0aGUgdXNlciB0byBiZSBhYmxlIHRvIGNsaWNrIFwiYmFja1wiXG4gICAqIHRvIHRoZSBwYWdlIHdpdGggdGhlIGZvcm0gb24gaXQuXG4gICAqL1xuICByZXBsYWNlPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogU3RhdGUgb2JqZWN0IHRvIGFkZCB0byB0aGUgaGlzdG9yeSBzdGFjayBlbnRyeSBmb3IgdGhpcyBuYXZpZ2F0aW9uXG4gICAqL1xuICBzdGF0ZT86IGFueTtcblxuICAvKipcbiAgICogRW5hYmxlIHZpZXcgdHJhbnNpdGlvbnMgb24gdGhpcyBGb3JtIG5hdmlnYXRpb25cbiAgICovXG4gIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uPzogYm9vbGVhbjtcbn1cblxudHlwZSBIVE1MU3VibWl0RXZlbnQgPSBSZWFjdC5CYXNlU3ludGhldGljRXZlbnQ8XG4gIFN1Ym1pdEV2ZW50LFxuICBFdmVudCxcbiAgSFRNTEZvcm1FbGVtZW50XG4+O1xuXG50eXBlIEhUTUxGb3JtU3VibWl0dGVyID0gSFRNTEJ1dHRvbkVsZW1lbnQgfCBIVE1MSW5wdXRFbGVtZW50O1xuXG4vKipcbiAqIEEgYEByZW1peC1ydW4vcm91dGVyYC1hd2FyZSBgPGZvcm0+YC4gSXQgYmVoYXZlcyBsaWtlIGEgbm9ybWFsIGZvcm0gZXhjZXB0XG4gKiB0aGF0IHRoZSBpbnRlcmFjdGlvbiB3aXRoIHRoZSBzZXJ2ZXIgaXMgd2l0aCBgZmV0Y2hgIGluc3RlYWQgb2YgbmV3IGRvY3VtZW50XG4gKiByZXF1ZXN0cywgYWxsb3dpbmcgY29tcG9uZW50cyB0byBhZGQgbmljZXIgVVggdG8gdGhlIHBhZ2UgYXMgdGhlIGZvcm0gaXNcbiAqIHN1Ym1pdHRlZCBhbmQgcmV0dXJucyB3aXRoIGRhdGEuXG4gKi9cbmV4cG9ydCBjb25zdCBGb3JtID0gUmVhY3QuZm9yd2FyZFJlZjxIVE1MRm9ybUVsZW1lbnQsIEZvcm1Qcm9wcz4oXG4gIChcbiAgICB7XG4gICAgICBmZXRjaGVyS2V5LFxuICAgICAgbmF2aWdhdGUsXG4gICAgICByZWxvYWREb2N1bWVudCxcbiAgICAgIHJlcGxhY2UsXG4gICAgICBzdGF0ZSxcbiAgICAgIG1ldGhvZCA9IGRlZmF1bHRNZXRob2QsXG4gICAgICBhY3Rpb24sXG4gICAgICBvblN1Ym1pdCxcbiAgICAgIHJlbGF0aXZlLFxuICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgdW5zdGFibGVfdmlld1RyYW5zaXRpb24sXG4gICAgICAuLi5wcm9wc1xuICAgIH0sXG4gICAgZm9yd2FyZGVkUmVmXG4gICkgPT4ge1xuICAgIGxldCBzdWJtaXQgPSB1c2VTdWJtaXQoKTtcbiAgICBsZXQgZm9ybUFjdGlvbiA9IHVzZUZvcm1BY3Rpb24oYWN0aW9uLCB7IHJlbGF0aXZlIH0pO1xuICAgIGxldCBmb3JtTWV0aG9kOiBIVE1MRm9ybU1ldGhvZCA9XG4gICAgICBtZXRob2QudG9Mb3dlckNhc2UoKSA9PT0gXCJnZXRcIiA/IFwiZ2V0XCIgOiBcInBvc3RcIjtcblxuICAgIGxldCBzdWJtaXRIYW5kbGVyOiBSZWFjdC5Gb3JtRXZlbnRIYW5kbGVyPEhUTUxGb3JtRWxlbWVudD4gPSAoZXZlbnQpID0+IHtcbiAgICAgIG9uU3VibWl0ICYmIG9uU3VibWl0KGV2ZW50KTtcbiAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBsZXQgc3VibWl0dGVyID0gKGV2ZW50IGFzIHVua25vd24gYXMgSFRNTFN1Ym1pdEV2ZW50KS5uYXRpdmVFdmVudFxuICAgICAgICAuc3VibWl0dGVyIGFzIEhUTUxGb3JtU3VibWl0dGVyIHwgbnVsbDtcblxuICAgICAgbGV0IHN1Ym1pdE1ldGhvZCA9XG4gICAgICAgIChzdWJtaXR0ZXI/LmdldEF0dHJpYnV0ZShcImZvcm1tZXRob2RcIikgYXMgSFRNTEZvcm1NZXRob2QgfCB1bmRlZmluZWQpIHx8XG4gICAgICAgIG1ldGhvZDtcblxuICAgICAgc3VibWl0KHN1Ym1pdHRlciB8fCBldmVudC5jdXJyZW50VGFyZ2V0LCB7XG4gICAgICAgIGZldGNoZXJLZXksXG4gICAgICAgIG1ldGhvZDogc3VibWl0TWV0aG9kLFxuICAgICAgICBuYXZpZ2F0ZSxcbiAgICAgICAgcmVwbGFjZSxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIHJlbGF0aXZlLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uLFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiAoXG4gICAgICA8Zm9ybVxuICAgICAgICByZWY9e2ZvcndhcmRlZFJlZn1cbiAgICAgICAgbWV0aG9kPXtmb3JtTWV0aG9kfVxuICAgICAgICBhY3Rpb249e2Zvcm1BY3Rpb259XG4gICAgICAgIG9uU3VibWl0PXtyZWxvYWREb2N1bWVudCA/IG9uU3VibWl0IDogc3VibWl0SGFuZGxlcn1cbiAgICAgICAgey4uLnByb3BzfVxuICAgICAgLz5cbiAgICApO1xuICB9XG4pO1xuXG5pZiAoX19ERVZfXykge1xuICBGb3JtLmRpc3BsYXlOYW1lID0gXCJGb3JtXCI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2Nyb2xsUmVzdG9yYXRpb25Qcm9wcyB7XG4gIGdldEtleT86IEdldFNjcm9sbFJlc3RvcmF0aW9uS2V5RnVuY3Rpb247XG4gIHN0b3JhZ2VLZXk/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogVGhpcyBjb21wb25lbnQgd2lsbCBlbXVsYXRlIHRoZSBicm93c2VyJ3Mgc2Nyb2xsIHJlc3RvcmF0aW9uIG9uIGxvY2F0aW9uXG4gKiBjaGFuZ2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gU2Nyb2xsUmVzdG9yYXRpb24oe1xuICBnZXRLZXksXG4gIHN0b3JhZ2VLZXksXG59OiBTY3JvbGxSZXN0b3JhdGlvblByb3BzKSB7XG4gIHVzZVNjcm9sbFJlc3RvcmF0aW9uKHsgZ2V0S2V5LCBzdG9yYWdlS2V5IH0pO1xuICByZXR1cm4gbnVsbDtcbn1cblxuaWYgKF9fREVWX18pIHtcbiAgU2Nyb2xsUmVzdG9yYXRpb24uZGlzcGxheU5hbWUgPSBcIlNjcm9sbFJlc3RvcmF0aW9uXCI7XG59XG4vLyNlbmRyZWdpb25cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBIb29rc1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZW51bSBEYXRhUm91dGVySG9vayB7XG4gIFVzZVNjcm9sbFJlc3RvcmF0aW9uID0gXCJ1c2VTY3JvbGxSZXN0b3JhdGlvblwiLFxuICBVc2VTdWJtaXQgPSBcInVzZVN1Ym1pdFwiLFxuICBVc2VTdWJtaXRGZXRjaGVyID0gXCJ1c2VTdWJtaXRGZXRjaGVyXCIsXG4gIFVzZUZldGNoZXIgPSBcInVzZUZldGNoZXJcIixcbiAgdXNlVmlld1RyYW5zaXRpb25TdGF0ZSA9IFwidXNlVmlld1RyYW5zaXRpb25TdGF0ZVwiLFxufVxuXG5lbnVtIERhdGFSb3V0ZXJTdGF0ZUhvb2sge1xuICBVc2VGZXRjaGVyID0gXCJ1c2VGZXRjaGVyXCIsXG4gIFVzZUZldGNoZXJzID0gXCJ1c2VGZXRjaGVyc1wiLFxuICBVc2VTY3JvbGxSZXN0b3JhdGlvbiA9IFwidXNlU2Nyb2xsUmVzdG9yYXRpb25cIixcbn1cblxuLy8gSW50ZXJuYWwgaG9va3NcblxuZnVuY3Rpb24gZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihcbiAgaG9va05hbWU6IERhdGFSb3V0ZXJIb29rIHwgRGF0YVJvdXRlclN0YXRlSG9va1xuKSB7XG4gIHJldHVybiBgJHtob29rTmFtZX0gbXVzdCBiZSB1c2VkIHdpdGhpbiBhIGRhdGEgcm91dGVyLiAgU2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3JvdXRlcnMvcGlja2luZy1hLXJvdXRlci5gO1xufVxuXG5mdW5jdGlvbiB1c2VEYXRhUm91dGVyQ29udGV4dChob29rTmFtZTogRGF0YVJvdXRlckhvb2spIHtcbiAgbGV0IGN0eCA9IFJlYWN0LnVzZUNvbnRleHQoRGF0YVJvdXRlckNvbnRleHQpO1xuICBpbnZhcmlhbnQoY3R4LCBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSk7XG4gIHJldHVybiBjdHg7XG59XG5cbmZ1bmN0aW9uIHVzZURhdGFSb3V0ZXJTdGF0ZShob29rTmFtZTogRGF0YVJvdXRlclN0YXRlSG9vaykge1xuICBsZXQgc3RhdGUgPSBSZWFjdC51c2VDb250ZXh0KERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQpO1xuICBpbnZhcmlhbnQoc3RhdGUsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpKTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vLyBFeHRlcm5hbCBob29rc1xuXG4vKipcbiAqIEhhbmRsZXMgdGhlIGNsaWNrIGJlaGF2aW9yIGZvciByb3V0ZXIgYDxMaW5rPmAgY29tcG9uZW50cy4gVGhpcyBpcyB1c2VmdWwgaWZcbiAqIHlvdSBuZWVkIHRvIGNyZWF0ZSBjdXN0b20gYDxMaW5rPmAgY29tcG9uZW50cyB3aXRoIHRoZSBzYW1lIGNsaWNrIGJlaGF2aW9yIHdlXG4gKiB1c2UgaW4gb3VyIGV4cG9ydGVkIGA8TGluaz5gLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTGlua0NsaWNrSGFuZGxlcjxFIGV4dGVuZHMgRWxlbWVudCA9IEhUTUxBbmNob3JFbGVtZW50PihcbiAgdG86IFRvLFxuICB7XG4gICAgdGFyZ2V0LFxuICAgIHJlcGxhY2U6IHJlcGxhY2VQcm9wLFxuICAgIHN0YXRlLFxuICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICByZWxhdGl2ZSxcbiAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbixcbiAgfToge1xuICAgIHRhcmdldD86IFJlYWN0LkhUTUxBdHRyaWJ1dGVBbmNob3JUYXJnZXQ7XG4gICAgcmVwbGFjZT86IGJvb2xlYW47XG4gICAgc3RhdGU/OiBhbnk7XG4gICAgcHJldmVudFNjcm9sbFJlc2V0PzogYm9vbGVhbjtcbiAgICByZWxhdGl2ZT86IFJlbGF0aXZlUm91dGluZ1R5cGU7XG4gICAgdW5zdGFibGVfdmlld1RyYW5zaXRpb24/OiBib29sZWFuO1xuICB9ID0ge31cbik6IChldmVudDogUmVhY3QuTW91c2VFdmVudDxFLCBNb3VzZUV2ZW50PikgPT4gdm9pZCB7XG4gIGxldCBuYXZpZ2F0ZSA9IHVzZU5hdmlnYXRlKCk7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBwYXRoID0gdXNlUmVzb2x2ZWRQYXRoKHRvLCB7IHJlbGF0aXZlIH0pO1xuXG4gIHJldHVybiBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAoZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQ8RSwgTW91c2VFdmVudD4pID0+IHtcbiAgICAgIGlmIChzaG91bGRQcm9jZXNzTGlua0NsaWNrKGV2ZW50LCB0YXJnZXQpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgLy8gSWYgdGhlIFVSTCBoYXNuJ3QgY2hhbmdlZCwgYSByZWd1bGFyIDxhPiB3aWxsIGRvIGEgcmVwbGFjZSBpbnN0ZWFkIG9mXG4gICAgICAgIC8vIGEgcHVzaCwgc28gZG8gdGhlIHNhbWUgaGVyZSB1bmxlc3MgdGhlIHJlcGxhY2UgcHJvcCBpcyBleHBsaWNpdGx5IHNldFxuICAgICAgICBsZXQgcmVwbGFjZSA9XG4gICAgICAgICAgcmVwbGFjZVByb3AgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyByZXBsYWNlUHJvcFxuICAgICAgICAgICAgOiBjcmVhdGVQYXRoKGxvY2F0aW9uKSA9PT0gY3JlYXRlUGF0aChwYXRoKTtcblxuICAgICAgICBuYXZpZ2F0ZSh0bywge1xuICAgICAgICAgIHJlcGxhY2UsXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICAgIHJlbGF0aXZlLFxuICAgICAgICAgIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgbmF2aWdhdGUsXG4gICAgICBwYXRoLFxuICAgICAgcmVwbGFjZVByb3AsXG4gICAgICBzdGF0ZSxcbiAgICAgIHRhcmdldCxcbiAgICAgIHRvLFxuICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgcmVsYXRpdmUsXG4gICAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbixcbiAgICBdXG4gICk7XG59XG5cbi8qKlxuICogQSBjb252ZW5pZW50IHdyYXBwZXIgZm9yIHJlYWRpbmcgYW5kIHdyaXRpbmcgc2VhcmNoIHBhcmFtZXRlcnMgdmlhIHRoZVxuICogVVJMU2VhcmNoUGFyYW1zIGludGVyZmFjZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVNlYXJjaFBhcmFtcyhcbiAgZGVmYXVsdEluaXQ/OiBVUkxTZWFyY2hQYXJhbXNJbml0XG4pOiBbVVJMU2VhcmNoUGFyYW1zLCBTZXRVUkxTZWFyY2hQYXJhbXNdIHtcbiAgd2FybmluZyhcbiAgICB0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSBcInVuZGVmaW5lZFwiLFxuICAgIGBZb3UgY2Fubm90IHVzZSB0aGUgXFxgdXNlU2VhcmNoUGFyYW1zXFxgIGhvb2sgaW4gYSBicm93c2VyIHRoYXQgZG9lcyBub3QgYCArXG4gICAgICBgc3VwcG9ydCB0aGUgVVJMU2VhcmNoUGFyYW1zIEFQSS4gSWYgeW91IG5lZWQgdG8gc3VwcG9ydCBJbnRlcm5ldCBgICtcbiAgICAgIGBFeHBsb3JlciAxMSwgd2UgcmVjb21tZW5kIHlvdSBsb2FkIGEgcG9seWZpbGwgc3VjaCBhcyBgICtcbiAgICAgIGBodHRwczovL2dpdGh1Yi5jb20vdW5nYXAvdXJsLXNlYXJjaC1wYXJhbXNcXG5cXG5gICtcbiAgICAgIGBJZiB5b3UncmUgdW5zdXJlIGhvdyB0byBsb2FkIHBvbHlmaWxscywgd2UgcmVjb21tZW5kIHlvdSBjaGVjayBvdXQgYCArXG4gICAgICBgaHR0cHM6Ly9wb2x5ZmlsbC5pby92My8gd2hpY2ggcHJvdmlkZXMgc29tZSByZWNvbW1lbmRhdGlvbnMgYWJvdXQgaG93IGAgK1xuICAgICAgYHRvIGxvYWQgcG9seWZpbGxzIG9ubHkgZm9yIHVzZXJzIHRoYXQgbmVlZCB0aGVtLCBpbnN0ZWFkIG9mIGZvciBldmVyeSBgICtcbiAgICAgIGB1c2VyLmBcbiAgKTtcblxuICBsZXQgZGVmYXVsdFNlYXJjaFBhcmFtc1JlZiA9IFJlYWN0LnVzZVJlZihjcmVhdGVTZWFyY2hQYXJhbXMoZGVmYXVsdEluaXQpKTtcbiAgbGV0IGhhc1NldFNlYXJjaFBhcmFtc1JlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG5cbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHNlYXJjaFBhcmFtcyA9IFJlYWN0LnVzZU1lbW8oXG4gICAgKCkgPT5cbiAgICAgIC8vIE9ubHkgbWVyZ2UgaW4gdGhlIGRlZmF1bHRzIGlmIHdlIGhhdmVuJ3QgeWV0IGNhbGxlZCBzZXRTZWFyY2hQYXJhbXMuXG4gICAgICAvLyBPbmNlIHdlIGNhbGwgdGhhdCB3ZSB3YW50IHRob3NlIHRvIHRha2UgcHJlY2VkZW5jZSwgb3RoZXJ3aXNlIHlvdSBjYW4ndFxuICAgICAgLy8gcmVtb3ZlIGEgcGFyYW0gd2l0aCBzZXRTZWFyY2hQYXJhbXMoe30pIGlmIGl0IGhhcyBhbiBpbml0aWFsIHZhbHVlXG4gICAgICBnZXRTZWFyY2hQYXJhbXNGb3JMb2NhdGlvbihcbiAgICAgICAgbG9jYXRpb24uc2VhcmNoLFxuICAgICAgICBoYXNTZXRTZWFyY2hQYXJhbXNSZWYuY3VycmVudCA/IG51bGwgOiBkZWZhdWx0U2VhcmNoUGFyYW1zUmVmLmN1cnJlbnRcbiAgICAgICksXG4gICAgW2xvY2F0aW9uLnNlYXJjaF1cbiAgKTtcblxuICBsZXQgbmF2aWdhdGUgPSB1c2VOYXZpZ2F0ZSgpO1xuICBsZXQgc2V0U2VhcmNoUGFyYW1zID0gUmVhY3QudXNlQ2FsbGJhY2s8U2V0VVJMU2VhcmNoUGFyYW1zPihcbiAgICAobmV4dEluaXQsIG5hdmlnYXRlT3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgbmV3U2VhcmNoUGFyYW1zID0gY3JlYXRlU2VhcmNoUGFyYW1zKFxuICAgICAgICB0eXBlb2YgbmV4dEluaXQgPT09IFwiZnVuY3Rpb25cIiA/IG5leHRJbml0KHNlYXJjaFBhcmFtcykgOiBuZXh0SW5pdFxuICAgICAgKTtcbiAgICAgIGhhc1NldFNlYXJjaFBhcmFtc1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIG5hdmlnYXRlKFwiP1wiICsgbmV3U2VhcmNoUGFyYW1zLCBuYXZpZ2F0ZU9wdGlvbnMpO1xuICAgIH0sXG4gICAgW25hdmlnYXRlLCBzZWFyY2hQYXJhbXNdXG4gICk7XG5cbiAgcmV0dXJuIFtzZWFyY2hQYXJhbXMsIHNldFNlYXJjaFBhcmFtc107XG59XG5cbmV4cG9ydCB0eXBlIFNldFVSTFNlYXJjaFBhcmFtcyA9IChcbiAgbmV4dEluaXQ/OlxuICAgIHwgVVJMU2VhcmNoUGFyYW1zSW5pdFxuICAgIHwgKChwcmV2OiBVUkxTZWFyY2hQYXJhbXMpID0+IFVSTFNlYXJjaFBhcmFtc0luaXQpLFxuICBuYXZpZ2F0ZU9wdHM/OiBOYXZpZ2F0ZU9wdGlvbnNcbikgPT4gdm9pZDtcblxuLyoqXG4gKiBTdWJtaXRzIGEgSFRNTCBgPGZvcm0+YCB0byB0aGUgc2VydmVyIHdpdGhvdXQgcmVsb2FkaW5nIHRoZSBwYWdlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN1Ym1pdEZ1bmN0aW9uIHtcbiAgKFxuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgYDxmb3JtPmAgdG8gYmUgc3VibWl0dGVkIHRvIHRoZSBzZXJ2ZXIsIGEgc3BlY2lmaWNcbiAgICAgKiBgPGJ1dHRvbj5gIG9yIGA8aW5wdXQgdHlwZT1cInN1Ym1pdFwiPmAgdG8gdXNlIHRvIHN1Ym1pdCB0aGUgZm9ybSwgb3Igc29tZVxuICAgICAqIGFyYml0cmFyeSBkYXRhIHRvIHN1Ym1pdC5cbiAgICAgKlxuICAgICAqIE5vdGU6IFdoZW4gdXNpbmcgYSBgPGJ1dHRvbj5gIGl0cyBgbmFtZWAgYW5kIGB2YWx1ZWAgd2lsbCBhbHNvIGJlXG4gICAgICogaW5jbHVkZWQgaW4gdGhlIGZvcm0gZGF0YSB0aGF0IGlzIHN1Ym1pdHRlZC5cbiAgICAgKi9cbiAgICB0YXJnZXQ6IFN1Ym1pdFRhcmdldCxcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbnMgdGhhdCBvdmVycmlkZSB0aGUgYDxmb3JtPmAncyBvd24gYXR0cmlidXRlcy4gUmVxdWlyZWQgd2hlblxuICAgICAqIHN1Ym1pdHRpbmcgYXJiaXRyYXJ5IGRhdGEgd2l0aG91dCBhIGJhY2tpbmcgYDxmb3JtPmAuXG4gICAgICovXG4gICAgb3B0aW9ucz86IFN1Ym1pdE9wdGlvbnNcbiAgKTogdm9pZDtcbn1cblxuLyoqXG4gKiBTdWJtaXRzIGEgZmV0Y2hlciBgPGZvcm0+YCB0byB0aGUgc2VydmVyIHdpdGhvdXQgcmVsb2FkaW5nIHRoZSBwYWdlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZldGNoZXJTdWJtaXRGdW5jdGlvbiB7XG4gIChcbiAgICB0YXJnZXQ6IFN1Ym1pdFRhcmdldCxcbiAgICAvLyBGZXRjaGVycyBjYW5ub3QgcmVwbGFjZSBvciBzZXQgc3RhdGUgYmVjYXVzZSB0aGV5IGFyZSBub3QgbmF2aWdhdGlvbiBldmVudHNcbiAgICBvcHRpb25zPzogT21pdDxTdWJtaXRPcHRpb25zLCBcInJlcGxhY2VcIiB8IFwic3RhdGVcIj5cbiAgKTogdm9pZDtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVDbGllbnRTaWRlU3VibWlzc2lvbigpIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiWW91IGFyZSBjYWxsaW5nIHN1Ym1pdCBkdXJpbmcgdGhlIHNlcnZlciByZW5kZXIuIFwiICtcbiAgICAgICAgXCJUcnkgY2FsbGluZyBzdWJtaXQgd2l0aGluIGEgYHVzZUVmZmVjdGAgb3IgY2FsbGJhY2sgaW5zdGVhZC5cIlxuICAgICk7XG4gIH1cbn1cblxubGV0IGZldGNoZXJJZCA9IDA7XG5sZXQgZ2V0VW5pcXVlRmV0Y2hlcklkID0gKCkgPT4gYF9fJHtTdHJpbmcoKytmZXRjaGVySWQpfV9fYDtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBtYXkgYmUgdXNlZCB0byBwcm9ncmFtbWF0aWNhbGx5IHN1Ym1pdCBhIGZvcm0gKG9yXG4gKiBzb21lIGFyYml0cmFyeSBkYXRhKSB0byB0aGUgc2VydmVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3VibWl0KCk6IFN1Ym1pdEZ1bmN0aW9uIHtcbiAgbGV0IHsgcm91dGVyIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dChEYXRhUm91dGVySG9vay5Vc2VTdWJtaXQpO1xuICBsZXQgeyBiYXNlbmFtZSB9ID0gUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCBjdXJyZW50Um91dGVJZCA9IHVzZVJvdXRlSWQoKTtcblxuICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2s8U3VibWl0RnVuY3Rpb24+KFxuICAgICh0YXJnZXQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgdmFsaWRhdGVDbGllbnRTaWRlU3VibWlzc2lvbigpO1xuXG4gICAgICBsZXQgeyBhY3Rpb24sIG1ldGhvZCwgZW5jVHlwZSwgZm9ybURhdGEsIGJvZHkgfSA9IGdldEZvcm1TdWJtaXNzaW9uSW5mbyhcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBiYXNlbmFtZVxuICAgICAgKTtcblxuICAgICAgaWYgKG9wdGlvbnMubmF2aWdhdGUgPT09IGZhbHNlKSB7XG4gICAgICAgIGxldCBrZXkgPSBvcHRpb25zLmZldGNoZXJLZXkgfHwgZ2V0VW5pcXVlRmV0Y2hlcklkKCk7XG4gICAgICAgIHJvdXRlci5mZXRjaChrZXksIGN1cnJlbnRSb3V0ZUlkLCBvcHRpb25zLmFjdGlvbiB8fCBhY3Rpb24sIHtcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IG9wdGlvbnMucHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICAgIGZvcm1EYXRhLFxuICAgICAgICAgIGJvZHksXG4gICAgICAgICAgZm9ybU1ldGhvZDogb3B0aW9ucy5tZXRob2QgfHwgKG1ldGhvZCBhcyBIVE1MRm9ybU1ldGhvZCksXG4gICAgICAgICAgZm9ybUVuY1R5cGU6IG9wdGlvbnMuZW5jVHlwZSB8fCAoZW5jVHlwZSBhcyBGb3JtRW5jVHlwZSksXG4gICAgICAgICAgdW5zdGFibGVfZmx1c2hTeW5jOiBvcHRpb25zLnVuc3RhYmxlX2ZsdXNoU3luYyxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb3V0ZXIubmF2aWdhdGUob3B0aW9ucy5hY3Rpb24gfHwgYWN0aW9uLCB7XG4gICAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBvcHRpb25zLnByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgICAgICBmb3JtRGF0YSxcbiAgICAgICAgICBib2R5LFxuICAgICAgICAgIGZvcm1NZXRob2Q6IG9wdGlvbnMubWV0aG9kIHx8IChtZXRob2QgYXMgSFRNTEZvcm1NZXRob2QpLFxuICAgICAgICAgIGZvcm1FbmNUeXBlOiBvcHRpb25zLmVuY1R5cGUgfHwgKGVuY1R5cGUgYXMgRm9ybUVuY1R5cGUpLFxuICAgICAgICAgIHJlcGxhY2U6IG9wdGlvbnMucmVwbGFjZSxcbiAgICAgICAgICBzdGF0ZTogb3B0aW9ucy5zdGF0ZSxcbiAgICAgICAgICBmcm9tUm91dGVJZDogY3VycmVudFJvdXRlSWQsXG4gICAgICAgICAgdW5zdGFibGVfZmx1c2hTeW5jOiBvcHRpb25zLnVuc3RhYmxlX2ZsdXNoU3luYyxcbiAgICAgICAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbjogb3B0aW9ucy51bnN0YWJsZV92aWV3VHJhbnNpdGlvbixcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbcm91dGVyLCBiYXNlbmFtZSwgY3VycmVudFJvdXRlSWRdXG4gICk7XG59XG5cbi8vIHY3OiBFdmVudHVhbGx5IHdlIHNob3VsZCBkZXByZWNhdGUgdGhpcyBlbnRpcmVseSBpbiBmYXZvciBvZiB1c2luZyB0aGVcbi8vIHJvdXRlciBtZXRob2QgZGlyZWN0bHk/XG5leHBvcnQgZnVuY3Rpb24gdXNlRm9ybUFjdGlvbihcbiAgYWN0aW9uPzogc3RyaW5nLFxuICB7IHJlbGF0aXZlIH06IHsgcmVsYXRpdmU/OiBSZWxhdGl2ZVJvdXRpbmdUeXBlIH0gPSB7fVxuKTogc3RyaW5nIHtcbiAgbGV0IHsgYmFzZW5hbWUgfSA9IFJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgcm91dGVDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBpbnZhcmlhbnQocm91dGVDb250ZXh0LCBcInVzZUZvcm1BY3Rpb24gbXVzdCBiZSB1c2VkIGluc2lkZSBhIFJvdXRlQ29udGV4dFwiKTtcblxuICBsZXQgW21hdGNoXSA9IHJvdXRlQ29udGV4dC5tYXRjaGVzLnNsaWNlKC0xKTtcbiAgLy8gU2hhbGxvdyBjbG9uZSBwYXRoIHNvIHdlIGNhbiBtb2RpZnkgaXQgYmVsb3csIG90aGVyd2lzZSB3ZSBtb2RpZnkgdGhlXG4gIC8vIG9iamVjdCByZWZlcmVuY2VkIGJ5IHVzZU1lbW8gaW5zaWRlIHVzZVJlc29sdmVkUGF0aFxuICBsZXQgcGF0aCA9IHsgLi4udXNlUmVzb2x2ZWRQYXRoKGFjdGlvbiA/IGFjdGlvbiA6IFwiLlwiLCB7IHJlbGF0aXZlIH0pIH07XG5cbiAgLy8gSWYgbm8gYWN0aW9uIHdhcyBzcGVjaWZpZWQsIGJyb3dzZXJzIHdpbGwgcGVyc2lzdCBjdXJyZW50IHNlYXJjaCBwYXJhbXNcbiAgLy8gd2hlbiBkZXRlcm1pbmluZyB0aGUgcGF0aCwgc28gbWF0Y2ggdGhhdCBiZWhhdmlvclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL3JlbWl4L2lzc3Vlcy85MjdcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgaWYgKGFjdGlvbiA9PSBudWxsKSB7XG4gICAgLy8gU2FmZSB0byB3cml0ZSB0byB0aGlzIGRpcmVjdGx5IGhlcmUgc2luY2UgaWYgYWN0aW9uIHdhcyB1bmRlZmluZWQsIHdlXG4gICAgLy8gd291bGQgaGF2ZSBjYWxsZWQgdXNlUmVzb2x2ZWRQYXRoKFwiLlwiKSB3aGljaCB3aWxsIG5ldmVyIGluY2x1ZGUgYSBzZWFyY2hcbiAgICBwYXRoLnNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaDtcblxuICAgIC8vIFdoZW4gZ3JhYmJpbmcgc2VhcmNoIHBhcmFtcyBmcm9tIHRoZSBVUkwsIHJlbW92ZSBhbnkgaW5jbHVkZWQgP2luZGV4IHBhcmFtXG4gICAgLy8gc2luY2UgaXQgbWlnaHQgbm90IGFwcGx5IHRvIG91ciBjb250ZXh0dWFsIHJvdXRlLiAgV2UgYWRkIGl0IGJhY2sgYmFzZWRcbiAgICAvLyBvbiBtYXRjaC5yb3V0ZS5pbmRleCBiZWxvd1xuICAgIGxldCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhdGguc2VhcmNoKTtcbiAgICBpZiAocGFyYW1zLmhhcyhcImluZGV4XCIpICYmIHBhcmFtcy5nZXQoXCJpbmRleFwiKSA9PT0gXCJcIikge1xuICAgICAgcGFyYW1zLmRlbGV0ZShcImluZGV4XCIpO1xuICAgICAgcGF0aC5zZWFyY2ggPSBwYXJhbXMudG9TdHJpbmcoKSA/IGA/JHtwYXJhbXMudG9TdHJpbmcoKX1gIDogXCJcIjtcbiAgICB9XG4gIH1cblxuICBpZiAoKCFhY3Rpb24gfHwgYWN0aW9uID09PSBcIi5cIikgJiYgbWF0Y2gucm91dGUuaW5kZXgpIHtcbiAgICBwYXRoLnNlYXJjaCA9IHBhdGguc2VhcmNoXG4gICAgICA/IHBhdGguc2VhcmNoLnJlcGxhY2UoL15cXD8vLCBcIj9pbmRleCZcIilcbiAgICAgIDogXCI/aW5kZXhcIjtcbiAgfVxuXG4gIC8vIElmIHdlJ3JlIG9wZXJhdGluZyB3aXRoaW4gYSBiYXNlbmFtZSwgcHJlcGVuZCBpdCB0byB0aGUgcGF0aG5hbWUgcHJpb3JcbiAgLy8gdG8gY3JlYXRpbmcgdGhlIGZvcm0gYWN0aW9uLiAgSWYgdGhpcyBpcyBhIHJvb3QgbmF2aWdhdGlvbiwgdGhlbiBqdXN0IHVzZVxuICAvLyB0aGUgcmF3IGJhc2VuYW1lIHdoaWNoIGFsbG93cyB0aGUgYmFzZW5hbWUgdG8gaGF2ZSBmdWxsIGNvbnRyb2wgb3ZlciB0aGVcbiAgLy8gcHJlc2VuY2Ugb2YgYSB0cmFpbGluZyBzbGFzaCBvbiByb290IGFjdGlvbnNcbiAgaWYgKGJhc2VuYW1lICE9PSBcIi9cIikge1xuICAgIHBhdGgucGF0aG5hbWUgPVxuICAgICAgcGF0aC5wYXRobmFtZSA9PT0gXCIvXCIgPyBiYXNlbmFtZSA6IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGgucGF0aG5hbWVdKTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVQYXRoKHBhdGgpO1xufVxuXG5leHBvcnQgdHlwZSBGZXRjaGVyV2l0aENvbXBvbmVudHM8VERhdGE+ID0gRmV0Y2hlcjxURGF0YT4gJiB7XG4gIEZvcm06IFJlYWN0LkZvcndhcmRSZWZFeG90aWNDb21wb25lbnQ8XG4gICAgRmV0Y2hlckZvcm1Qcm9wcyAmIFJlYWN0LlJlZkF0dHJpYnV0ZXM8SFRNTEZvcm1FbGVtZW50PlxuICA+O1xuICBzdWJtaXQ6IEZldGNoZXJTdWJtaXRGdW5jdGlvbjtcbiAgbG9hZDogKGhyZWY6IHN0cmluZywgb3B0cz86IHsgdW5zdGFibGVfZmx1c2hTeW5jPzogYm9vbGVhbiB9KSA9PiB2b2lkO1xufTtcblxuLy8gVE9ETzogKHY3KSBDaGFuZ2UgdGhlIHVzZUZldGNoZXIgZ2VuZXJpYyBkZWZhdWx0IGZyb20gYGFueWAgdG8gYHVua25vd25gXG5cbi8qKlxuICogSW50ZXJhY3RzIHdpdGggcm91dGUgbG9hZGVycyBhbmQgYWN0aW9ucyB3aXRob3V0IGNhdXNpbmcgYSBuYXZpZ2F0aW9uLiBHcmVhdFxuICogZm9yIGFueSBpbnRlcmFjdGlvbiB0aGF0IHN0YXlzIG9uIHRoZSBzYW1lIHBhZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VGZXRjaGVyPFREYXRhID0gYW55Pih7XG4gIGtleSxcbn06IHsga2V5Pzogc3RyaW5nIH0gPSB7fSk6IEZldGNoZXJXaXRoQ29tcG9uZW50czxURGF0YT4ge1xuICBsZXQgeyByb3V0ZXIgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KERhdGFSb3V0ZXJIb29rLlVzZUZldGNoZXIpO1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VGZXRjaGVyKTtcbiAgbGV0IGZldGNoZXJEYXRhID0gUmVhY3QudXNlQ29udGV4dChGZXRjaGVyc0NvbnRleHQpO1xuICBsZXQgcm91dGUgPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCByb3V0ZUlkID0gcm91dGUubWF0Y2hlc1tyb3V0ZS5tYXRjaGVzLmxlbmd0aCAtIDFdPy5yb3V0ZS5pZDtcblxuICBpbnZhcmlhbnQoZmV0Y2hlckRhdGEsIGB1c2VGZXRjaGVyIG11c3QgYmUgdXNlZCBpbnNpZGUgYSBGZXRjaGVyc0NvbnRleHRgKTtcbiAgaW52YXJpYW50KHJvdXRlLCBgdXNlRmV0Y2hlciBtdXN0IGJlIHVzZWQgaW5zaWRlIGEgUm91dGVDb250ZXh0YCk7XG4gIGludmFyaWFudChcbiAgICByb3V0ZUlkICE9IG51bGwsXG4gICAgYHVzZUZldGNoZXIgY2FuIG9ubHkgYmUgdXNlZCBvbiByb3V0ZXMgdGhhdCBjb250YWluIGEgdW5pcXVlIFwiaWRcImBcbiAgKTtcblxuICAvLyBGZXRjaGVyIGtleSBoYW5kbGluZ1xuICBsZXQgW2ZldGNoZXJLZXksIHNldEZldGNoZXJLZXldID0gUmVhY3QudXNlU3RhdGU8c3RyaW5nPihrZXkgfHwgXCJcIik7XG4gIGlmIChrZXkgJiYga2V5ICE9PSBmZXRjaGVyS2V5KSB7XG4gICAgc2V0RmV0Y2hlcktleShrZXkpO1xuICB9IGVsc2UgaWYgKCFmZXRjaGVyS2V5KSB7XG4gICAgc2V0RmV0Y2hlcktleShnZXRVbmlxdWVGZXRjaGVySWQoKSk7XG4gIH1cblxuICAvLyBSZWdpc3RyYXRpb24vY2xlYW51cFxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJvdXRlci5nZXRGZXRjaGVyKGZldGNoZXJLZXkpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAvLyBUZWxsIHRoZSByb3V0ZXIgd2UndmUgdW5tb3VudGVkIC0gaWYgdjdfZmV0Y2hlclBlcnNpc3QgaXMgZW5hYmxlZCB0aGlzXG4gICAgICAvLyB3aWxsIG5vdCBkZWxldGUgaW1tZWRpYXRlbHkgYnV0IGluc3RlYWQgcXVldWUgdXAgYSBkZWxldGUgYWZ0ZXIgdGhlXG4gICAgICAvLyBmZXRjaGVyIHJldHVybnMgdG8gYW4gYGlkbGVgIHN0YXRlXG4gICAgICByb3V0ZXIuZGVsZXRlRmV0Y2hlcihmZXRjaGVyS2V5KTtcbiAgICB9O1xuICB9LCBbcm91dGVyLCBmZXRjaGVyS2V5XSk7XG5cbiAgLy8gRmV0Y2hlciBhZGRpdGlvbnNcbiAgbGV0IGxvYWQgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAoaHJlZjogc3RyaW5nLCBvcHRzPzogeyB1bnN0YWJsZV9mbHVzaFN5bmM/OiBib29sZWFuIH0pID0+IHtcbiAgICAgIGludmFyaWFudChyb3V0ZUlkLCBcIk5vIHJvdXRlSWQgYXZhaWxhYmxlIGZvciBmZXRjaGVyLmxvYWQoKVwiKTtcbiAgICAgIHJvdXRlci5mZXRjaChmZXRjaGVyS2V5LCByb3V0ZUlkLCBocmVmLCBvcHRzKTtcbiAgICB9LFxuICAgIFtmZXRjaGVyS2V5LCByb3V0ZUlkLCByb3V0ZXJdXG4gICk7XG5cbiAgbGV0IHN1Ym1pdEltcGwgPSB1c2VTdWJtaXQoKTtcbiAgbGV0IHN1Ym1pdCA9IFJlYWN0LnVzZUNhbGxiYWNrPEZldGNoZXJTdWJtaXRGdW5jdGlvbj4oXG4gICAgKHRhcmdldCwgb3B0cykgPT4ge1xuICAgICAgc3VibWl0SW1wbCh0YXJnZXQsIHtcbiAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgbmF2aWdhdGU6IGZhbHNlLFxuICAgICAgICBmZXRjaGVyS2V5LFxuICAgICAgfSk7XG4gICAgfSxcbiAgICBbZmV0Y2hlcktleSwgc3VibWl0SW1wbF1cbiAgKTtcblxuICBsZXQgRmV0Y2hlckZvcm0gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBsZXQgRmV0Y2hlckZvcm0gPSBSZWFjdC5mb3J3YXJkUmVmPEhUTUxGb3JtRWxlbWVudCwgRmV0Y2hlckZvcm1Qcm9wcz4oXG4gICAgICAocHJvcHMsIHJlZikgPT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIDxGb3JtIHsuLi5wcm9wc30gbmF2aWdhdGU9e2ZhbHNlfSBmZXRjaGVyS2V5PXtmZXRjaGVyS2V5fSByZWY9e3JlZn0gLz5cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICApO1xuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICBGZXRjaGVyRm9ybS5kaXNwbGF5TmFtZSA9IFwiZmV0Y2hlci5Gb3JtXCI7XG4gICAgfVxuICAgIHJldHVybiBGZXRjaGVyRm9ybTtcbiAgfSwgW2ZldGNoZXJLZXldKTtcblxuICAvLyBFeHBvc2VkIEZldGNoZXJXaXRoQ29tcG9uZW50c1xuICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChmZXRjaGVyS2V5KSB8fCBJRExFX0ZFVENIRVI7XG4gIGxldCBkYXRhID0gZmV0Y2hlckRhdGEuZ2V0KGZldGNoZXJLZXkpO1xuICBsZXQgZmV0Y2hlcldpdGhDb21wb25lbnRzID0gUmVhY3QudXNlTWVtbyhcbiAgICAoKSA9PiAoe1xuICAgICAgRm9ybTogRmV0Y2hlckZvcm0sXG4gICAgICBzdWJtaXQsXG4gICAgICBsb2FkLFxuICAgICAgLi4uZmV0Y2hlcixcbiAgICAgIGRhdGEsXG4gICAgfSksXG4gICAgW0ZldGNoZXJGb3JtLCBzdWJtaXQsIGxvYWQsIGZldGNoZXIsIGRhdGFdXG4gICk7XG5cbiAgcmV0dXJuIGZldGNoZXJXaXRoQ29tcG9uZW50cztcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBhbGwgZmV0Y2hlcnMgY3VycmVudGx5IG9uIHRoZSBwYWdlLiBVc2VmdWwgZm9yIGxheW91dHMgYW5kIHBhcmVudFxuICogcm91dGVzIHRoYXQgbmVlZCB0byBwcm92aWRlIHBlbmRpbmcvb3B0aW1pc3RpYyBVSSByZWdhcmRpbmcgdGhlIGZldGNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRmV0Y2hlcnMoKTogKEZldGNoZXIgJiB7IGtleTogc3RyaW5nIH0pW10ge1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VGZXRjaGVycyk7XG4gIHJldHVybiBBcnJheS5mcm9tKHN0YXRlLmZldGNoZXJzLmVudHJpZXMoKSkubWFwKChba2V5LCBmZXRjaGVyXSkgPT4gKHtcbiAgICAuLi5mZXRjaGVyLFxuICAgIGtleSxcbiAgfSkpO1xufVxuXG5jb25zdCBTQ1JPTExfUkVTVE9SQVRJT05fU1RPUkFHRV9LRVkgPSBcInJlYWN0LXJvdXRlci1zY3JvbGwtcG9zaXRpb25zXCI7XG5sZXQgc2F2ZWRTY3JvbGxQb3NpdGlvbnM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcblxuLyoqXG4gKiBXaGVuIHJlbmRlcmVkIGluc2lkZSBhIFJvdXRlclByb3ZpZGVyLCB3aWxsIHJlc3RvcmUgc2Nyb2xsIHBvc2l0aW9ucyBvbiBuYXZpZ2F0aW9uc1xuICovXG5mdW5jdGlvbiB1c2VTY3JvbGxSZXN0b3JhdGlvbih7XG4gIGdldEtleSxcbiAgc3RvcmFnZUtleSxcbn06IHtcbiAgZ2V0S2V5PzogR2V0U2Nyb2xsUmVzdG9yYXRpb25LZXlGdW5jdGlvbjtcbiAgc3RvcmFnZUtleT86IHN0cmluZztcbn0gPSB7fSkge1xuICBsZXQgeyByb3V0ZXIgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KERhdGFSb3V0ZXJIb29rLlVzZVNjcm9sbFJlc3RvcmF0aW9uKTtcbiAgbGV0IHsgcmVzdG9yZVNjcm9sbFBvc2l0aW9uLCBwcmV2ZW50U2Nyb2xsUmVzZXQgfSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShcbiAgICBEYXRhUm91dGVyU3RhdGVIb29rLlVzZVNjcm9sbFJlc3RvcmF0aW9uXG4gICk7XG4gIGxldCB7IGJhc2VuYW1lIH0gPSBSZWFjdC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IG1hdGNoZXMgPSB1c2VNYXRjaGVzKCk7XG4gIGxldCBuYXZpZ2F0aW9uID0gdXNlTmF2aWdhdGlvbigpO1xuXG4gIC8vIFRyaWdnZXIgbWFudWFsIHNjcm9sbCByZXN0b3JhdGlvbiB3aGlsZSB3ZSdyZSBhY3RpdmVcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwibWFudWFsXCI7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJhdXRvXCI7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIC8vIFNhdmUgcG9zaXRpb25zIG9uIHBhZ2VoaWRlXG4gIHVzZVBhZ2VIaWRlKFxuICAgIFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgIGlmIChuYXZpZ2F0aW9uLnN0YXRlID09PSBcImlkbGVcIikge1xuICAgICAgICBsZXQga2V5ID0gKGdldEtleSA/IGdldEtleShsb2NhdGlvbiwgbWF0Y2hlcykgOiBudWxsKSB8fCBsb2NhdGlvbi5rZXk7XG4gICAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zW2tleV0gPSB3aW5kb3cuc2Nyb2xsWTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXG4gICAgICAgICAgc3RvcmFnZUtleSB8fCBTQ1JPTExfUkVTVE9SQVRJT05fU1RPUkFHRV9LRVksXG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkoc2F2ZWRTY3JvbGxQb3NpdGlvbnMpXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIGBGYWlsZWQgdG8gc2F2ZSBzY3JvbGwgcG9zaXRpb25zIGluIHNlc3Npb25TdG9yYWdlLCA8U2Nyb2xsUmVzdG9yYXRpb24gLz4gd2lsbCBub3Qgd29yayBwcm9wZXJseSAoJHtlcnJvcn0pLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJhdXRvXCI7XG4gICAgfSwgW3N0b3JhZ2VLZXksIGdldEtleSwgbmF2aWdhdGlvbi5zdGF0ZSwgbG9jYXRpb24sIG1hdGNoZXNdKVxuICApO1xuXG4gIC8vIFJlYWQgaW4gYW55IHNhdmVkIHNjcm9sbCBsb2NhdGlvbnNcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgc2Vzc2lvblBvc2l0aW9ucyA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oXG4gICAgICAgICAgc3RvcmFnZUtleSB8fCBTQ1JPTExfUkVTVE9SQVRJT05fU1RPUkFHRV9LRVlcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHNlc3Npb25Qb3NpdGlvbnMpIHtcbiAgICAgICAgICBzYXZlZFNjcm9sbFBvc2l0aW9ucyA9IEpTT04ucGFyc2Uoc2Vzc2lvblBvc2l0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gbm8tb3AsIHVzZSBkZWZhdWx0IGVtcHR5IG9iamVjdFxuICAgICAgfVxuICAgIH0sIFtzdG9yYWdlS2V5XSk7XG5cbiAgICAvLyBFbmFibGUgc2Nyb2xsIHJlc3RvcmF0aW9uIGluIHRoZSByb3V0ZXJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgbGV0IGdldEtleVdpdGhvdXRCYXNlbmFtZTogR2V0U2Nyb2xsUmVzdG9yYXRpb25LZXlGdW5jdGlvbiB8IHVuZGVmaW5lZCA9XG4gICAgICAgIGdldEtleSAmJiBiYXNlbmFtZSAhPT0gXCIvXCJcbiAgICAgICAgICA/IChsb2NhdGlvbiwgbWF0Y2hlcykgPT5cbiAgICAgICAgICAgICAgZ2V0S2V5KFxuICAgICAgICAgICAgICAgIC8vIFN0cmlwIHRoZSBiYXNlbmFtZSB0byBtYXRjaCB1c2VMb2NhdGlvbigpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgLi4ubG9jYXRpb24sXG4gICAgICAgICAgICAgICAgICBwYXRobmFtZTpcbiAgICAgICAgICAgICAgICAgICAgc3RyaXBCYXNlbmFtZShsb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbWF0Y2hlc1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgOiBnZXRLZXk7XG4gICAgICBsZXQgZGlzYWJsZVNjcm9sbFJlc3RvcmF0aW9uID0gcm91dGVyPy5lbmFibGVTY3JvbGxSZXN0b3JhdGlvbihcbiAgICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnMsXG4gICAgICAgICgpID0+IHdpbmRvdy5zY3JvbGxZLFxuICAgICAgICBnZXRLZXlXaXRob3V0QmFzZW5hbWVcbiAgICAgICk7XG4gICAgICByZXR1cm4gKCkgPT4gZGlzYWJsZVNjcm9sbFJlc3RvcmF0aW9uICYmIGRpc2FibGVTY3JvbGxSZXN0b3JhdGlvbigpO1xuICAgIH0sIFtyb3V0ZXIsIGJhc2VuYW1lLCBnZXRLZXldKTtcblxuICAgIC8vIFJlc3RvcmUgc2Nyb2xsaW5nIHdoZW4gc3RhdGUucmVzdG9yZVNjcm9sbFBvc2l0aW9uIGNoYW5nZXNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgLy8gRXhwbGljaXQgZmFsc2UgbWVhbnMgZG9uJ3QgZG8gYW55dGhpbmcgKHVzZWQgZm9yIHN1Ym1pc3Npb25zKVxuICAgICAgaWYgKHJlc3RvcmVTY3JvbGxQb3NpdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBiZWVuIGhlcmUgYmVmb3JlLCBzY3JvbGwgdG8gaXRcbiAgICAgIGlmICh0eXBlb2YgcmVzdG9yZVNjcm9sbFBvc2l0aW9uID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCByZXN0b3JlU2Nyb2xsUG9zaXRpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHRyeSB0byBzY3JvbGwgdG8gdGhlIGhhc2hcbiAgICAgIGlmIChsb2NhdGlvbi5oYXNoKSB7XG4gICAgICAgIGxldCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxuICAgICAgICAgIGRlY29kZVVSSUNvbXBvbmVudChsb2NhdGlvbi5oYXNoLnNsaWNlKDEpKVxuICAgICAgICApO1xuICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICBlbC5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBEb24ndCByZXNldCBpZiB0aGlzIG5hdmlnYXRpb24gb3B0ZWQgb3V0XG4gICAgICBpZiAocHJldmVudFNjcm9sbFJlc2V0ID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gb3RoZXJ3aXNlIGdvIHRvIHRoZSB0b3Agb24gbmV3IGxvY2F0aW9uc1xuICAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApO1xuICAgIH0sIFtsb2NhdGlvbiwgcmVzdG9yZVNjcm9sbFBvc2l0aW9uLCBwcmV2ZW50U2Nyb2xsUmVzZXRdKTtcbiAgfVxufVxuXG5leHBvcnQgeyB1c2VTY3JvbGxSZXN0b3JhdGlvbiBhcyBVTlNBRkVfdXNlU2Nyb2xsUmVzdG9yYXRpb24gfTtcblxuLyoqXG4gKiBTZXR1cCBhIGNhbGxiYWNrIHRvIGJlIGZpcmVkIG9uIHRoZSB3aW5kb3cncyBgYmVmb3JldW5sb2FkYCBldmVudC4gVGhpcyBpc1xuICogdXNlZnVsIGZvciBzYXZpbmcgc29tZSBkYXRhIHRvIGB3aW5kb3cubG9jYWxTdG9yYWdlYCBqdXN0IGJlZm9yZSB0aGUgcGFnZVxuICogcmVmcmVzaGVzLlxuICpcbiAqIE5vdGU6IFRoZSBgY2FsbGJhY2tgIGFyZ3VtZW50IHNob3VsZCBiZSBhIGZ1bmN0aW9uIGNyZWF0ZWQgd2l0aFxuICogYFJlYWN0LnVzZUNhbGxiYWNrKClgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQmVmb3JlVW5sb2FkKFxuICBjYWxsYmFjazogKGV2ZW50OiBCZWZvcmVVbmxvYWRFdmVudCkgPT4gYW55LFxuICBvcHRpb25zPzogeyBjYXB0dXJlPzogYm9vbGVhbiB9XG4pOiB2b2lkIHtcbiAgbGV0IHsgY2FwdHVyZSB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgb3B0cyA9IGNhcHR1cmUgIT0gbnVsbCA/IHsgY2FwdHVyZSB9IDogdW5kZWZpbmVkO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIGNhbGxiYWNrLCBvcHRzKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgY2FsbGJhY2ssIG9wdHMpO1xuICAgIH07XG4gIH0sIFtjYWxsYmFjaywgY2FwdHVyZV0pO1xufVxuXG4vKipcbiAqIFNldHVwIGEgY2FsbGJhY2sgdG8gYmUgZmlyZWQgb24gdGhlIHdpbmRvdydzIGBwYWdlaGlkZWAgZXZlbnQuIFRoaXMgaXNcbiAqIHVzZWZ1bCBmb3Igc2F2aW5nIHNvbWUgZGF0YSB0byBgd2luZG93LmxvY2FsU3RvcmFnZWAganVzdCBiZWZvcmUgdGhlIHBhZ2VcbiAqIHJlZnJlc2hlcy4gIFRoaXMgZXZlbnQgaXMgYmV0dGVyIHN1cHBvcnRlZCB0aGFuIGJlZm9yZXVubG9hZCBhY3Jvc3MgYnJvd3NlcnMuXG4gKlxuICogTm90ZTogVGhlIGBjYWxsYmFja2AgYXJndW1lbnQgc2hvdWxkIGJlIGEgZnVuY3Rpb24gY3JlYXRlZCB3aXRoXG4gKiBgUmVhY3QudXNlQ2FsbGJhY2soKWAuXG4gKi9cbmZ1bmN0aW9uIHVzZVBhZ2VIaWRlKFxuICBjYWxsYmFjazogKGV2ZW50OiBQYWdlVHJhbnNpdGlvbkV2ZW50KSA9PiBhbnksXG4gIG9wdGlvbnM/OiB7IGNhcHR1cmU/OiBib29sZWFuIH1cbik6IHZvaWQge1xuICBsZXQgeyBjYXB0dXJlIH0gPSBvcHRpb25zIHx8IHt9O1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBvcHRzID0gY2FwdHVyZSAhPSBudWxsID8geyBjYXB0dXJlIH0gOiB1bmRlZmluZWQ7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgY2FsbGJhY2ssIG9wdHMpO1xuICAgIH07XG4gIH0sIFtjYWxsYmFjaywgY2FwdHVyZV0pO1xufVxuXG4vKipcbiAqIFdyYXBwZXIgYXJvdW5kIHVzZUJsb2NrZXIgdG8gc2hvdyBhIHdpbmRvdy5jb25maXJtIHByb21wdCB0byB1c2VycyBpbnN0ZWFkXG4gKiBvZiBidWlsZGluZyBhIGN1c3RvbSBVSSB3aXRoIHVzZUJsb2NrZXIuXG4gKlxuICogV2FybmluZzogVGhpcyBoYXMgKmEgbG90IG9mIHJvdWdoIGVkZ2VzKiBhbmQgYmVoYXZlcyB2ZXJ5IGRpZmZlcmVudGx5IChhbmRcbiAqIHZlcnkgaW5jb3JyZWN0bHkgaW4gc29tZSBjYXNlcykgYWNyb3NzIGJyb3dzZXJzIGlmIHVzZXIgY2xpY2sgYWRkaXRpb25cbiAqIGJhY2svZm9yd2FyZCBuYXZpZ2F0aW9ucyB3aGlsZSB0aGUgY29uZmlybSBpcyBvcGVuLiAgVXNlIGF0IHlvdXIgb3duIHJpc2suXG4gKi9cbmZ1bmN0aW9uIHVzZVByb21wdCh7XG4gIHdoZW4sXG4gIG1lc3NhZ2UsXG59OiB7XG4gIHdoZW46IGJvb2xlYW4gfCBCbG9ja2VyRnVuY3Rpb247XG4gIG1lc3NhZ2U6IHN0cmluZztcbn0pIHtcbiAgbGV0IGJsb2NrZXIgPSB1c2VCbG9ja2VyKHdoZW4pO1xuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiKSB7XG4gICAgICBsZXQgcHJvY2VlZCA9IHdpbmRvdy5jb25maXJtKG1lc3NhZ2UpO1xuICAgICAgaWYgKHByb2NlZWQpIHtcbiAgICAgICAgLy8gVGhpcyB0aW1lb3V0IGlzIG5lZWRlZCB0byBhdm9pZCBhIHdlaXJkIFwicmFjZVwiIG9uIFBPUCBuYXZpZ2F0aW9uc1xuICAgICAgICAvLyBiZXR3ZWVuIHRoZSBgd2luZG93Lmhpc3RvcnlgIHJldmVydCBuYXZpZ2F0aW9uIGFuZCB0aGUgcmVzdWx0IG9mXG4gICAgICAgIC8vIGB3aW5kb3cuY29uZmlybWBcbiAgICAgICAgc2V0VGltZW91dChibG9ja2VyLnByb2NlZWQsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmxvY2tlci5yZXNldCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2Jsb2NrZXIsIG1lc3NhZ2VdKTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChibG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIiAmJiAhd2hlbikge1xuICAgICAgYmxvY2tlci5yZXNldCgpO1xuICAgIH1cbiAgfSwgW2Jsb2NrZXIsIHdoZW5dKTtcbn1cblxuZXhwb3J0IHsgdXNlUHJvbXB0IGFzIHVuc3RhYmxlX3VzZVByb21wdCB9O1xuXG4vKipcbiAqIFJldHVybiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGVyZSBpcyBhbiBhY3RpdmUgdmlldyB0cmFuc2l0aW9uIHRvIHRoZVxuICogZ2l2ZW4gaHJlZi4gIFlvdSBjYW4gdXNlIHRoaXMgdmFsdWUgdG8gcmVuZGVyIENTUyBjbGFzc2VzIG9yIHZpZXdUcmFuc2l0aW9uTmFtZVxuICogc3R5bGVzIG9udG8geW91ciBlbGVtZW50c1xuICpcbiAqIEBwYXJhbSBocmVmIFRoZSBkZXN0aW5hdGlvbiBocmVmXG4gKiBAcGFyYW0gW29wdHMucmVsYXRpdmVdIFJlbGF0aXZlIHJvdXRpbmcgdHlwZSAoXCJyb3V0ZVwiIHwgXCJwYXRoXCIpXG4gKi9cbmZ1bmN0aW9uIHVzZVZpZXdUcmFuc2l0aW9uU3RhdGUoXG4gIHRvOiBUbyxcbiAgb3B0czogeyByZWxhdGl2ZT86IFJlbGF0aXZlUm91dGluZ1R5cGUgfSA9IHt9XG4pIHtcbiAgbGV0IHZ0Q29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoVmlld1RyYW5zaXRpb25Db250ZXh0KTtcblxuICBpbnZhcmlhbnQoXG4gICAgdnRDb250ZXh0ICE9IG51bGwsXG4gICAgXCJgdW5zdGFibGVfdXNlVmlld1RyYW5zaXRpb25TdGF0ZWAgbXVzdCBiZSB1c2VkIHdpdGhpbiBgcmVhY3Qtcm91dGVyLWRvbWAncyBgUm91dGVyUHJvdmlkZXJgLiAgXCIgK1xuICAgICAgXCJEaWQgeW91IGFjY2lkZW50YWxseSBpbXBvcnQgYFJvdXRlclByb3ZpZGVyYCBmcm9tIGByZWFjdC1yb3V0ZXJgP1wiXG4gICk7XG5cbiAgbGV0IHsgYmFzZW5hbWUgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KFxuICAgIERhdGFSb3V0ZXJIb29rLnVzZVZpZXdUcmFuc2l0aW9uU3RhdGVcbiAgKTtcbiAgbGV0IHBhdGggPSB1c2VSZXNvbHZlZFBhdGgodG8sIHsgcmVsYXRpdmU6IG9wdHMucmVsYXRpdmUgfSk7XG4gIGlmICghdnRDb250ZXh0LmlzVHJhbnNpdGlvbmluZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGxldCBjdXJyZW50UGF0aCA9XG4gICAgc3RyaXBCYXNlbmFtZSh2dENvbnRleHQuY3VycmVudExvY2F0aW9uLnBhdGhuYW1lLCBiYXNlbmFtZSkgfHxcbiAgICB2dENvbnRleHQuY3VycmVudExvY2F0aW9uLnBhdGhuYW1lO1xuICBsZXQgbmV4dFBhdGggPVxuICAgIHN0cmlwQmFzZW5hbWUodnRDb250ZXh0Lm5leHRMb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8XG4gICAgdnRDb250ZXh0Lm5leHRMb2NhdGlvbi5wYXRobmFtZTtcblxuICAvLyBUcmFuc2l0aW9uIGlzIGFjdGl2ZSBpZiB3ZSdyZSBnb2luZyB0byBvciBjb21pbmcgZnJvbSB0aGUgaW5kaWNhdGVkXG4gIC8vIGRlc3RpbmF0aW9uLiAgVGhpcyBlbnN1cmVzIHRoYXQgb3RoZXIgUFVTSCBuYXZpZ2F0aW9ucyB0aGF0IHJldmVyc2VcbiAgLy8gYW4gaW5kaWNhdGVkIHRyYW5zaXRpb24gYXBwbHkuICBJLmUuLCBvbiB0aGUgbGlzdCB2aWV3IHlvdSBoYXZlOlxuICAvL1xuICAvLyAgIDxOYXZMaW5rIHRvPVwiL2RldGFpbHMvMVwiIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uPlxuICAvL1xuICAvLyBJZiB5b3UgY2xpY2sgdGhlIGJyZWFkY3J1bWIgYmFjayB0byB0aGUgbGlzdCB2aWV3OlxuICAvL1xuICAvLyAgIDxOYXZMaW5rIHRvPVwiL2xpc3RcIiB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbj5cbiAgLy9cbiAgLy8gV2Ugc2hvdWxkIGFwcGx5IHRoZSB0cmFuc2l0aW9uIGJlY2F1c2UgaXQncyBpbmRpY2F0ZWQgYXMgYWN0aXZlIGdvaW5nXG4gIC8vIGZyb20gL2xpc3QgLT4gL2RldGFpbHMvMSBhbmQgdGhlcmVmb3JlIHNob3VsZCBiZSBhY3RpdmUgb24gdGhlIHJldmVyc2VcbiAgLy8gKGV2ZW4gdGhvdWdoIHRoaXMgaXNuJ3Qgc3RyaWN0bHkgYSBQT1AgcmV2ZXJzZSlcbiAgcmV0dXJuIChcbiAgICBtYXRjaFBhdGgocGF0aC5wYXRobmFtZSwgbmV4dFBhdGgpICE9IG51bGwgfHxcbiAgICBtYXRjaFBhdGgocGF0aC5wYXRobmFtZSwgY3VycmVudFBhdGgpICE9IG51bGxcbiAgKTtcbn1cblxuZXhwb3J0IHsgdXNlVmlld1RyYW5zaXRpb25TdGF0ZSBhcyB1bnN0YWJsZV91c2VWaWV3VHJhbnNpdGlvblN0YXRlIH07XG5cbi8vI2VuZHJlZ2lvblxuIl0sIm5hbWVzIjpbImRlZmF1bHRNZXRob2QiLCJkZWZhdWx0RW5jVHlwZSIsImlzSHRtbEVsZW1lbnQiLCJvYmplY3QiLCJ0YWdOYW1lIiwiaXNCdXR0b25FbGVtZW50IiwidG9Mb3dlckNhc2UiLCJpc0Zvcm1FbGVtZW50IiwiaXNJbnB1dEVsZW1lbnQiLCJpc01vZGlmaWVkRXZlbnQiLCJldmVudCIsIm1ldGFLZXkiLCJhbHRLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJzaG91bGRQcm9jZXNzTGlua0NsaWNrIiwidGFyZ2V0IiwiYnV0dG9uIiwiY3JlYXRlU2VhcmNoUGFyYW1zIiwiaW5pdCIsIlVSTFNlYXJjaFBhcmFtcyIsIkFycmF5IiwiaXNBcnJheSIsIk9iamVjdCIsImtleXMiLCJyZWR1Y2UiLCJtZW1vIiwia2V5IiwidmFsdWUiLCJjb25jYXQiLCJtYXAiLCJ2IiwiZ2V0U2VhcmNoUGFyYW1zRm9yTG9jYXRpb24iLCJsb2NhdGlvblNlYXJjaCIsImRlZmF1bHRTZWFyY2hQYXJhbXMiLCJzZWFyY2hQYXJhbXMiLCJmb3JFYWNoIiwiXyIsImhhcyIsImdldEFsbCIsImFwcGVuZCIsIl9mb3JtRGF0YVN1cHBvcnRzU3VibWl0dGVyIiwiaXNGb3JtRGF0YVN1Ym1pdHRlclN1cHBvcnRlZCIsIkZvcm1EYXRhIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiZSIsInN1cHBvcnRlZEZvcm1FbmNUeXBlcyIsIlNldCIsImdldEZvcm1FbmNUeXBlIiwiZW5jVHlwZSIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIlVOU0FGRV93YXJuaW5nIiwiZ2V0Rm9ybVN1Ym1pc3Npb25JbmZvIiwiYmFzZW5hbWUiLCJtZXRob2QiLCJhY3Rpb24iLCJmb3JtRGF0YSIsImJvZHkiLCJhdHRyIiwiZ2V0QXR0cmlidXRlIiwic3RyaXBCYXNlbmFtZSIsInR5cGUiLCJmb3JtIiwiRXJyb3IiLCJuYW1lIiwicHJlZml4IiwidW5kZWZpbmVkIiwiY3JlYXRlQnJvd3NlclJvdXRlciIsInJvdXRlcyIsIm9wdHMiLCJjcmVhdGVSb3V0ZXIiLCJmdXR1cmUiLCJfZXh0ZW5kcyIsInY3X3ByZXBlbmRCYXNlbmFtZSIsImhpc3RvcnkiLCJjcmVhdGVCcm93c2VySGlzdG9yeSIsIndpbmRvdyIsImh5ZHJhdGlvbkRhdGEiLCJwYXJzZUh5ZHJhdGlvbkRhdGEiLCJVTlNBRkVfbWFwUm91dGVQcm9wZXJ0aWVzIiwiaW5pdGlhbGl6ZSIsImNyZWF0ZUhhc2hSb3V0ZXIiLCJjcmVhdGVIYXNoSGlzdG9yeSIsIl93aW5kb3ciLCJzdGF0ZSIsIl9fc3RhdGljUm91dGVySHlkcmF0aW9uRGF0YSIsImVycm9ycyIsImRlc2VyaWFsaXplRXJyb3JzIiwiZW50cmllcyIsInNlcmlhbGl6ZWQiLCJfaSIsIl9lbnRyaWVzIiwibGVuZ3RoIiwiX2VudHJpZXMkX2kiLCJfc2xpY2VkVG9BcnJheSIsInZhbCIsIl9fdHlwZSIsIlVOU0FGRV9FcnJvclJlc3BvbnNlSW1wbCIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJkYXRhIiwiaW50ZXJuYWwiLCJfX3N1YlR5cGUiLCJFcnJvckNvbnN0cnVjdG9yIiwiZXJyb3IiLCJtZXNzYWdlIiwic3RhY2siLCJWaWV3VHJhbnNpdGlvbkNvbnRleHQiLCJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJpc1RyYW5zaXRpb25pbmciLCJkaXNwbGF5TmFtZSIsIkZldGNoZXJzQ29udGV4dCIsIk1hcCIsIlNUQVJUX1RSQU5TSVRJT04iLCJzdGFydFRyYW5zaXRpb25JbXBsIiwiRkxVU0hfU1lOQyIsImZsdXNoU3luY0ltcGwiLCJSZWFjdERPTSIsInN0YXJ0VHJhbnNpdGlvblNhZmUiLCJjYiIsImZsdXNoU3luY1NhZmUiLCJEZWZlcnJlZCIsIl9jcmVhdGVDbGFzcyIsIl90aGlzIiwiX2NsYXNzQ2FsbENoZWNrIiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicmVhc29uIiwiUm91dGVyUHJvdmlkZXIiLCJfcmVmIiwiZmFsbGJhY2tFbGVtZW50Iiwicm91dGVyIiwiX1JlYWN0JHVzZVN0YXRlIiwidXNlU3RhdGUiLCJfUmVhY3QkdXNlU3RhdGUyIiwic2V0U3RhdGVJbXBsIiwiX1JlYWN0JHVzZVN0YXRlMyIsIl9SZWFjdCR1c2VTdGF0ZTQiLCJwZW5kaW5nU3RhdGUiLCJzZXRQZW5kaW5nU3RhdGUiLCJfUmVhY3QkdXNlU3RhdGU1IiwiX1JlYWN0JHVzZVN0YXRlNiIsInZ0Q29udGV4dCIsInNldFZ0Q29udGV4dCIsIl9SZWFjdCR1c2VTdGF0ZTciLCJfUmVhY3QkdXNlU3RhdGU4IiwicmVuZGVyRGZkIiwic2V0UmVuZGVyRGZkIiwiX1JlYWN0JHVzZVN0YXRlOSIsIl9SZWFjdCR1c2VTdGF0ZTEwIiwidHJhbnNpdGlvbiIsInNldFRyYW5zaXRpb24iLCJfUmVhY3QkdXNlU3RhdGUxMSIsIl9SZWFjdCR1c2VTdGF0ZTEyIiwiaW50ZXJydXB0aW9uIiwic2V0SW50ZXJydXB0aW9uIiwiZmV0Y2hlckRhdGEiLCJ1c2VSZWYiLCJfcmVmMTMiLCJ2N19zdGFydFRyYW5zaXRpb24iLCJvcHRJblN0YXJ0VHJhbnNpdGlvbiIsInVzZUNhbGxiYWNrIiwic2V0U3RhdGUiLCJuZXdTdGF0ZSIsIl9yZWYyIiwiZGVsZXRlZEZldGNoZXJzIiwiZmx1c2hTeW5jIiwidW5zdGFibGVfZmx1c2hTeW5jIiwidmlld1RyYW5zaXRpb25PcHRzIiwidW5zdGFibGVfdmlld1RyYW5zaXRpb25PcHRzIiwiY3VycmVudCIsImZldGNoZXJzIiwiZmV0Y2hlciIsInNldCIsImlzVmlld1RyYW5zaXRpb25VbmF2YWlsYWJsZSIsInN0YXJ0Vmlld1RyYW5zaXRpb24iLCJza2lwVHJhbnNpdGlvbiIsImN1cnJlbnRMb2NhdGlvbiIsIm5leHRMb2NhdGlvbiIsInQiLCJmaW5pc2hlZCIsInVzZUxheW91dEVmZmVjdCIsInN1YnNjcmliZSIsInVzZUVmZmVjdCIsInJlbmRlclByb21pc2UiLCJfYXN5bmNUb0dlbmVyYXRvciIsIl9yZWdlbmVyYXRvclJ1bnRpbWUiLCJtYXJrIiwiX2NhbGxlZSIsIndyYXAiLCJfY2FsbGVlJCIsIl9jb250ZXh0IiwicHJldiIsIm5leHQiLCJzdG9wIiwibG9jYXRpb24iLCJuYXZpZ2F0b3IiLCJ1c2VNZW1vIiwiY3JlYXRlSHJlZiIsImVuY29kZUxvY2F0aW9uIiwiZ28iLCJuIiwibmF2aWdhdGUiLCJwdXNoIiwidG8iLCJwcmV2ZW50U2Nyb2xsUmVzZXQiLCJyZXBsYWNlIiwiZGF0YVJvdXRlckNvbnRleHQiLCJGcmFnbWVudCIsIlVOU0FGRV9EYXRhUm91dGVyQ29udGV4dCIsIlByb3ZpZGVyIiwiVU5TQUZFX0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQiLCJSb3V0ZXIiLCJuYXZpZ2F0aW9uVHlwZSIsImhpc3RvcnlBY3Rpb24iLCJpbml0aWFsaXplZCIsIkRhdGFSb3V0ZXMiLCJfcmVmMyIsIlVOU0FGRV91c2VSb3V0ZXNJbXBsIiwiQnJvd3NlclJvdXRlciIsIl9yZWY0IiwiY2hpbGRyZW4iLCJoaXN0b3J5UmVmIiwidjVDb21wYXQiLCJfUmVhY3QkdXNlU3RhdGUxMyIsIl9SZWFjdCR1c2VTdGF0ZTE0IiwiX3JlZjE1IiwibGlzdGVuIiwiSGFzaFJvdXRlciIsIl9yZWY1IiwiX1JlYWN0JHVzZVN0YXRlMTUiLCJfUmVhY3QkdXNlU3RhdGUxNiIsIl9yZWYxNiIsIkhpc3RvcnlSb3V0ZXIiLCJfcmVmNiIsIl9SZWFjdCR1c2VTdGF0ZTE3IiwiX1JlYWN0JHVzZVN0YXRlMTgiLCJfcmVmMTciLCJpc0Jyb3dzZXIiLCJBQlNPTFVURV9VUkxfUkVHRVgiLCJMaW5rIiwiZm9yd2FyZFJlZiIsIkxpbmtXaXRoUmVmIiwiX3JlZjciLCJyZWYiLCJvbkNsaWNrIiwicmVsYXRpdmUiLCJyZWxvYWREb2N1bWVudCIsInVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uIiwicmVzdCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwiX2V4Y2x1ZGVkIiwiX1JlYWN0JHVzZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwiVU5TQUZFX05hdmlnYXRpb25Db250ZXh0IiwiYWJzb2x1dGVIcmVmIiwiaXNFeHRlcm5hbCIsInRlc3QiLCJjdXJyZW50VXJsIiwiVVJMIiwiaHJlZiIsInRhcmdldFVybCIsInN0YXJ0c1dpdGgiLCJwcm90b2NvbCIsInBhdGgiLCJwYXRobmFtZSIsIm9yaWdpbiIsInNlYXJjaCIsImhhc2giLCJ1c2VIcmVmIiwiaW50ZXJuYWxPbkNsaWNrIiwidXNlTGlua0NsaWNrSGFuZGxlciIsImhhbmRsZUNsaWNrIiwiZGVmYXVsdFByZXZlbnRlZCIsIk5hdkxpbmsiLCJOYXZMaW5rV2l0aFJlZiIsIl9yZWY4IiwiX3JlZjgkYXJpYUN1cnJlbnQiLCJhcmlhQ3VycmVudFByb3AiLCJfcmVmOCRjYXNlU2Vuc2l0aXZlIiwiY2FzZVNlbnNpdGl2ZSIsIl9yZWY4JGNsYXNzTmFtZSIsImNsYXNzTmFtZSIsImNsYXNzTmFtZVByb3AiLCJfcmVmOCRlbmQiLCJlbmQiLCJzdHlsZVByb3AiLCJzdHlsZSIsIl9leGNsdWRlZDIiLCJ1c2VSZXNvbHZlZFBhdGgiLCJ1c2VMb2NhdGlvbiIsInJvdXRlclN0YXRlIiwiX1JlYWN0JHVzZUNvbnRleHQyIiwidXNlVmlld1RyYW5zaXRpb25TdGF0ZSIsInRvUGF0aG5hbWUiLCJsb2NhdGlvblBhdGhuYW1lIiwibmV4dExvY2F0aW9uUGF0aG5hbWUiLCJuYXZpZ2F0aW9uIiwiZW5kU2xhc2hQb3NpdGlvbiIsImVuZHNXaXRoIiwiaXNBY3RpdmUiLCJjaGFyQXQiLCJpc1BlbmRpbmciLCJyZW5kZXJQcm9wcyIsImFyaWFDdXJyZW50IiwiZmlsdGVyIiwiQm9vbGVhbiIsImpvaW4iLCJGb3JtIiwiX3JlZjkiLCJmb3J3YXJkZWRSZWYiLCJmZXRjaGVyS2V5IiwiX3JlZjkkbWV0aG9kIiwib25TdWJtaXQiLCJwcm9wcyIsIl9leGNsdWRlZDMiLCJzdWJtaXQiLCJ1c2VTdWJtaXQiLCJmb3JtQWN0aW9uIiwidXNlRm9ybUFjdGlvbiIsImZvcm1NZXRob2QiLCJzdWJtaXRIYW5kbGVyIiwicHJldmVudERlZmF1bHQiLCJzdWJtaXR0ZXIiLCJuYXRpdmVFdmVudCIsInN1Ym1pdE1ldGhvZCIsImN1cnJlbnRUYXJnZXQiLCJTY3JvbGxSZXN0b3JhdGlvbiIsIl9yZWYxMCIsImdldEtleSIsInN0b3JhZ2VLZXkiLCJ1c2VTY3JvbGxSZXN0b3JhdGlvbiIsIkRhdGFSb3V0ZXJIb29rIiwiRGF0YVJvdXRlclN0YXRlSG9vayIsImdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IiLCJob29rTmFtZSIsInVzZURhdGFSb3V0ZXJDb250ZXh0IiwiY3R4IiwiVU5TQUZFX2ludmFyaWFudCIsInVzZURhdGFSb3V0ZXJTdGF0ZSIsIl90ZW1wIiwiX3JlZjE4IiwicmVwbGFjZVByb3AiLCJ1c2VOYXZpZ2F0ZSIsImNyZWF0ZVBhdGgiLCJ1c2VTZWFyY2hQYXJhbXMiLCJkZWZhdWx0SW5pdCIsImRlZmF1bHRTZWFyY2hQYXJhbXNSZWYiLCJoYXNTZXRTZWFyY2hQYXJhbXNSZWYiLCJzZXRTZWFyY2hQYXJhbXMiLCJuZXh0SW5pdCIsIm5hdmlnYXRlT3B0aW9ucyIsIm5ld1NlYXJjaFBhcmFtcyIsInZhbGlkYXRlQ2xpZW50U2lkZVN1Ym1pc3Npb24iLCJmZXRjaGVySWQiLCJnZXRVbmlxdWVGZXRjaGVySWQiLCJTdHJpbmciLCJfdXNlRGF0YVJvdXRlckNvbnRleHQiLCJVc2VTdWJtaXQiLCJfUmVhY3QkdXNlQ29udGV4dDMiLCJjdXJyZW50Um91dGVJZCIsIlVOU0FGRV91c2VSb3V0ZUlkIiwib3B0aW9ucyIsIl9nZXRGb3JtU3VibWlzc2lvbkluZiIsImZldGNoIiwiZm9ybUVuY1R5cGUiLCJmcm9tUm91dGVJZCIsIl90ZW1wMiIsIl9yZWYxOSIsIl9SZWFjdCR1c2VDb250ZXh0NCIsInJvdXRlQ29udGV4dCIsIlVOU0FGRV9Sb3V0ZUNvbnRleHQiLCJfcm91dGVDb250ZXh0JG1hdGNoZXMiLCJtYXRjaGVzIiwic2xpY2UiLCJfcm91dGVDb250ZXh0JG1hdGNoZXMyIiwibWF0Y2giLCJwYXJhbXMiLCJnZXQiLCJ0b1N0cmluZyIsInJvdXRlIiwiaW5kZXgiLCJqb2luUGF0aHMiLCJ1c2VGZXRjaGVyIiwiX3RlbXAzIiwiX3JvdXRlJG1hdGNoZXMiLCJfcmVmMjAiLCJfdXNlRGF0YVJvdXRlckNvbnRleHQyIiwiVXNlRmV0Y2hlciIsInJvdXRlSWQiLCJpZCIsIl9SZWFjdCR1c2VTdGF0ZTE5IiwiX1JlYWN0JHVzZVN0YXRlMjAiLCJzZXRGZXRjaGVyS2V5IiwiZ2V0RmV0Y2hlciIsImRlbGV0ZUZldGNoZXIiLCJsb2FkIiwic3VibWl0SW1wbCIsIkZldGNoZXJGb3JtIiwiSURMRV9GRVRDSEVSIiwiZmV0Y2hlcldpdGhDb21wb25lbnRzIiwidXNlRmV0Y2hlcnMiLCJVc2VGZXRjaGVycyIsImZyb20iLCJfcmVmMTEiLCJfcmVmMjEiLCJTQ1JPTExfUkVTVE9SQVRJT05fU1RPUkFHRV9LRVkiLCJzYXZlZFNjcm9sbFBvc2l0aW9ucyIsIl90ZW1wNCIsIl9yZWYyMiIsIl91c2VEYXRhUm91dGVyQ29udGV4dDMiLCJVc2VTY3JvbGxSZXN0b3JhdGlvbiIsIl91c2VEYXRhUm91dGVyU3RhdGUiLCJyZXN0b3JlU2Nyb2xsUG9zaXRpb24iLCJfUmVhY3QkdXNlQ29udGV4dDUiLCJ1c2VNYXRjaGVzIiwidXNlTmF2aWdhdGlvbiIsInNjcm9sbFJlc3RvcmF0aW9uIiwidXNlUGFnZUhpZGUiLCJzY3JvbGxZIiwic2Vzc2lvblN0b3JhZ2UiLCJzZXRJdGVtIiwiSlNPTiIsInN0cmluZ2lmeSIsInNlc3Npb25Qb3NpdGlvbnMiLCJnZXRJdGVtIiwicGFyc2UiLCJnZXRLZXlXaXRob3V0QmFzZW5hbWUiLCJkaXNhYmxlU2Nyb2xsUmVzdG9yYXRpb24iLCJlbmFibGVTY3JvbGxSZXN0b3JhdGlvbiIsInNjcm9sbFRvIiwiZWwiLCJnZXRFbGVtZW50QnlJZCIsImRlY29kZVVSSUNvbXBvbmVudCIsInNjcm9sbEludG9WaWV3IiwidXNlQmVmb3JlVW5sb2FkIiwiY2FsbGJhY2siLCJfcmVmMjMiLCJjYXB0dXJlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJfcmVmMjQiLCJ1c2VQcm9tcHQiLCJfcmVmMTIiLCJ3aGVuIiwiYmxvY2tlciIsInVzZUJsb2NrZXIiLCJwcm9jZWVkIiwiY29uZmlybSIsInNldFRpbWVvdXQiLCJyZXNldCIsIl91c2VEYXRhUm91dGVyQ29udGV4dDQiLCJjdXJyZW50UGF0aCIsIm5leHRQYXRoIiwibWF0Y2hQYXRoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///781\n')}}]);