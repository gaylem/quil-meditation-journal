"use strict";(self.webpackChunkquil=self.webpackChunkquil||[]).push([[766],{194:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AV: () => (/* binding */ json),\n/* harmony export */   Ep: () => (/* binding */ createPath),\n/* harmony export */   Gn: () => (/* binding */ generatePath),\n/* harmony export */   J0: () => (/* binding */ invariant),\n/* harmony export */   LX: () => (/* binding */ matchPath),\n/* harmony export */   OF: () => (/* binding */ ErrorResponseImpl),\n/* harmony export */   PP: () => (/* binding */ createMemoryHistory),\n/* harmony export */   PQ: () => (/* binding */ defer),\n/* harmony export */   RQ: () => (/* binding */ joinPaths),\n/* harmony export */   WK: () => (/* binding */ isRouteErrorResponse),\n/* harmony export */   WS: () => (/* binding */ convertRouteMatchToUiMatch),\n/* harmony export */   X3: () => (/* binding */ AbortedDeferredError),\n/* harmony export */   Zn: () => (/* binding */ stripBasename),\n/* harmony export */   Zq: () => (/* binding */ getPathContributingMatches),\n/* harmony export */   aU: () => (/* binding */ Action),\n/* harmony export */   cP: () => (/* binding */ parsePath),\n/* harmony export */   fZ: () => (/* binding */ redirectDocument),\n/* harmony export */   fp: () => (/* binding */ matchRoutes),\n/* harmony export */   i3: () => (/* binding */ resolvePath),\n/* harmony export */   lX: () => (/* binding */ createBrowserHistory),\n/* harmony export */   ov: () => (/* binding */ IDLE_FETCHER),\n/* harmony export */   p7: () => (/* binding */ createRouter),\n/* harmony export */   pC: () => (/* binding */ resolveTo),\n/* harmony export */   q_: () => (/* binding */ createHashHistory),\n/* harmony export */   qp: () => (/* binding */ IDLE_BLOCKER),\n/* harmony export */   uX: () => (/* binding */ redirect)\n/* harmony export */ });\n/* unused harmony exports IDLE_NAVIGATION, UNSAFE_DEFERRED_SYMBOL, UNSAFE_DeferredData, UNSAFE_convertRoutesToDataRoutes, UNSAFE_warning, createStaticHandler, getStaticContextFromError, getToPathname, isDeferredData, normalizePathname */\nfunction _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a \'" + n + "\' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _isNativeFunction(fn) { try { return Function.toString.call(fn).indexOf("[native code]") !== -1; } catch (e) { return typeof fn === "function"; } }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n/**\n * @remix-run/router v1.12.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Types and Constants\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Actions represent the type of change to a location value.\n */\nvar Action;\n(function (Action) {\n  /**\n   * A POP indicates a change to an arbitrary index in the history stack, such\n   * as a back or forward navigation. It does not describe the direction of the\n   * navigation, only that the current index changed.\n   *\n   * Note: This is the default action for newly created history objects.\n   */\n  Action["Pop"] = "POP";\n  /**\n   * A PUSH indicates a new entry being added to the history stack, such as when\n   * a link is clicked and a new page loads. When this happens, all subsequent\n   * entries in the stack are lost.\n   */\n  Action["Push"] = "PUSH";\n  /**\n   * A REPLACE indicates the entry at the current index in the history stack\n   * being replaced by a new one.\n   */\n  Action["Replace"] = "REPLACE";\n})(Action || (Action = {}));\nvar PopStateEventType = "popstate";\n/**\n * Memory history stores the current location in memory. It is designed for use\n * in stateful non-browser environments like tests and React Native.\n */\nfunction createMemoryHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var _options = options,\n    _options$initialEntri = _options.initialEntries,\n    initialEntries = _options$initialEntri === void 0 ? ["/"] : _options$initialEntri,\n    initialIndex = _options.initialIndex,\n    _options$v5Compat = _options.v5Compat,\n    v5Compat = _options$v5Compat === void 0 ? false : _options$v5Compat;\n  var entries; // Declare so we can access from createMemoryLocation\n  entries = initialEntries.map(function (entry, index) {\n    return createMemoryLocation(entry, typeof entry === "string" ? null : entry.state, index === 0 ? "default" : undefined);\n  });\n  var index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);\n  var action = Action.Pop;\n  var listener = null;\n  function clampIndex(n) {\n    return Math.min(Math.max(n, 0), entries.length - 1);\n  }\n  function getCurrentLocation() {\n    return entries[index];\n  }\n  function createMemoryLocation(to, state, key) {\n    if (state === void 0) {\n      state = null;\n    }\n    var location = createLocation(entries ? getCurrentLocation().pathname : "/", to, state, key);\n    warning(location.pathname.charAt(0) === "/", "relative pathnames are not supported in memory history: " + JSON.stringify(to));\n    return location;\n  }\n  function createHref(to) {\n    return typeof to === "string" ? to : createPath(to);\n  }\n  var history = {\n    get index() {\n      return index;\n    },\n    get action() {\n      return action;\n    },\n    get location() {\n      return getCurrentLocation();\n    },\n    createHref: createHref,\n    createURL: function createURL(to) {\n      return new URL(createHref(to), "http://localhost");\n    },\n    encodeLocation: function encodeLocation(to) {\n      var path = typeof to === "string" ? parsePath(to) : to;\n      return {\n        pathname: path.pathname || "",\n        search: path.search || "",\n        hash: path.hash || ""\n      };\n    },\n    push: function push(to, state) {\n      action = Action.Push;\n      var nextLocation = createMemoryLocation(to, state);\n      index += 1;\n      entries.splice(index, entries.length, nextLocation);\n      if (v5Compat && listener) {\n        listener({\n          action: action,\n          location: nextLocation,\n          delta: 1\n        });\n      }\n    },\n    replace: function replace(to, state) {\n      action = Action.Replace;\n      var nextLocation = createMemoryLocation(to, state);\n      entries[index] = nextLocation;\n      if (v5Compat && listener) {\n        listener({\n          action: action,\n          location: nextLocation,\n          delta: 0\n        });\n      }\n    },\n    go: function go(delta) {\n      action = Action.Pop;\n      var nextIndex = clampIndex(index + delta);\n      var nextLocation = entries[nextIndex];\n      index = nextIndex;\n      if (listener) {\n        listener({\n          action: action,\n          location: nextLocation,\n          delta: delta\n        });\n      }\n    },\n    listen: function listen(fn) {\n      listener = fn;\n      return function () {\n        listener = null;\n      };\n    }\n  };\n  return history;\n}\n/**\n * Browser history stores the location in regular URLs. This is the standard for\n * most web apps, but it requires some configuration on the server to ensure you\n * serve the same app at multiple URLs.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\n */\nfunction createBrowserHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  function createBrowserLocation(window, globalHistory) {\n    var _window$location = window.location,\n      pathname = _window$location.pathname,\n      search = _window$location.search,\n      hash = _window$location.hash;\n    return createLocation("", {\n      pathname: pathname,\n      search: search,\n      hash: hash\n    },\n    // state defaults to `null` because `window.history.state` does\n    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || "default");\n  }\n  function createBrowserHref(window, to) {\n    return typeof to === "string" ? to : createPath(to);\n  }\n  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);\n}\n/**\n * Hash history stores the location in window.location.hash. This makes it ideal\n * for situations where you don\'t want to send the location to the server for\n * some reason, either because you do cannot configure it or the URL space is\n * reserved for something else.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\n */\nfunction createHashHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  function createHashLocation(window, globalHistory) {\n    var _parsePath = parsePath(window.location.hash.substr(1)),\n      _parsePath$pathname = _parsePath.pathname,\n      pathname = _parsePath$pathname === void 0 ? "/" : _parsePath$pathname,\n      _parsePath$search = _parsePath.search,\n      search = _parsePath$search === void 0 ? "" : _parsePath$search,\n      _parsePath$hash = _parsePath.hash,\n      hash = _parsePath$hash === void 0 ? "" : _parsePath$hash;\n    // Hash URL should always have a leading / just like window.location.pathname\n    // does, so if an app ends up at a route like /#something then we add a\n    // leading slash so all of our path-matching behaves the same as if it would\n    // in a browser router.  This is particularly important when there exists a\n    // root splat route (<Route path="*">) since that matches internally against\n    // "/*" and we\'d expect /#something to 404 in a hash router app.\n    if (!pathname.startsWith("/") && !pathname.startsWith(".")) {\n      pathname = "/" + pathname;\n    }\n    return createLocation("", {\n      pathname: pathname,\n      search: search,\n      hash: hash\n    },\n    // state defaults to `null` because `window.history.state` does\n    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || "default");\n  }\n  function createHashHref(window, to) {\n    var base = window.document.querySelector("base");\n    var href = "";\n    if (base && base.getAttribute("href")) {\n      var url = window.location.href;\n      var hashIndex = url.indexOf("#");\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n    return href + "#" + (typeof to === "string" ? to : createPath(to));\n  }\n  function validateHashLocation(location, to) {\n    warning(location.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(to) + ")");\n  }\n  return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);\n}\nfunction invariant(value, message) {\n  if (value === false || value === null || typeof value === "undefined") {\n    throw new Error(message);\n  }\n}\nfunction warning(cond, message) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== "undefined") console.warn(message);\n    try {\n      // Welcome to debugging history!\n      //\n      // This error is thrown as a convenience, so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling "pause on exceptions" in your JavaScript debugger.\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\nfunction createKey() {\n  return Math.random().toString(36).substr(2, 8);\n}\n/**\n * For browser-based histories, we combine the state and key into an object\n */\nfunction getHistoryState(location, index) {\n  return {\n    usr: location.state,\n    key: location.key,\n    idx: index\n  };\n}\n/**\n * Creates a Location object with a unique key from the given Path\n */\nfunction createLocation(current, to, state, key) {\n  if (state === void 0) {\n    state = null;\n  }\n  var location = _extends({\n    pathname: typeof current === "string" ? current : current.pathname,\n    search: "",\n    hash: ""\n  }, typeof to === "string" ? parsePath(to) : to, {\n    state: state,\n    // TODO: This could be cleaned up.  push/replace should probably just take\n    // full Locations now and avoid the need to run through this flow at all\n    // But that\'s a pretty big refactor to the current test suite so going to\n    // keep as is for the time being and just let any incoming keys take precedence\n    key: to && to.key || key || createKey()\n  });\n  return location;\n}\n/**\n * Creates a string URL path from the given pathname, search, and hash components.\n */\nfunction createPath(_ref) {\n  var _ref$pathname = _ref.pathname,\n    pathname = _ref$pathname === void 0 ? "/" : _ref$pathname,\n    _ref$search = _ref.search,\n    search = _ref$search === void 0 ? "" : _ref$search,\n    _ref$hash = _ref.hash,\n    hash = _ref$hash === void 0 ? "" : _ref$hash;\n  if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;\n  if (hash && hash !== "#") pathname += hash.charAt(0) === "#" ? hash : "#" + hash;\n  return pathname;\n}\n/**\n * Parses a string URL path into its separate pathname, search, and hash components.\n */\nfunction parsePath(path) {\n  var parsedPath = {};\n  if (path) {\n    var hashIndex = path.indexOf("#");\n    if (hashIndex >= 0) {\n      parsedPath.hash = path.substr(hashIndex);\n      path = path.substr(0, hashIndex);\n    }\n    var searchIndex = path.indexOf("?");\n    if (searchIndex >= 0) {\n      parsedPath.search = path.substr(searchIndex);\n      path = path.substr(0, searchIndex);\n    }\n    if (path) {\n      parsedPath.pathname = path;\n    }\n  }\n  return parsedPath;\n}\nfunction getUrlBasedHistory(getLocation, _createHref, validateLocation, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var _options2 = options,\n    _options2$window = _options2.window,\n    window = _options2$window === void 0 ? document.defaultView : _options2$window,\n    _options2$v5Compat = _options2.v5Compat,\n    v5Compat = _options2$v5Compat === void 0 ? false : _options2$v5Compat;\n  var globalHistory = window.history;\n  var action = Action.Pop;\n  var listener = null;\n  var index = getIndex();\n  // Index should only be null when we initialize. If not, it\'s because the\n  // user called history.pushState or history.replaceState directly, in which\n  // case we should log a warning as it will result in bugs.\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\n      idx: index\n    }), "");\n  }\n  function getIndex() {\n    var state = globalHistory.state || {\n      idx: null\n    };\n    return state.idx;\n  }\n  function handlePop() {\n    action = Action.Pop;\n    var nextIndex = getIndex();\n    var delta = nextIndex == null ? null : nextIndex - index;\n    index = nextIndex;\n    if (listener) {\n      listener({\n        action: action,\n        location: history.location,\n        delta: delta\n      });\n    }\n  }\n  function push(to, state) {\n    action = Action.Push;\n    var location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n    index = getIndex() + 1;\n    var historyState = getHistoryState(location, index);\n    var url = history.createHref(location);\n    // try...catch because iOS limits us to 100 pushState calls :/\n    try {\n      globalHistory.pushState(historyState, "", url);\n    } catch (error) {\n      // If the exception is because `state` can\'t be serialized, let that throw\n      // outwards just like a replace call would so the dev knows the cause\n      // https://html.spec.whatwg.org/multipage/nav-history-apis.html#shared-history-push/replace-state-steps\n      // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal\n      if (error instanceof DOMException && error.name === "DataCloneError") {\n        throw error;\n      }\n      // They are going to lose state here, but there is no real\n      // way to warn them about it since the page will refresh...\n      window.location.assign(url);\n    }\n    if (v5Compat && listener) {\n      listener({\n        action: action,\n        location: history.location,\n        delta: 1\n      });\n    }\n  }\n  function replace(to, state) {\n    action = Action.Replace;\n    var location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n    index = getIndex();\n    var historyState = getHistoryState(location, index);\n    var url = history.createHref(location);\n    globalHistory.replaceState(historyState, "", url);\n    if (v5Compat && listener) {\n      listener({\n        action: action,\n        location: history.location,\n        delta: 0\n      });\n    }\n  }\n  function createURL(to) {\n    // window.location.origin is "null" (the literal string value) in Firefox\n    // under certain conditions, notably when serving from a local HTML file\n    // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297\n    var base = window.location.origin !== "null" ? window.location.origin : window.location.href;\n    var href = typeof to === "string" ? to : createPath(to);\n    invariant(base, "No window.location.(origin|href) available to create URL for href: " + href);\n    return new URL(href, base);\n  }\n  var history = {\n    get action() {\n      return action;\n    },\n    get location() {\n      return getLocation(window, globalHistory);\n    },\n    listen: function listen(fn) {\n      if (listener) {\n        throw new Error("A history only accepts one active listener");\n      }\n      window.addEventListener(PopStateEventType, handlePop);\n      listener = fn;\n      return function () {\n        window.removeEventListener(PopStateEventType, handlePop);\n        listener = null;\n      };\n    },\n    createHref: function createHref(to) {\n      return _createHref(window, to);\n    },\n    createURL: createURL,\n    encodeLocation: function encodeLocation(to) {\n      // Encode a Location the same way window.location would\n      var url = createURL(to);\n      return {\n        pathname: url.pathname,\n        search: url.search,\n        hash: url.hash\n      };\n    },\n    push: push,\n    replace: replace,\n    go: function go(n) {\n      return globalHistory.go(n);\n    }\n  };\n  return history;\n}\n//#endregion\n\nvar ResultType;\n(function (ResultType) {\n  ResultType["data"] = "data";\n  ResultType["deferred"] = "deferred";\n  ResultType["redirect"] = "redirect";\n  ResultType["error"] = "error";\n})(ResultType || (ResultType = {}));\nvar immutableRouteKeys = new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);\nfunction isIndexRoute(route) {\n  return route.index === true;\n}\n// Walk the route tree generating unique IDs where necessary, so we are working\n// solely with AgnosticDataRouteObject\'s within the Router\nfunction convertRoutesToDataRoutes(routes, mapRouteProperties, parentPath, manifest) {\n  if (parentPath === void 0) {\n    parentPath = [];\n  }\n  if (manifest === void 0) {\n    manifest = {};\n  }\n  return routes.map(function (route, index) {\n    var treePath = [].concat(_toConsumableArray(parentPath), [index]);\n    var id = typeof route.id === "string" ? route.id : treePath.join("-");\n    invariant(route.index !== true || !route.children, "Cannot specify children on an index route");\n    invariant(!manifest[id], "Found a route id collision on id \\"" + id + "\\".  Route " + "id\'s must be globally unique within Data Router usages");\n    if (isIndexRoute(route)) {\n      var indexRoute = _extends({}, route, mapRouteProperties(route), {\n        id: id\n      });\n      manifest[id] = indexRoute;\n      return indexRoute;\n    } else {\n      var pathOrLayoutRoute = _extends({}, route, mapRouteProperties(route), {\n        id: id,\n        children: undefined\n      });\n      manifest[id] = pathOrLayoutRoute;\n      if (route.children) {\n        pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties, treePath, manifest);\n      }\n      return pathOrLayoutRoute;\n    }\n  });\n}\n/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/utils/match-routes\n */\nfunction matchRoutes(routes, locationArg, basename) {\n  if (basename === void 0) {\n    basename = "/";\n  }\n  var location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;\n  var pathname = stripBasename(location.pathname || "/", basename);\n  if (pathname == null) {\n    return null;\n  }\n  var branches = flattenRoutes(routes);\n  rankRouteBranches(branches);\n  var matches = null;\n  for (var i = 0; matches == null && i < branches.length; ++i) {\n    matches = matchRouteBranch(branches[i],\n    // Incoming pathnames are generally encoded from either window.location\n    // or from router.navigate, but we want to match against the unencoded\n    // paths in the route definitions.  Memory router locations won\'t be\n    // encoded here but there also shouldn\'t be anything to decode so this\n    // should be a safe operation.  This avoids needing matchRoutes to be\n    // history-aware.\n    safelyDecodeURI(pathname));\n  }\n  return matches;\n}\nfunction convertRouteMatchToUiMatch(match, loaderData) {\n  var route = match.route,\n    pathname = match.pathname,\n    params = match.params;\n  return {\n    id: route.id,\n    pathname: pathname,\n    params: params,\n    data: loaderData[route.id],\n    handle: route.handle\n  };\n}\nfunction flattenRoutes(routes, branches, parentsMeta, parentPath) {\n  if (branches === void 0) {\n    branches = [];\n  }\n  if (parentsMeta === void 0) {\n    parentsMeta = [];\n  }\n  if (parentPath === void 0) {\n    parentPath = "";\n  }\n  var flattenRoute = function flattenRoute(route, index, relativePath) {\n    var meta = {\n      relativePath: relativePath === undefined ? route.path || "" : relativePath,\n      caseSensitive: route.caseSensitive === true,\n      childrenIndex: index,\n      route: route\n    };\n    if (meta.relativePath.startsWith("/")) {\n      invariant(meta.relativePath.startsWith(parentPath), "Absolute route path \\"" + meta.relativePath + "\\" nested under path " + ("\\"" + parentPath + "\\" is not valid. An absolute child route path ") + "must start with the combined path of all its parent routes.");\n      meta.relativePath = meta.relativePath.slice(parentPath.length);\n    }\n    var path = joinPaths([parentPath, meta.relativePath]);\n    var routesMeta = parentsMeta.concat(meta);\n    // Add the children before adding this route to the array, so we traverse the\n    // route tree depth-first and child routes appear before their parents in\n    // the "flattened" version.\n    if (route.children && route.children.length > 0) {\n      invariant(\n      // Our types know better, but runtime JS may not!\n      // @ts-expect-error\n      route.index !== true, "Index routes must not have child routes. Please remove " + ("all child routes from route path \\"" + path + "\\"."));\n      flattenRoutes(route.children, branches, routesMeta, path);\n    }\n    // Routes without a path shouldn\'t ever match by themselves unless they are\n    // index routes, so don\'t add them to the list of possible branches.\n    if (route.path == null && !route.index) {\n      return;\n    }\n    branches.push({\n      path: path,\n      score: computeScore(path, route.index),\n      routesMeta: routesMeta\n    });\n  };\n  routes.forEach(function (route, index) {\n    var _route$path;\n    // coarse-grain check for optional params\n    if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {\n      flattenRoute(route, index);\n    } else {\n      var _iterator = _createForOfIteratorHelper(explodeOptionalSegments(route.path)),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var exploded = _step.value;\n          flattenRoute(route, index, exploded);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  });\n  return branches;\n}\n/**\n * Computes all combinations of optional path segments for a given path,\n * excluding combinations that are ambiguous and of lower priority.\n *\n * For example, `/one/:two?/three/:four?/:five?` explodes to:\n * - `/one/three`\n * - `/one/:two/three`\n * - `/one/three/:four`\n * - `/one/three/:five`\n * - `/one/:two/three/:four`\n * - `/one/:two/three/:five`\n * - `/one/three/:four/:five`\n * - `/one/:two/three/:four/:five`\n */\nfunction explodeOptionalSegments(path) {\n  var segments = path.split("/");\n  if (segments.length === 0) return [];\n  var _segments = _toArray(segments),\n    first = _segments[0],\n    rest = _segments.slice(1);\n  // Optional path segments are denoted by a trailing `?`\n  var isOptional = first.endsWith("?");\n  // Compute the corresponding required segment: `foo?` -> `foo`\n  var required = first.replace(/\\?$/, "");\n  if (rest.length === 0) {\n    // Intepret empty string as omitting an optional segment\n    // `["one", "", "three"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`\n    return isOptional ? [required, ""] : [required];\n  }\n  var restExploded = explodeOptionalSegments(rest.join("/"));\n  var result = [];\n  // All child paths with the prefix.  Do this for all children before the\n  // optional version for all children, so we get consistent ordering where the\n  // parent optional aspect is preferred as required.  Otherwise, we can get\n  // child sections interspersed where deeper optional segments are higher than\n  // parent optional segments, where for example, /:two would explode _earlier_\n  // then /:one.  By always including the parent as required _for all children_\n  // first, we avoid this issue\n  result.push.apply(result, _toConsumableArray(restExploded.map(function (subpath) {\n    return subpath === "" ? required : [required, subpath].join("/");\n  })));\n  // Then, if this is an optional value, add all child versions without\n  if (isOptional) {\n    result.push.apply(result, _toConsumableArray(restExploded));\n  }\n  // for absolute paths, ensure `/` instead of empty segment\n  return result.map(function (exploded) {\n    return path.startsWith("/") && exploded === "" ? "/" : exploded;\n  });\n}\nfunction rankRouteBranches(branches) {\n  branches.sort(function (a, b) {\n    return a.score !== b.score ? b.score - a.score // Higher score first\n    : compareIndexes(a.routesMeta.map(function (meta) {\n      return meta.childrenIndex;\n    }), b.routesMeta.map(function (meta) {\n      return meta.childrenIndex;\n    }));\n  });\n}\nvar paramRe = /^:\\w+$/;\nvar dynamicSegmentValue = 3;\nvar indexRouteValue = 2;\nvar emptySegmentValue = 1;\nvar staticSegmentValue = 10;\nvar splatPenalty = -2;\nvar isSplat = function isSplat(s) {\n  return s === "*";\n};\nfunction computeScore(path, index) {\n  var segments = path.split("/");\n  var initialScore = segments.length;\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n  if (index) {\n    initialScore += indexRouteValue;\n  }\n  return segments.filter(function (s) {\n    return !isSplat(s);\n  }).reduce(function (score, segment) {\n    return score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue);\n  }, initialScore);\n}\nfunction compareIndexes(a, b) {\n  var siblings = a.length === b.length && a.slice(0, -1).every(function (n, i) {\n    return n === b[i];\n  });\n  return siblings ?\n  // If two routes are siblings, we should try to match the earlier sibling\n  // first. This allows people to have fine-grained control over the matching\n  // behavior by simply putting routes with identical paths in the order they\n  // want them tried.\n  a[a.length - 1] - b[b.length - 1] :\n  // Otherwise, it doesn\'t really make sense to rank non-siblings by index,\n  // so they sort equally.\n  0;\n}\nfunction matchRouteBranch(branch, pathname) {\n  var routesMeta = branch.routesMeta;\n  var matchedParams = {};\n  var matchedPathname = "/";\n  var matches = [];\n  for (var i = 0; i < routesMeta.length; ++i) {\n    var meta = routesMeta[i];\n    var end = i === routesMeta.length - 1;\n    var remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";\n    var match = matchPath({\n      path: meta.relativePath,\n      caseSensitive: meta.caseSensitive,\n      end: end\n    }, remainingPathname);\n    if (!match) return null;\n    Object.assign(matchedParams, match.params);\n    var route = meta.route;\n    matches.push({\n      // TODO: Can this as be avoided?\n      params: matchedParams,\n      pathname: joinPaths([matchedPathname, match.pathname]),\n      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),\n      route: route\n    });\n    if (match.pathnameBase !== "/") {\n      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);\n    }\n  }\n  return matches;\n}\n/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/utils/generate-path\n */\nfunction generatePath(originalPath, params) {\n  if (params === void 0) {\n    params = {};\n  }\n  var path = originalPath;\n  if (path.endsWith("*") && path !== "*" && !path.endsWith("/*")) {\n    warning(false, "Route path \\"" + path + "\\" will be treated as if it were " + ("\\"" + path.replace(/\\*$/, "/*") + "\\" because the `*` character must ") + "always follow a `/` in the pattern. To get rid of this warning, " + ("please change the route path to \\"" + path.replace(/\\*$/, "/*") + "\\"."));\n    path = path.replace(/\\*$/, "/*");\n  }\n  // ensure `/` is added at the beginning if the path is absolute\n  var prefix = path.startsWith("/") ? "/" : "";\n  var stringify = function stringify(p) {\n    return p == null ? "" : typeof p === "string" ? p : String(p);\n  };\n  var segments = path.split(/\\/+/).map(function (segment, index, array) {\n    var isLastSegment = index === array.length - 1;\n    // only apply the splat if it\'s the last segment\n    if (isLastSegment && segment === "*") {\n      var star = "*";\n      // Apply the splat\n      return stringify(params[star]);\n    }\n    var keyMatch = segment.match(/^:(\\w+)(\\??)$/);\n    if (keyMatch) {\n      var _keyMatch = _slicedToArray(keyMatch, 3),\n        key = _keyMatch[1],\n        optional = _keyMatch[2];\n      var param = params[key];\n      invariant(optional === "?" || param != null, "Missing \\":" + key + "\\" param");\n      return stringify(param);\n    }\n    // Remove any optional markers from optional static segments\n    return segment.replace(/\\?$/g, "");\n  })\n  // Remove empty segments\n  .filter(function (segment) {\n    return !!segment;\n  });\n  return prefix + segments.join("/");\n}\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/utils/match-path\n */\nfunction matchPath(pattern, pathname) {\n  if (typeof pattern === "string") {\n    pattern = {\n      path: pattern,\n      caseSensitive: false,\n      end: true\n    };\n  }\n  var _compilePath = compilePath(pattern.path, pattern.caseSensitive, pattern.end),\n    _compilePath2 = _slicedToArray(_compilePath, 2),\n    matcher = _compilePath2[0],\n    compiledParams = _compilePath2[1];\n  var match = pathname.match(matcher);\n  if (!match) return null;\n  var matchedPathname = match[0];\n  var pathnameBase = matchedPathname.replace(/(.)\\/+$/, "$1");\n  var captureGroups = match.slice(1);\n  var params = compiledParams.reduce(function (memo, _ref, index) {\n    var paramName = _ref.paramName,\n      isOptional = _ref.isOptional;\n    // We need to compute the pathnameBase here using the raw splat value\n    // instead of using params["*"] later because it will be decoded then\n    if (paramName === "*") {\n      var splatValue = captureGroups[index] || "";\n      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\\/+$/, "$1");\n    }\n    var value = captureGroups[index];\n    if (isOptional && !value) {\n      memo[paramName] = undefined;\n    } else {\n      memo[paramName] = safelyDecodeURIComponent(value || "", paramName);\n    }\n    return memo;\n  }, {});\n  return {\n    params: params,\n    pathname: matchedPathname,\n    pathnameBase: pathnameBase,\n    pattern: pattern\n  };\n}\nfunction compilePath(path, caseSensitive, end) {\n  if (caseSensitive === void 0) {\n    caseSensitive = false;\n  }\n  if (end === void 0) {\n    end = true;\n  }\n  warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), "Route path \\"" + path + "\\" will be treated as if it were " + ("\\"" + path.replace(/\\*$/, "/*") + "\\" because the `*` character must ") + "always follow a `/` in the pattern. To get rid of this warning, " + ("please change the route path to \\"" + path.replace(/\\*$/, "/*") + "\\"."));\n  var params = [];\n  var regexpSource = "^" + path.replace(/\\/*\\*?$/, "") // Ignore trailing / and /*, we\'ll handle it below\n  .replace(/^\\/*/, "/") // Make sure it has a leading /\n  .replace(/[\\\\.*+^${}|()[\\]]/g, "\\\\$&") // Escape special regex chars\n  .replace(/\\/:(\\w+)(\\?)?/g, function (_, paramName, isOptional) {\n    params.push({\n      paramName: paramName,\n      isOptional: isOptional != null\n    });\n    return isOptional ? "/?([^\\\\/]+)?" : "/([^\\\\/]+)";\n  });\n  if (path.endsWith("*")) {\n    params.push({\n      paramName: "*"\n    });\n    regexpSource += path === "*" || path === "/*" ? "(.*)$" // Already matched the initial /, just match the rest\n    : "(?:\\\\/(.+)|\\\\/*)$"; // Don\'t include the / in params["*"]\n  } else if (end) {\n    // When matching to the end, ignore trailing slashes\n    regexpSource += "\\\\/*$";\n  } else if (path !== "" && path !== "/") {\n    // If our path is non-empty and contains anything beyond an initial slash,\n    // then we have _some_ form of path in our regex, so we should expect to\n    // match only if we find the end of this path segment.  Look for an optional\n    // non-captured trailing slash (to match a portion of the URL) or the end\n    // of the path (if we\'ve matched to the end).  We used to do this with a\n    // word boundary but that gives false positives on routes like\n    // /user-preferences since `-` counts as a word boundary.\n    regexpSource += "(?:(?=\\\\/|$))";\n  } else ;\n  var matcher = new RegExp(regexpSource, caseSensitive ? undefined : "i");\n  return [matcher, params];\n}\nfunction safelyDecodeURI(value) {\n  try {\n    return decodeURI(value);\n  } catch (error) {\n    warning(false, "The URL path \\"" + value + "\\" could not be decoded because it is is a " + "malformed URL segment. This is probably due to a bad percent " + ("encoding (" + error + ")."));\n    return value;\n  }\n}\nfunction safelyDecodeURIComponent(value, paramName) {\n  try {\n    return decodeURIComponent(value);\n  } catch (error) {\n    warning(false, "The value for the URL param \\"" + paramName + "\\" will not be decoded because" + (" the string \\"" + value + "\\" is a malformed URL segment. This is probably") + (" due to a bad percent encoding (" + error + ")."));\n    return value;\n  }\n}\n/**\n * @private\n */\nfunction stripBasename(pathname, basename) {\n  if (basename === "/") return pathname;\n  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n    return null;\n  }\n  // We want to leave trailing slash behavior in the user\'s control, so if they\n  // specify a basename with a trailing slash, we should support it\n  var startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;\n  var nextChar = pathname.charAt(startIndex);\n  if (nextChar && nextChar !== "/") {\n    // pathname does not start with basename/\n    return null;\n  }\n  return pathname.slice(startIndex) || "/";\n}\n/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/utils/resolve-path\n */\nfunction resolvePath(to, fromPathname) {\n  if (fromPathname === void 0) {\n    fromPathname = "/";\n  }\n  var _ref4 = typeof to === "string" ? parsePath(to) : to,\n    toPathname = _ref4.pathname,\n    _ref4$search = _ref4.search,\n    search = _ref4$search === void 0 ? "" : _ref4$search,\n    _ref4$hash = _ref4.hash,\n    hash = _ref4$hash === void 0 ? "" : _ref4$hash;\n  var pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;\n  return {\n    pathname: pathname,\n    search: normalizeSearch(search),\n    hash: normalizeHash(hash)\n  };\n}\nfunction resolvePathname(relativePath, fromPathname) {\n  var segments = fromPathname.replace(/\\/+$/, "").split("/");\n  var relativeSegments = relativePath.split("/");\n  relativeSegments.forEach(function (segment) {\n    if (segment === "..") {\n      // Keep the root "" segment so the pathname starts at /\n      if (segments.length > 1) segments.pop();\n    } else if (segment !== ".") {\n      segments.push(segment);\n    }\n  });\n  return segments.length > 1 ? segments.join("/") : "/";\n}\nfunction getInvalidPathError(_char, field, dest, path) {\n  return "Cannot include a \'" + _char + "\' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + "a string in <Link to=\\"...\\"> and the router will parse it for you.";\n}\n/**\n * @private\n *\n * When processing relative navigation we want to ignore ancestor routes that\n * do not contribute to the path, such that index/pathless layout routes don\'t\n * interfere.\n *\n * For example, when moving a route element into an index route and/or a\n * pathless layout route, relative link behavior contained within should stay\n * the same.  Both of the following examples should link back to the root:\n *\n *   <Route path="/">\n *     <Route path="accounts" element={<Link to=".."}>\n *   </Route>\n *\n *   <Route path="/">\n *     <Route path="accounts">\n *       <Route element={<AccountsLayout />}>       // <-- Does not contribute\n *         <Route index element={<Link to=".."} />  // <-- Does not contribute\n *       </Route\n *     </Route>\n *   </Route>\n */\nfunction getPathContributingMatches(matches) {\n  return matches.filter(function (match, index) {\n    return index === 0 || match.route.path && match.route.path.length > 0;\n  });\n}\n/**\n * @private\n */\nfunction resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {\n  if (isPathRelative === void 0) {\n    isPathRelative = false;\n  }\n  var to;\n  if (typeof toArg === "string") {\n    to = parsePath(toArg);\n  } else {\n    to = _extends({}, toArg);\n    invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));\n    invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));\n    invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));\n  }\n  var isEmptyPath = toArg === "" || to.pathname === "";\n  var toPathname = isEmptyPath ? "/" : to.pathname;\n  var from;\n  // Routing is relative to the current pathname if explicitly requested.\n  //\n  // If a pathname is explicitly provided in `to`, it should be relative to the\n  // route context. This is explained in `Note on `<Link to>` values` in our\n  // migration guide from v5 as a means of disambiguation between `to` values\n  // that begin with `/` and those that do not. However, this is problematic for\n  // `to` values that do not provide a pathname. `to` can simply be a search or\n  // hash string, in which case we should assume that the navigation is relative\n  // to the current location\'s pathname and *not* the route pathname.\n  if (toPathname == null) {\n    from = locationPathname;\n  } else if (isPathRelative) {\n    var fromSegments = routePathnames[routePathnames.length - 1].replace(/^\\//, "").split("/");\n    if (toPathname.startsWith("..")) {\n      var toSegments = toPathname.split("/");\n      // With relative="path", each leading .. segment means "go up one URL segment"\n      while (toSegments[0] === "..") {\n        toSegments.shift();\n        fromSegments.pop();\n      }\n      to.pathname = toSegments.join("/");\n    }\n    from = "/" + fromSegments.join("/");\n  } else {\n    var routePathnameIndex = routePathnames.length - 1;\n    if (toPathname.startsWith("..")) {\n      var _toSegments = toPathname.split("/");\n      // With relative="route" (the default), each leading .. segment means\n      // "go up one route" instead of "go up one URL segment".  This is a key\n      // difference from how <a href> works and a major reason we call this a\n      // "to" value instead of a "href".\n      while (_toSegments[0] === "..") {\n        _toSegments.shift();\n        routePathnameIndex -= 1;\n      }\n      to.pathname = _toSegments.join("/");\n    }\n    // If there are more ".." segments than parent routes, resolve relative to\n    // the root / URL.\n    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";\n  }\n  var path = resolvePath(to, from);\n  // Ensure the pathname has a trailing slash if the original "to" had one\n  var hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");\n  // Or if this was a link to the current path which has a trailing slash\n  var hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");\n  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {\n    path.pathname += "/";\n  }\n  return path;\n}\n/**\n * @private\n */\nfunction getToPathname(to) {\n  // Empty strings should be treated the same as / paths\n  return to === "" || to.pathname === "" ? "/" : typeof to === "string" ? parsePath(to).pathname : to.pathname;\n}\n/**\n * @private\n */\nvar joinPaths = function joinPaths(paths) {\n  return paths.join("/").replace(/\\/\\/+/g, "/");\n};\n/**\n * @private\n */\nvar normalizePathname = function normalizePathname(pathname) {\n  return pathname.replace(/\\/+$/, "").replace(/^\\/*/, "/");\n};\n/**\n * @private\n */\nvar normalizeSearch = function normalizeSearch(search) {\n  return !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;\n};\n/**\n * @private\n */\nvar normalizeHash = function normalizeHash(hash) {\n  return !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;\n};\n/**\n * This is a shortcut for creating `application/json` responses. Converts `data`\n * to JSON and sets the `Content-Type` header.\n */\nvar json = function json(data, init) {\n  if (init === void 0) {\n    init = {};\n  }\n  var responseInit = typeof init === "number" ? {\n    status: init\n  } : init;\n  var headers = new Headers(responseInit.headers);\n  if (!headers.has("Content-Type")) {\n    headers.set("Content-Type", "application/json; charset=utf-8");\n  }\n  return new Response(JSON.stringify(data), _extends({}, responseInit, {\n    headers: headers\n  }));\n};\nvar AbortedDeferredError = /*#__PURE__*/function (_Error) {\n  _inherits(AbortedDeferredError, _Error);\n  var _super = _createSuper(AbortedDeferredError);\n  function AbortedDeferredError() {\n    _classCallCheck(this, AbortedDeferredError);\n    return _super.apply(this, arguments);\n  }\n  return _createClass(AbortedDeferredError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nvar DeferredData = /*#__PURE__*/function () {\n  function DeferredData(data, responseInit) {\n    var _this = this;\n    _classCallCheck(this, DeferredData);\n    this.pendingKeysSet = new Set();\n    this.subscribers = new Set();\n    this.deferredKeys = [];\n    invariant(data && _typeof(data) === "object" && !Array.isArray(data), "defer() only accepts plain objects");\n    // Set up an AbortController + Promise we can race against to exit early\n    // cancellation\n    var reject;\n    this.abortPromise = new Promise(function (_, r) {\n      return reject = r;\n    });\n    this.controller = new AbortController();\n    var onAbort = function onAbort() {\n      return reject(new AbortedDeferredError("Deferred data aborted"));\n    };\n    this.unlistenAbortSignal = function () {\n      return _this.controller.signal.removeEventListener("abort", onAbort);\n    };\n    this.controller.signal.addEventListener("abort", onAbort);\n    this.data = Object.entries(data).reduce(function (acc, _ref2) {\n      var _ref5 = _slicedToArray(_ref2, 2),\n        key = _ref5[0],\n        value = _ref5[1];\n      return Object.assign(acc, _defineProperty({}, key, _this.trackPromise(key, value)));\n    }, {});\n    if (this.done) {\n      // All incoming values were resolved\n      this.unlistenAbortSignal();\n    }\n    this.init = responseInit;\n  }\n  _createClass(DeferredData, [{\n    key: "trackPromise",\n    value: function trackPromise(key, value) {\n      var _this2 = this;\n      if (!(value instanceof Promise)) {\n        return value;\n      }\n      this.deferredKeys.push(key);\n      this.pendingKeysSet.add(key);\n      // We store a little wrapper promise that will be extended with\n      // _data/_error props upon resolve/reject\n      var promise = Promise.race([value, this.abortPromise]).then(function (data) {\n        return _this2.onSettle(promise, key, undefined, data);\n      }, function (error) {\n        return _this2.onSettle(promise, key, error);\n      });\n      // Register rejection listeners to avoid uncaught promise rejections on\n      // errors or aborted deferred values\n      promise["catch"](function () {});\n      Object.defineProperty(promise, "_tracked", {\n        get: function get() {\n          return true;\n        }\n      });\n      return promise;\n    }\n  }, {\n    key: "onSettle",\n    value: function onSettle(promise, key, error, data) {\n      if (this.controller.signal.aborted && error instanceof AbortedDeferredError) {\n        this.unlistenAbortSignal();\n        Object.defineProperty(promise, "_error", {\n          get: function get() {\n            return error;\n          }\n        });\n        return Promise.reject(error);\n      }\n      this.pendingKeysSet["delete"](key);\n      if (this.done) {\n        // Nothing left to abort!\n        this.unlistenAbortSignal();\n      }\n      // If the promise was resolved/rejected with undefined, we\'ll throw an error as you\n      // should always resolve with a value or null\n      if (error === undefined && data === undefined) {\n        var undefinedError = new Error("Deferred data for key \\"" + key + "\\" resolved/rejected with `undefined`, " + "you must resolve/reject with a value or `null`.");\n        Object.defineProperty(promise, "_error", {\n          get: function get() {\n            return undefinedError;\n          }\n        });\n        this.emit(false, key);\n        return Promise.reject(undefinedError);\n      }\n      if (data === undefined) {\n        Object.defineProperty(promise, "_error", {\n          get: function get() {\n            return error;\n          }\n        });\n        this.emit(false, key);\n        return Promise.reject(error);\n      }\n      Object.defineProperty(promise, "_data", {\n        get: function get() {\n          return data;\n        }\n      });\n      this.emit(false, key);\n      return data;\n    }\n  }, {\n    key: "emit",\n    value: function emit(aborted, settledKey) {\n      this.subscribers.forEach(function (subscriber) {\n        return subscriber(aborted, settledKey);\n      });\n    }\n  }, {\n    key: "subscribe",\n    value: function subscribe(fn) {\n      var _this3 = this;\n      this.subscribers.add(fn);\n      return function () {\n        return _this3.subscribers["delete"](fn);\n      };\n    }\n  }, {\n    key: "cancel",\n    value: function cancel() {\n      var _this4 = this;\n      this.controller.abort();\n      this.pendingKeysSet.forEach(function (v, k) {\n        return _this4.pendingKeysSet["delete"](k);\n      });\n      this.emit(true);\n    }\n  }, {\n    key: "resolveData",\n    value: function () {\n      var _resolveData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(signal) {\n        var _this5 = this;\n        var aborted, onAbort;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              aborted = false;\n              if (this.done) {\n                _context.next = 7;\n                break;\n              }\n              onAbort = function onAbort() {\n                return _this5.cancel();\n              };\n              signal.addEventListener("abort", onAbort);\n              _context.next = 6;\n              return new Promise(function (resolve) {\n                _this5.subscribe(function (aborted) {\n                  signal.removeEventListener("abort", onAbort);\n                  if (aborted || _this5.done) {\n                    resolve(aborted);\n                  }\n                });\n              });\n            case 6:\n              aborted = _context.sent;\n            case 7:\n              return _context.abrupt("return", aborted);\n            case 8:\n            case "end":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function resolveData(_x) {\n        return _resolveData.apply(this, arguments);\n      }\n      return resolveData;\n    }()\n  }, {\n    key: "done",\n    get: function get() {\n      return this.pendingKeysSet.size === 0;\n    }\n  }, {\n    key: "unwrappedData",\n    get: function get() {\n      invariant(this.data !== null && this.done, "Can only unwrap data on initialized and settled deferreds");\n      return Object.entries(this.data).reduce(function (acc, _ref3) {\n        var _ref6 = _slicedToArray(_ref3, 2),\n          key = _ref6[0],\n          value = _ref6[1];\n        return Object.assign(acc, _defineProperty({}, key, unwrapTrackedPromise(value)));\n      }, {});\n    }\n  }, {\n    key: "pendingKeys",\n    get: function get() {\n      return Array.from(this.pendingKeysSet);\n    }\n  }]);\n  return DeferredData;\n}();\nfunction isTrackedPromise(value) {\n  return value instanceof Promise && value._tracked === true;\n}\nfunction unwrapTrackedPromise(value) {\n  if (!isTrackedPromise(value)) {\n    return value;\n  }\n  if (value._error) {\n    throw value._error;\n  }\n  return value._data;\n}\nvar defer = function defer(data, init) {\n  if (init === void 0) {\n    init = {};\n  }\n  var responseInit = typeof init === "number" ? {\n    status: init\n  } : init;\n  return new DeferredData(data, responseInit);\n};\n/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to "302 Found".\n */\nvar redirect = function redirect(url, init) {\n  if (init === void 0) {\n    init = 302;\n  }\n  var responseInit = init;\n  if (typeof responseInit === "number") {\n    responseInit = {\n      status: responseInit\n    };\n  } else if (typeof responseInit.status === "undefined") {\n    responseInit.status = 302;\n  }\n  var headers = new Headers(responseInit.headers);\n  headers.set("Location", url);\n  return new Response(null, _extends({}, responseInit, {\n    headers: headers\n  }));\n};\n/**\n * A redirect response that will force a document reload to the new location.\n * Sets the status code and the `Location` header.\n * Defaults to "302 Found".\n */\nvar redirectDocument = function redirectDocument(url, init) {\n  var response = redirect(url, init);\n  response.headers.set("X-Remix-Reload-Document", "true");\n  return response;\n};\n/**\n * @private\n * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies\n *\n * We don\'t export the class for public use since it\'s an implementation\n * detail, but we export the interface above so folks can build their own\n * abstractions around instances via isRouteErrorResponse()\n */\nvar ErrorResponseImpl = /*#__PURE__*/_createClass(function ErrorResponseImpl(status, statusText, data, internal) {\n  _classCallCheck(this, ErrorResponseImpl);\n  if (internal === void 0) {\n    internal = false;\n  }\n  this.status = status;\n  this.statusText = statusText || "";\n  this.internal = internal;\n  if (data instanceof Error) {\n    this.data = data.toString();\n    this.error = data;\n  } else {\n    this.data = data;\n  }\n});\n/**\n * Check if the given error is an ErrorResponse generated from a 4xx/5xx\n * Response thrown from an action/loader\n */\nfunction isRouteErrorResponse(error) {\n  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;\n}\nvar validMutationMethodsArr = ["post", "put", "patch", "delete"];\nvar validMutationMethods = new Set(validMutationMethodsArr);\nvar validRequestMethodsArr = ["get"].concat(validMutationMethodsArr);\nvar validRequestMethods = new Set(validRequestMethodsArr);\nvar redirectStatusCodes = new Set([301, 302, 303, 307, 308]);\nvar redirectPreserveMethodStatusCodes = new Set([307, 308]);\nvar IDLE_NAVIGATION = {\n  state: "idle",\n  location: undefined,\n  formMethod: undefined,\n  formAction: undefined,\n  formEncType: undefined,\n  formData: undefined,\n  json: undefined,\n  text: undefined\n};\nvar IDLE_FETCHER = {\n  state: "idle",\n  data: undefined,\n  formMethod: undefined,\n  formAction: undefined,\n  formEncType: undefined,\n  formData: undefined,\n  json: undefined,\n  text: undefined\n};\nvar IDLE_BLOCKER = {\n  state: "unblocked",\n  proceed: undefined,\n  reset: undefined,\n  location: undefined\n};\nvar ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nvar defaultMapRouteProperties = function defaultMapRouteProperties(route) {\n  return {\n    hasErrorBoundary: Boolean(route.hasErrorBoundary)\n  };\n};\nvar TRANSITIONS_STORAGE_KEY = "remix-router-transitions";\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createRouter\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Create a router and listen to history POP navigations\n */\nfunction createRouter(init) {\n  var routerWindow = init.window ? init.window : typeof window !== "undefined" ? window : undefined;\n  var isBrowser = typeof routerWindow !== "undefined" && typeof routerWindow.document !== "undefined" && typeof routerWindow.document.createElement !== "undefined";\n  var isServer = !isBrowser;\n  invariant(init.routes.length > 0, "You must provide a non-empty routes array to createRouter");\n  var mapRouteProperties;\n  if (init.mapRouteProperties) {\n    mapRouteProperties = init.mapRouteProperties;\n  } else if (init.detectErrorBoundary) {\n    // If they are still using the deprecated version, wrap it with the new API\n    var detectErrorBoundary = init.detectErrorBoundary;\n    mapRouteProperties = function mapRouteProperties(route) {\n      return {\n        hasErrorBoundary: detectErrorBoundary(route)\n      };\n    };\n  } else {\n    mapRouteProperties = defaultMapRouteProperties;\n  }\n  // Routes keyed by ID\n  var manifest = {};\n  // Routes in tree format for matching\n  var dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties, undefined, manifest);\n  var inFlightDataRoutes;\n  var basename = init.basename || "/";\n  // Config driven behavior flags\n  var future = _extends({\n    v7_fetcherPersist: false,\n    v7_normalizeFormMethod: false,\n    v7_prependBasename: false\n  }, init.future);\n  // Cleanup function for history\n  var unlistenHistory = null;\n  // Externally-provided functions to call on all state changes\n  var subscribers = new Set();\n  // Externally-provided object to hold scroll restoration locations during routing\n  var savedScrollPositions = null;\n  // Externally-provided function to get scroll restoration keys\n  var getScrollRestorationKey = null;\n  // Externally-provided function to get current scroll position\n  var getScrollPosition = null;\n  // One-time flag to control the initial hydration scroll restoration.  Because\n  // we don\'t get the saved positions from <ScrollRestoration /> until _after_\n  // the initial render, we need to manually trigger a separate updateState to\n  // send along the restoreScrollPosition\n  // Set to true if we have `hydrationData` since we assume we were SSR\'d and that\n  // SSR did the initial scroll restoration.\n  var initialScrollRestored = init.hydrationData != null;\n  var initialMatches = matchRoutes(dataRoutes, init.history.location, basename);\n  var initialErrors = null;\n  if (initialMatches == null) {\n    // If we do not match a user-provided-route, fall back to the root\n    // to allow the error boundary to take over\n    var error = getInternalRouterError(404, {\n      pathname: init.history.location.pathname\n    });\n    var _getShortCircuitMatch = getShortCircuitMatches(dataRoutes),\n      matches = _getShortCircuitMatch.matches,\n      route = _getShortCircuitMatch.route;\n    initialMatches = matches;\n    initialErrors = _defineProperty({}, route.id, error);\n  }\n  var initialized =\n  // All initialMatches need to be loaded before we\'re ready.  If we have lazy\n  // functions around still then we\'ll need to run them in initialize()\n  !initialMatches.some(function (m) {\n    return m.route.lazy;\n  }) && (\n  // And we have to either have no loaders or have been provided hydrationData\n  !initialMatches.some(function (m) {\n    return m.route.loader;\n  }) || init.hydrationData != null);\n  var router;\n  var state = {\n    historyAction: init.history.action,\n    location: init.history.location,\n    matches: initialMatches,\n    initialized: initialized,\n    navigation: IDLE_NAVIGATION,\n    // Don\'t restore on initial updateState() if we were SSR\'d\n    restoreScrollPosition: init.hydrationData != null ? false : null,\n    preventScrollReset: false,\n    revalidation: "idle",\n    loaderData: init.hydrationData && init.hydrationData.loaderData || {},\n    actionData: init.hydrationData && init.hydrationData.actionData || null,\n    errors: init.hydrationData && init.hydrationData.errors || initialErrors,\n    fetchers: new Map(),\n    blockers: new Map()\n  };\n  // -- Stateful internal variables to manage navigations --\n  // Current navigation in progress (to be committed in completeNavigation)\n  var pendingAction = Action.Pop;\n  // Should the current navigation prevent the scroll reset if scroll cannot\n  // be restored?\n  var pendingPreventScrollReset = false;\n  // AbortController for the active navigation\n  var pendingNavigationController;\n  // Should the current navigation enable document.startViewTransition?\n  var pendingViewTransitionEnabled = false;\n  // Store applied view transitions so we can apply them on POP\n  var appliedViewTransitions = new Map();\n  // Cleanup function for persisting applied transitions to sessionStorage\n  var removePageHideEventListener = null;\n  // We use this to avoid touching history in completeNavigation if a\n  // revalidation is entirely uninterrupted\n  var isUninterruptedRevalidation = false;\n  // Use this internal flag to force revalidation of all loaders:\n  //  - submissions (completed or interrupted)\n  //  - useRevalidator()\n  //  - X-Remix-Revalidate (from redirect)\n  var isRevalidationRequired = false;\n  // Use this internal array to capture routes that require revalidation due\n  // to a cancelled deferred on action submission\n  var cancelledDeferredRoutes = [];\n  // Use this internal array to capture fetcher loads that were cancelled by an\n  // action navigation and require revalidation\n  var cancelledFetcherLoads = [];\n  // AbortControllers for any in-flight fetchers\n  var fetchControllers = new Map();\n  // Track loads based on the order in which they started\n  var incrementingLoadId = 0;\n  // Track the outstanding pending navigation data load to be compared against\n  // the globally incrementing load when a fetcher load lands after a completed\n  // navigation\n  var pendingNavigationLoadId = -1;\n  // Fetchers that triggered data reloads as a result of their actions\n  var fetchReloadIds = new Map();\n  // Fetchers that triggered redirect navigations\n  var fetchRedirectIds = new Set();\n  // Most recent href/match for fetcher.load calls for fetchers\n  var fetchLoadMatches = new Map();\n  // Ref-count mounted fetchers so we know when it\'s ok to clean them up\n  var activeFetchers = new Map();\n  // Fetchers that have requested a delete when using v7_fetcherPersist,\n  // they\'ll be officially removed after they return to idle\n  var deletedFetchers = new Set();\n  // Store DeferredData instances for active route matches.  When a\n  // route loader returns defer() we stick one in here.  Then, when a nested\n  // promise resolves we update loaderData.  If a new navigation starts we\n  // cancel active deferreds for eliminated routes.\n  var activeDeferreds = new Map();\n  // Store blocker functions in a separate Map outside of router state since\n  // we don\'t need to update UI state if they change\n  var blockerFunctions = new Map();\n  // Flag to ignore the next history update, so we can revert the URL change on\n  // a POP navigation that was blocked by the user without touching router state\n  var ignoreNextHistoryUpdate = false;\n  // Initialize the router, all side effects should be kicked off from here.\n  // Implemented as a Fluent API for ease of:\n  //   let router = createRouter(init).initialize();\n  function initialize() {\n    // If history informs us of a POP navigation, start the navigation but do not update\n    // state.  We\'ll update our own state once the navigation completes\n    unlistenHistory = init.history.listen(function (_ref) {\n      var historyAction = _ref.action,\n        location = _ref.location,\n        delta = _ref.delta;\n      // Ignore this event if it was just us resetting the URL from a\n      // blocked POP navigation\n      if (ignoreNextHistoryUpdate) {\n        ignoreNextHistoryUpdate = false;\n        return;\n      }\n      warning(blockerFunctions.size === 0 || delta != null, "You are trying to use a blocker on a POP navigation to a location " + "that was not created by @remix-run/router. This will fail silently in " + "production. This can happen if you are navigating outside the router " + "via `window.history.pushState`/`window.location.hash` instead of using " + "router navigation APIs.  This can also happen if you are using " + "createHashRouter and the user manually changes the URL.");\n      var blockerKey = shouldBlockNavigation({\n        currentLocation: state.location,\n        nextLocation: location,\n        historyAction: historyAction\n      });\n      if (blockerKey && delta != null) {\n        // Restore the URL to match the current UI, but don\'t update router state\n        ignoreNextHistoryUpdate = true;\n        init.history.go(delta * -1);\n        // Put the blocker into a blocked state\n        updateBlocker(blockerKey, {\n          state: "blocked",\n          location: location,\n          proceed: function proceed() {\n            updateBlocker(blockerKey, {\n              state: "proceeding",\n              proceed: undefined,\n              reset: undefined,\n              location: location\n            });\n            // Re-do the same POP navigation we just blocked\n            init.history.go(delta);\n          },\n          reset: function reset() {\n            var blockers = new Map(state.blockers);\n            blockers.set(blockerKey, IDLE_BLOCKER);\n            updateState({\n              blockers: blockers\n            });\n          }\n        });\n        return;\n      }\n      return startNavigation(historyAction, location);\n    });\n    if (isBrowser) {\n      // FIXME: This feels gross.  How can we cleanup the lines between\n      // scrollRestoration/appliedTransitions persistance?\n      restoreAppliedTransitions(routerWindow, appliedViewTransitions);\n      var _saveAppliedTransitions = function _saveAppliedTransitions() {\n        return persistAppliedTransitions(routerWindow, appliedViewTransitions);\n      };\n      routerWindow.addEventListener("pagehide", _saveAppliedTransitions);\n      removePageHideEventListener = function removePageHideEventListener() {\n        return routerWindow.removeEventListener("pagehide", _saveAppliedTransitions);\n      };\n    }\n    // Kick off initial data load if needed.  Use Pop to avoid modifying history\n    // Note we don\'t do any handling of lazy here.  For SPA\'s it\'ll get handled\n    // in the normal navigation flow.  For SSR it\'s expected that lazy modules are\n    // resolved prior to router creation since we can\'t go into a fallbackElement\n    // UI for SSR\'d apps\n    if (!state.initialized) {\n      startNavigation(Action.Pop, state.location);\n    }\n    return router;\n  }\n  // Clean up a router and it\'s side effects\n  function dispose() {\n    if (unlistenHistory) {\n      unlistenHistory();\n    }\n    if (removePageHideEventListener) {\n      removePageHideEventListener();\n    }\n    subscribers.clear();\n    pendingNavigationController && pendingNavigationController.abort();\n    state.fetchers.forEach(function (_, key) {\n      return deleteFetcher(key);\n    });\n    state.blockers.forEach(function (_, key) {\n      return deleteBlocker(key);\n    });\n  }\n  // Subscribe to state updates for the router\n  function subscribe(fn) {\n    subscribers.add(fn);\n    return function () {\n      return subscribers["delete"](fn);\n    };\n  }\n  // Update our state and notify the calling context of the change\n  function updateState(newState, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    state = _extends({}, state, newState);\n    // Prep fetcher cleanup so we can tell the UI which fetcher data entries\n    // can be removed\n    var completedFetchers = [];\n    var deletedFetchersKeys = [];\n    if (future.v7_fetcherPersist) {\n      state.fetchers.forEach(function (fetcher, key) {\n        if (fetcher.state === "idle") {\n          if (deletedFetchers.has(key)) {\n            // Unmounted from the UI and can be totally removed\n            deletedFetchersKeys.push(key);\n          } else {\n            // Returned to idle but still mounted in the UI, so semi-remains for\n            // revalidations and such\n            completedFetchers.push(key);\n          }\n        }\n      });\n    }\n    // Iterate over a local copy so that if flushSync is used and we end up\n    // removing and adding a new subscriber due to the useCallback dependencies,\n    // we don\'t get ourselves into a loop calling the new subscriber immediately\n    _toConsumableArray(subscribers).forEach(function (subscriber) {\n      return subscriber(state, {\n        deletedFetchers: deletedFetchersKeys,\n        unstable_viewTransitionOpts: opts.viewTransitionOpts,\n        unstable_flushSync: opts.flushSync === true\n      });\n    });\n    // Remove idle fetchers from state since we only care about in-flight fetchers.\n    if (future.v7_fetcherPersist) {\n      completedFetchers.forEach(function (key) {\n        return state.fetchers["delete"](key);\n      });\n      deletedFetchersKeys.forEach(function (key) {\n        return deleteFetcher(key);\n      });\n    }\n  }\n  // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION\n  // and setting state.[historyAction/location/matches] to the new route.\n  // - Location is a required param\n  // - Navigation will always be set to IDLE_NAVIGATION\n  // - Can pass any other state in newState\n  function completeNavigation(location, newState, _temp) {\n    var _location$state, _location$state2;\n    var _ref7 = _temp === void 0 ? {} : _temp,\n      flushSync = _ref7.flushSync;\n    // Deduce if we\'re in a loading/actionReload state:\n    // - We have committed actionData in the store\n    // - The current navigation was a mutation submission\n    // - We\'re past the submitting state and into the loading state\n    // - The location being loaded is not the result of a redirect\n    var isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === "loading" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;\n    var actionData;\n    if (newState.actionData) {\n      if (Object.keys(newState.actionData).length > 0) {\n        actionData = newState.actionData;\n      } else {\n        // Empty actionData -> clear prior actionData due to an action error\n        actionData = null;\n      }\n    } else if (isActionReload) {\n      // Keep the current data if we\'re wrapping up the action reload\n      actionData = state.actionData;\n    } else {\n      // Clear actionData on any other completed navigations\n      actionData = null;\n    }\n    // Always preserve any existing loaderData from re-used routes\n    var loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;\n    // On a successful navigation we can assume we got through all blockers\n    // so we can start fresh\n    var blockers = state.blockers;\n    if (blockers.size > 0) {\n      blockers = new Map(blockers);\n      blockers.forEach(function (_, k) {\n        return blockers.set(k, IDLE_BLOCKER);\n      });\n    }\n    // Always respect the user flag.  Otherwise don\'t reset on mutation\n    // submission navigations unless they redirect\n    var preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;\n    if (inFlightDataRoutes) {\n      dataRoutes = inFlightDataRoutes;\n      inFlightDataRoutes = undefined;\n    }\n    if (isUninterruptedRevalidation) ;else if (pendingAction === Action.Pop) ;else if (pendingAction === Action.Push) {\n      init.history.push(location, location.state);\n    } else if (pendingAction === Action.Replace) {\n      init.history.replace(location, location.state);\n    }\n    var viewTransitionOpts;\n    // On POP, enable transitions if they were enabled on the original navigation\n    if (pendingAction === Action.Pop) {\n      // Forward takes precedence so they behave like the original navigation\n      var priorPaths = appliedViewTransitions.get(state.location.pathname);\n      if (priorPaths && priorPaths.has(location.pathname)) {\n        viewTransitionOpts = {\n          currentLocation: state.location,\n          nextLocation: location\n        };\n      } else if (appliedViewTransitions.has(location.pathname)) {\n        // If we don\'t have a previous forward nav, assume we\'re popping back to\n        // the new location and enable if that location previously enabled\n        viewTransitionOpts = {\n          currentLocation: location,\n          nextLocation: state.location\n        };\n      }\n    } else if (pendingViewTransitionEnabled) {\n      // Store the applied transition on PUSH/REPLACE\n      var toPaths = appliedViewTransitions.get(state.location.pathname);\n      if (toPaths) {\n        toPaths.add(location.pathname);\n      } else {\n        toPaths = new Set([location.pathname]);\n        appliedViewTransitions.set(state.location.pathname, toPaths);\n      }\n      viewTransitionOpts = {\n        currentLocation: state.location,\n        nextLocation: location\n      };\n    }\n    updateState(_extends({}, newState, {\n      actionData: actionData,\n      loaderData: loaderData,\n      historyAction: pendingAction,\n      location: location,\n      initialized: true,\n      navigation: IDLE_NAVIGATION,\n      revalidation: "idle",\n      restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),\n      preventScrollReset: preventScrollReset,\n      blockers: blockers\n    }), {\n      viewTransitionOpts: viewTransitionOpts,\n      flushSync: flushSync === true\n    });\n    // Reset stateful navigation vars\n    pendingAction = Action.Pop;\n    pendingPreventScrollReset = false;\n    pendingViewTransitionEnabled = false;\n    isUninterruptedRevalidation = false;\n    isRevalidationRequired = false;\n    cancelledDeferredRoutes = [];\n    cancelledFetcherLoads = [];\n  }\n  // Trigger a navigation event, which can either be a numerical POP or a PUSH\n  // replace with an optional submission\n  function navigate(_x2, _x3) {\n    return _navigate.apply(this, arguments);\n  } // Revalidate all current loaders.  If a navigation is in progress or if this\n  // is interrupted by a navigation, allow this to "succeed" by calling all\n  // loaders during the next loader round\n  function _navigate() {\n    _navigate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(to, opts) {\n      var normalizedPath, _normalizeNavigateOpt2, path, submission, error, currentLocation, nextLocation, userReplace, historyAction, preventScrollReset, flushSync, blockerKey;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            if (!(typeof to === "number")) {\n              _context2.next = 3;\n              break;\n            }\n            init.history.go(to);\n            return _context2.abrupt("return");\n          case 3:\n            normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, to, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative);\n            _normalizeNavigateOpt2 = normalizeNavigateOptions(future.v7_normalizeFormMethod, false, normalizedPath, opts), path = _normalizeNavigateOpt2.path, submission = _normalizeNavigateOpt2.submission, error = _normalizeNavigateOpt2.error;\n            currentLocation = state.location;\n            nextLocation = createLocation(state.location, path, opts && opts.state); // When using navigate as a PUSH/REPLACE we aren\'t reading an already-encoded\n            // URL from window.location, so we need to encode it here so the behavior\n            // remains the same as POP and non-data-router usages.  new URL() does all\n            // the same encoding we\'d get from a history.pushState/window.location read\n            // without having to touch history\n            nextLocation = _extends({}, nextLocation, init.history.encodeLocation(nextLocation));\n            userReplace = opts && opts.replace != null ? opts.replace : undefined;\n            historyAction = Action.Push;\n            if (userReplace === true) {\n              historyAction = Action.Replace;\n            } else if (userReplace === false) ;else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {\n              // By default on submissions to the current location we REPLACE so that\n              // users don\'t have to double-click the back button to get to the prior\n              // location.  If the user redirects to a different location from the\n              // action/loader this will be ignored and the redirect will be a PUSH\n              historyAction = Action.Replace;\n            }\n            preventScrollReset = opts && "preventScrollReset" in opts ? opts.preventScrollReset === true : undefined;\n            flushSync = (opts && opts.unstable_flushSync) === true;\n            blockerKey = shouldBlockNavigation({\n              currentLocation: currentLocation,\n              nextLocation: nextLocation,\n              historyAction: historyAction\n            });\n            if (!blockerKey) {\n              _context2.next = 17;\n              break;\n            }\n            // Put the blocker into a blocked state\n            updateBlocker(blockerKey, {\n              state: "blocked",\n              location: nextLocation,\n              proceed: function proceed() {\n                updateBlocker(blockerKey, {\n                  state: "proceeding",\n                  proceed: undefined,\n                  reset: undefined,\n                  location: nextLocation\n                });\n                // Send the same navigation through\n                navigate(to, opts);\n              },\n              reset: function reset() {\n                var blockers = new Map(state.blockers);\n                blockers.set(blockerKey, IDLE_BLOCKER);\n                updateState({\n                  blockers: blockers\n                });\n              }\n            });\n            return _context2.abrupt("return");\n          case 17:\n            _context2.next = 19;\n            return startNavigation(historyAction, nextLocation, {\n              submission: submission,\n              // Send through the formData serialization error if we have one so we can\n              // render at the right error boundary after we match routes\n              pendingError: error,\n              preventScrollReset: preventScrollReset,\n              replace: opts && opts.replace,\n              enableViewTransition: opts && opts.unstable_viewTransition,\n              flushSync: flushSync\n            });\n          case 19:\n            return _context2.abrupt("return", _context2.sent);\n          case 20:\n          case "end":\n            return _context2.stop();\n        }\n      }, _callee2);\n    }));\n    return _navigate.apply(this, arguments);\n  }\n  function revalidate() {\n    interruptActiveLoads();\n    updateState({\n      revalidation: "loading"\n    });\n    // If we\'re currently submitting an action, we don\'t need to start a new\n    // navigation, we\'ll just let the follow up loader execution call all loaders\n    if (state.navigation.state === "submitting") {\n      return;\n    }\n    // If we\'re currently in an idle state, start a new navigation for the current\n    // action/location and mark it as uninterrupted, which will skip the history\n    // update in completeNavigation\n    if (state.navigation.state === "idle") {\n      startNavigation(state.historyAction, state.location, {\n        startUninterruptedRevalidation: true\n      });\n      return;\n    }\n    // Otherwise, if we\'re currently in a loading state, just start a new\n    // navigation to the navigation.location but do not trigger an uninterrupted\n    // revalidation so that history correctly updates once the navigation completes\n    startNavigation(pendingAction || state.historyAction, state.navigation.location, {\n      overrideNavigation: state.navigation\n    });\n  }\n  // Start a navigation to the given action/location.  Can optionally provide a\n  // overrideNavigation which will override the normalLoad in the case of a redirect\n  // navigation\n  function startNavigation(_x4, _x5, _x6) {\n    return _startNavigation.apply(this, arguments);\n  } // Call the action matched by the leaf route for this navigation and handle\n  // redirects/errors\n  function _startNavigation() {\n    _startNavigation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(historyAction, location, opts) {\n      var routesToUse, loadingNavigation, matches, flushSync, _error, _getShortCircuitMatch2, notFoundMatches, _route, request, pendingActionData, pendingError, actionOutput, _yield$handleLoaders, shortCircuited, loaderData, errors;\n      return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            // Abort any in-progress navigations and start a new one. Unset any ongoing\n            // uninterrupted revalidations unless told otherwise, since we want this\n            // new navigation to update history normally\n            pendingNavigationController && pendingNavigationController.abort();\n            pendingNavigationController = null;\n            pendingAction = historyAction;\n            isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;\n            // Save the current scroll position every time we start a new navigation,\n            // and track whether we should reset scroll on completion\n            saveScrollPosition(state.location, state.matches);\n            pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n            pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;\n            routesToUse = inFlightDataRoutes || dataRoutes;\n            loadingNavigation = opts && opts.overrideNavigation;\n            matches = matchRoutes(routesToUse, location, basename);\n            flushSync = (opts && opts.flushSync) === true; // Short circuit with a 404 on the root error boundary if we match nothing\n            if (matches) {\n              _context3.next = 17;\n              break;\n            }\n            _error = getInternalRouterError(404, {\n              pathname: location.pathname\n            });\n            _getShortCircuitMatch2 = getShortCircuitMatches(routesToUse), notFoundMatches = _getShortCircuitMatch2.matches, _route = _getShortCircuitMatch2.route; // Cancel all pending deferred on 404s since we don\'t keep any routes\n            cancelActiveDeferreds();\n            completeNavigation(location, {\n              matches: notFoundMatches,\n              loaderData: {},\n              errors: _defineProperty({}, _route.id, _error)\n            }, {\n              flushSync: flushSync\n            });\n            return _context3.abrupt("return");\n          case 17:\n            if (!(state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod)))) {\n              _context3.next = 20;\n              break;\n            }\n            completeNavigation(location, {\n              matches: matches\n            }, {\n              flushSync: flushSync\n            });\n            return _context3.abrupt("return");\n          case 20:\n            // Create a controller/Request for this navigation\n            pendingNavigationController = new AbortController();\n            request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);\n            if (!(opts && opts.pendingError)) {\n              _context3.next = 26;\n              break;\n            }\n            // If we have a pendingError, it means the user attempted a GET submission\n            // with binary FormData so assign here and skip to handleLoaders.  That\n            // way we handle calling loaders above the boundary etc.  It\'s not really\n            // different from an actionError in that sense.\n            pendingError = _defineProperty({}, findNearestBoundary(matches).route.id, opts.pendingError);\n            _context3.next = 37;\n            break;\n          case 26:\n            if (!(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {\n              _context3.next = 37;\n              break;\n            }\n            _context3.next = 29;\n            return handleAction(request, location, opts.submission, matches, {\n              replace: opts.replace,\n              flushSync: flushSync\n            });\n          case 29:\n            actionOutput = _context3.sent;\n            if (!actionOutput.shortCircuited) {\n              _context3.next = 32;\n              break;\n            }\n            return _context3.abrupt("return");\n          case 32:\n            pendingActionData = actionOutput.pendingActionData;\n            pendingError = actionOutput.pendingActionError;\n            loadingNavigation = getLoadingNavigation(location, opts.submission);\n            flushSync = false;\n            // Create a GET request for the loaders\n            request = new Request(request.url, {\n              signal: request.signal\n            });\n          case 37:\n            _context3.next = 39;\n            return handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, flushSync, pendingActionData, pendingError);\n          case 39:\n            _yield$handleLoaders = _context3.sent;\n            shortCircuited = _yield$handleLoaders.shortCircuited;\n            loaderData = _yield$handleLoaders.loaderData;\n            errors = _yield$handleLoaders.errors;\n            if (!shortCircuited) {\n              _context3.next = 45;\n              break;\n            }\n            return _context3.abrupt("return");\n          case 45:\n            // Clean up now that the action/loaders have completed.  Don\'t clean up if\n            // we short circuited because pendingNavigationController will have already\n            // been assigned to a new controller for the next navigation\n            pendingNavigationController = null;\n            completeNavigation(location, _extends({\n              matches: matches\n            }, pendingActionData ? {\n              actionData: pendingActionData\n            } : {}, {\n              loaderData: loaderData,\n              errors: errors\n            }));\n          case 47:\n          case "end":\n            return _context3.stop();\n        }\n      }, _callee3);\n    }));\n    return _startNavigation.apply(this, arguments);\n  }\n  function handleAction(_x7, _x8, _x9, _x10, _x11) {\n    return _handleAction.apply(this, arguments);\n  } // Call all applicable loaders for the given matches, handling redirects,\n  // errors, etc.\n  function _handleAction() {\n    _handleAction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(request, location, submission, matches, opts) {\n      var navigation, result, actionMatch, replace, boundaryMatch;\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            if (opts === void 0) {\n              opts = {};\n            }\n            interruptActiveLoads();\n            // Put us in a submitting state\n            navigation = getSubmittingNavigation(location, submission);\n            updateState({\n              navigation: navigation\n            }, {\n              flushSync: opts.flushSync === true\n            });\n            // Call our action and get the result\n            actionMatch = getTargetMatch(matches, location);\n            if (!(!actionMatch.route.action && !actionMatch.route.lazy)) {\n              _context4.next = 9;\n              break;\n            }\n            result = {\n              type: ResultType.error,\n              error: getInternalRouterError(405, {\n                method: request.method,\n                pathname: location.pathname,\n                routeId: actionMatch.route.id\n              })\n            };\n            _context4.next = 14;\n            break;\n          case 9:\n            _context4.next = 11;\n            return callLoaderOrAction("action", request, actionMatch, matches, manifest, mapRouteProperties, basename);\n          case 11:\n            result = _context4.sent;\n            if (!request.signal.aborted) {\n              _context4.next = 14;\n              break;\n            }\n            return _context4.abrupt("return", {\n              shortCircuited: true\n            });\n          case 14:\n            if (!isRedirectResult(result)) {\n              _context4.next = 19;\n              break;\n            }\n            if (opts && opts.replace != null) {\n              replace = opts.replace;\n            } else {\n              // If the user didn\'t explicity indicate replace behavior, replace if\n              // we redirected to the exact same location we\'re currently at to avoid\n              // double back-buttons\n              replace = result.location === state.location.pathname + state.location.search;\n            }\n            _context4.next = 18;\n            return startRedirectNavigation(state, result, {\n              submission: submission,\n              replace: replace\n            });\n          case 18:\n            return _context4.abrupt("return", {\n              shortCircuited: true\n            });\n          case 19:\n            if (!isErrorResult(result)) {\n              _context4.next = 23;\n              break;\n            }\n            // Store off the pending error - we use it to determine which loaders\n            // to call and will commit it when we complete the navigation\n            boundaryMatch = findNearestBoundary(matches, actionMatch.route.id); // By default, all submissions are REPLACE navigations, but if the\n            // action threw an error that\'ll be rendered in an errorElement, we fall\n            // back to PUSH so that the user can use the back button to get back to\n            // the pre-submission form location to try again\n            if ((opts && opts.replace) !== true) {\n              pendingAction = Action.Push;\n            }\n            return _context4.abrupt("return", {\n              // Send back an empty object we can use to clear out any prior actionData\n              pendingActionData: {},\n              pendingActionError: _defineProperty({}, boundaryMatch.route.id, result.error)\n            });\n          case 23:\n            if (!isDeferredResult(result)) {\n              _context4.next = 25;\n              break;\n            }\n            throw getInternalRouterError(400, {\n              type: "defer-action"\n            });\n          case 25:\n            return _context4.abrupt("return", {\n              pendingActionData: _defineProperty({}, actionMatch.route.id, result.data)\n            });\n          case 26:\n          case "end":\n            return _context4.stop();\n        }\n      }, _callee4);\n    }));\n    return _handleAction.apply(this, arguments);\n  }\n  function handleLoaders(_x12, _x13, _x14, _x15, _x16, _x17, _x18, _x19, _x20, _x21) {\n    return _handleLoaders.apply(this, arguments);\n  } // Trigger a fetcher load/submit for the given fetcher key\n  function _handleLoaders() {\n    _handleLoaders = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(request, location, matches, overrideNavigation, submission, fetcherSubmission, replace, flushSync, pendingActionData, pendingError) {\n      var loadingNavigation, activeSubmission, routesToUse, _getMatchesToLoad, _getMatchesToLoad2, matchesToLoad, revalidatingFetchers, _updatedFetchers, actionData, abortPendingFetchRevalidations, _yield$callLoadersAnd, results, loaderResults, fetcherResults, redirect, fetcherKey, _processLoaderData, loaderData, errors, updatedFetchers, didAbortFetchLoads, shouldUpdateFetchers;\n      return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n        while (1) switch (_context5.prev = _context5.next) {\n          case 0:\n            // Figure out the right navigation we want to use for data loading\n            loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission); // If this was a redirect from an action we don\'t have a "submission" but\n            // we have it on the loading navigation so use that if available\n            activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);\n            routesToUse = inFlightDataRoutes || dataRoutes;\n            _getMatchesToLoad = getMatchesToLoad(init.history, state, matches, activeSubmission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError), _getMatchesToLoad2 = _slicedToArray(_getMatchesToLoad, 2), matchesToLoad = _getMatchesToLoad2[0], revalidatingFetchers = _getMatchesToLoad2[1]; // Cancel pending deferreds for no-longer-matched routes or routes we\'re\n            // about to reload.  Note that if this is an action reload we would have\n            // already cancelled all pending deferreds so this would be a no-op\n            cancelActiveDeferreds(function (routeId) {\n              return !(matches && matches.some(function (m) {\n                return m.route.id === routeId;\n              })) || matchesToLoad && matchesToLoad.some(function (m) {\n                return m.route.id === routeId;\n              });\n            });\n            pendingNavigationLoadId = ++incrementingLoadId;\n            // Short circuit if we have no loaders to run\n            if (!(matchesToLoad.length === 0 && revalidatingFetchers.length === 0)) {\n              _context5.next = 10;\n              break;\n            }\n            _updatedFetchers = markFetchRedirectsDone();\n            completeNavigation(location, _extends({\n              matches: matches,\n              loaderData: {},\n              // Commit pending error if we\'re short circuiting\n              errors: pendingError || null\n            }, pendingActionData ? {\n              actionData: pendingActionData\n            } : {}, _updatedFetchers ? {\n              fetchers: new Map(state.fetchers)\n            } : {}), {\n              flushSync: flushSync\n            });\n            return _context5.abrupt("return", {\n              shortCircuited: true\n            });\n          case 10:\n            // If this is an uninterrupted revalidation, we remain in our current idle\n            // state.  If not, we need to switch to our loading state and load data,\n            // preserving any new action data or existing action data (in the case of\n            // a revalidation interrupting an actionReload)\n            if (!isUninterruptedRevalidation) {\n              revalidatingFetchers.forEach(function (rf) {\n                var fetcher = state.fetchers.get(rf.key);\n                var revalidatingFetcher = getLoadingFetcher(undefined, fetcher ? fetcher.data : undefined);\n                state.fetchers.set(rf.key, revalidatingFetcher);\n              });\n              actionData = pendingActionData || state.actionData;\n              updateState(_extends({\n                navigation: loadingNavigation\n              }, actionData ? Object.keys(actionData).length === 0 ? {\n                actionData: null\n              } : {\n                actionData: actionData\n              } : {}, revalidatingFetchers.length > 0 ? {\n                fetchers: new Map(state.fetchers)\n              } : {}), {\n                flushSync: flushSync\n              });\n            }\n            revalidatingFetchers.forEach(function (rf) {\n              if (fetchControllers.has(rf.key)) {\n                abortFetcher(rf.key);\n              }\n              if (rf.controller) {\n                // Fetchers use an independent AbortController so that aborting a fetcher\n                // (via deleteFetcher) does not abort the triggering navigation that\n                // triggered the revalidation\n                fetchControllers.set(rf.key, rf.controller);\n              }\n            });\n            // Proxy navigation abort through to revalidation fetchers\n            abortPendingFetchRevalidations = function abortPendingFetchRevalidations() {\n              return revalidatingFetchers.forEach(function (f) {\n                return abortFetcher(f.key);\n              });\n            };\n            if (pendingNavigationController) {\n              pendingNavigationController.signal.addEventListener("abort", abortPendingFetchRevalidations);\n            }\n            _context5.next = 16;\n            return callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);\n          case 16:\n            _yield$callLoadersAnd = _context5.sent;\n            results = _yield$callLoadersAnd.results;\n            loaderResults = _yield$callLoadersAnd.loaderResults;\n            fetcherResults = _yield$callLoadersAnd.fetcherResults;\n            if (!request.signal.aborted) {\n              _context5.next = 22;\n              break;\n            }\n            return _context5.abrupt("return", {\n              shortCircuited: true\n            });\n          case 22:\n            // Clean up _after_ loaders have completed.  Don\'t clean up if we short\n            // circuited because fetchControllers would have been aborted and\n            // reassigned to new controllers for the next navigation\n            if (pendingNavigationController) {\n              pendingNavigationController.signal.removeEventListener("abort", abortPendingFetchRevalidations);\n            }\n            revalidatingFetchers.forEach(function (rf) {\n              return fetchControllers["delete"](rf.key);\n            });\n            // If any loaders returned a redirect Response, start a new REPLACE navigation\n            redirect = findRedirect(results);\n            if (!redirect) {\n              _context5.next = 30;\n              break;\n            }\n            if (redirect.idx >= matchesToLoad.length) {\n              // If this redirect came from a fetcher make sure we mark it in\n              // fetchRedirectIds so it doesn\'t get revalidated on the next set of\n              // loader executions\n              fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n              fetchRedirectIds.add(fetcherKey);\n            }\n            _context5.next = 29;\n            return startRedirectNavigation(state, redirect.result, {\n              replace: replace\n            });\n          case 29:\n            return _context5.abrupt("return", {\n              shortCircuited: true\n            });\n          case 30:\n            // Process and commit output from loaders\n            _processLoaderData = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds), loaderData = _processLoaderData.loaderData, errors = _processLoaderData.errors; // Wire up subscribers to update loaderData as promises settle\n            activeDeferreds.forEach(function (deferredData, routeId) {\n              deferredData.subscribe(function (aborted) {\n                // Note: No need to updateState here since the TrackedPromise on\n                // loaderData is stable across resolve/reject\n                // Remove this instance if we were aborted or if promises have settled\n                if (aborted || deferredData.done) {\n                  activeDeferreds["delete"](routeId);\n                }\n              });\n            });\n            updatedFetchers = markFetchRedirectsDone();\n            didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);\n            shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;\n            return _context5.abrupt("return", _extends({\n              loaderData: loaderData,\n              errors: errors\n            }, shouldUpdateFetchers ? {\n              fetchers: new Map(state.fetchers)\n            } : {}));\n          case 36:\n          case "end":\n            return _context5.stop();\n        }\n      }, _callee5);\n    }));\n    return _handleLoaders.apply(this, arguments);\n  }\n  function fetch(key, routeId, href, opts) {\n    if (isServer) {\n      throw new Error("router.fetch() was called during the server render, but it shouldn\'t be. " + "You are likely calling a useFetcher() method in the body of your component. " + "Try moving it to a useEffect or a callback.");\n    }\n    if (fetchControllers.has(key)) abortFetcher(key);\n    var flushSync = (opts && opts.unstable_flushSync) === true;\n    var routesToUse = inFlightDataRoutes || dataRoutes;\n    var normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, href, routeId, opts == null ? void 0 : opts.relative);\n    var matches = matchRoutes(routesToUse, normalizedPath, basename);\n    if (!matches) {\n      setFetcherError(key, routeId, getInternalRouterError(404, {\n        pathname: normalizedPath\n      }), {\n        flushSync: flushSync\n      });\n      return;\n    }\n    var _normalizeNavigateOpt = normalizeNavigateOptions(future.v7_normalizeFormMethod, true, normalizedPath, opts),\n      path = _normalizeNavigateOpt.path,\n      submission = _normalizeNavigateOpt.submission,\n      error = _normalizeNavigateOpt.error;\n    if (error) {\n      setFetcherError(key, routeId, error, {\n        flushSync: flushSync\n      });\n      return;\n    }\n    var match = getTargetMatch(matches, path);\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n    if (submission && isMutationMethod(submission.formMethod)) {\n      handleFetcherAction(key, routeId, path, match, matches, flushSync, submission);\n      return;\n    }\n    // Store off the match so we can call it\'s shouldRevalidate on subsequent\n    // revalidations\n    fetchLoadMatches.set(key, {\n      routeId: routeId,\n      path: path\n    });\n    handleFetcherLoader(key, routeId, path, match, matches, flushSync, submission);\n  }\n  // Call the action for the matched fetcher.submit(), and then handle redirects,\n  // errors, and revalidation\n  function handleFetcherAction(_x22, _x23, _x24, _x25, _x26, _x27, _x28) {\n    return _handleFetcherAction.apply(this, arguments);\n  } // Call the matched loader for fetcher.load(), handling redirects, errors, etc.\n  function _handleFetcherAction() {\n    _handleFetcherAction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(key, routeId, path, match, requestMatches, flushSync, submission) {\n      var _error2, existingFetcher, abortController, fetchRequest, originatingLoadId, actionResult, nextLocation, revalidationRequest, routesToUse, matches, loadId, loadFetcher, _getMatchesToLoad3, _getMatchesToLoad4, matchesToLoad, revalidatingFetchers, abortPendingFetchRevalidations, _yield$callLoadersAnd2, results, loaderResults, fetcherResults, redirect, fetcherKey, _processLoaderData2, loaderData, errors, doneFetcher;\n      return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n        while (1) switch (_context6.prev = _context6.next) {\n          case 0:\n            interruptActiveLoads();\n            fetchLoadMatches["delete"](key);\n            if (!(!match.route.action && !match.route.lazy)) {\n              _context6.next = 6;\n              break;\n            }\n            _error2 = getInternalRouterError(405, {\n              method: submission.formMethod,\n              pathname: path,\n              routeId: routeId\n            });\n            setFetcherError(key, routeId, _error2, {\n              flushSync: flushSync\n            });\n            return _context6.abrupt("return");\n          case 6:\n            // Put this fetcher into it\'s submitting state\n            existingFetcher = state.fetchers.get(key);\n            updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {\n              flushSync: flushSync\n            });\n            // Call the action for the fetcher\n            abortController = new AbortController();\n            fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);\n            fetchControllers.set(key, abortController);\n            originatingLoadId = incrementingLoadId;\n            _context6.next = 14;\n            return callLoaderOrAction("action", fetchRequest, match, requestMatches, manifest, mapRouteProperties, basename);\n          case 14:\n            actionResult = _context6.sent;\n            if (!fetchRequest.signal.aborted) {\n              _context6.next = 18;\n              break;\n            }\n            // We can delete this so long as we weren\'t aborted by our own fetcher\n            // re-submit which would have put _new_ controller is in fetchControllers\n            if (fetchControllers.get(key) === abortController) {\n              fetchControllers["delete"](key);\n            }\n            return _context6.abrupt("return");\n          case 18:\n            if (!deletedFetchers.has(key)) {\n              _context6.next = 21;\n              break;\n            }\n            updateFetcherState(key, getDoneFetcher(undefined));\n            return _context6.abrupt("return");\n          case 21:\n            if (!isRedirectResult(actionResult)) {\n              _context6.next = 31;\n              break;\n            }\n            fetchControllers["delete"](key);\n            if (!(pendingNavigationLoadId > originatingLoadId)) {\n              _context6.next = 28;\n              break;\n            }\n            // A new navigation was kicked off after our action started, so that\n            // should take precedence over this redirect navigation.  We already\n            // set isRevalidationRequired so all loaders for the new route should\n            // fire unless opted out via shouldRevalidate\n            updateFetcherState(key, getDoneFetcher(undefined));\n            return _context6.abrupt("return");\n          case 28:\n            fetchRedirectIds.add(key);\n            updateFetcherState(key, getLoadingFetcher(submission));\n            return _context6.abrupt("return", startRedirectNavigation(state, actionResult, {\n              fetcherSubmission: submission\n            }));\n          case 31:\n            if (!isErrorResult(actionResult)) {\n              _context6.next = 34;\n              break;\n            }\n            setFetcherError(key, routeId, actionResult.error);\n            return _context6.abrupt("return");\n          case 34:\n            if (!isDeferredResult(actionResult)) {\n              _context6.next = 36;\n              break;\n            }\n            throw getInternalRouterError(400, {\n              type: "defer-action"\n            });\n          case 36:\n            // Start the data load for current matches, or the next location if we\'re\n            // in the middle of a navigation\n            nextLocation = state.navigation.location || state.location;\n            revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);\n            routesToUse = inFlightDataRoutes || dataRoutes;\n            matches = state.navigation.state !== "idle" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;\n            invariant(matches, "Didn\'t find any matches after fetcher action");\n            loadId = ++incrementingLoadId;\n            fetchReloadIds.set(key, loadId);\n            loadFetcher = getLoadingFetcher(submission, actionResult.data);\n            state.fetchers.set(key, loadFetcher);\n            _getMatchesToLoad3 = getMatchesToLoad(init.history, state, matches, submission, nextLocation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, _defineProperty({}, match.route.id, actionResult.data), undefined // No need to send through errors since we short circuit above\n            ), _getMatchesToLoad4 = _slicedToArray(_getMatchesToLoad3, 2), matchesToLoad = _getMatchesToLoad4[0], revalidatingFetchers = _getMatchesToLoad4[1]; // Put all revalidating fetchers into the loading state, except for the\n            // current fetcher which we want to keep in it\'s current loading state which\n            // contains it\'s action submission info + action data\n            revalidatingFetchers.filter(function (rf) {\n              return rf.key !== key;\n            }).forEach(function (rf) {\n              var staleKey = rf.key;\n              var existingFetcher = state.fetchers.get(staleKey);\n              var revalidatingFetcher = getLoadingFetcher(undefined, existingFetcher ? existingFetcher.data : undefined);\n              state.fetchers.set(staleKey, revalidatingFetcher);\n              if (fetchControllers.has(staleKey)) {\n                abortFetcher(staleKey);\n              }\n              if (rf.controller) {\n                fetchControllers.set(staleKey, rf.controller);\n              }\n            });\n            updateState({\n              fetchers: new Map(state.fetchers)\n            });\n            abortPendingFetchRevalidations = function abortPendingFetchRevalidations() {\n              return revalidatingFetchers.forEach(function (rf) {\n                return abortFetcher(rf.key);\n              });\n            };\n            abortController.signal.addEventListener("abort", abortPendingFetchRevalidations);\n            _context6.next = 52;\n            return callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);\n          case 52:\n            _yield$callLoadersAnd2 = _context6.sent;\n            results = _yield$callLoadersAnd2.results;\n            loaderResults = _yield$callLoadersAnd2.loaderResults;\n            fetcherResults = _yield$callLoadersAnd2.fetcherResults;\n            if (!abortController.signal.aborted) {\n              _context6.next = 58;\n              break;\n            }\n            return _context6.abrupt("return");\n          case 58:\n            abortController.signal.removeEventListener("abort", abortPendingFetchRevalidations);\n            fetchReloadIds["delete"](key);\n            fetchControllers["delete"](key);\n            revalidatingFetchers.forEach(function (r) {\n              return fetchControllers["delete"](r.key);\n            });\n            redirect = findRedirect(results);\n            if (!redirect) {\n              _context6.next = 66;\n              break;\n            }\n            if (redirect.idx >= matchesToLoad.length) {\n              // If this redirect came from a fetcher make sure we mark it in\n              // fetchRedirectIds so it doesn\'t get revalidated on the next set of\n              // loader executions\n              fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n              fetchRedirectIds.add(fetcherKey);\n            }\n            return _context6.abrupt("return", startRedirectNavigation(state, redirect.result));\n          case 66:\n            // Process and commit output from loaders\n            _processLoaderData2 = processLoaderData(state, state.matches, matchesToLoad, loaderResults, undefined, revalidatingFetchers, fetcherResults, activeDeferreds), loaderData = _processLoaderData2.loaderData, errors = _processLoaderData2.errors; // Since we let revalidations complete even if the submitting fetcher was\n            // deleted, only put it back to idle if it hasn\'t been deleted\n            if (state.fetchers.has(key)) {\n              doneFetcher = getDoneFetcher(actionResult.data);\n              state.fetchers.set(key, doneFetcher);\n            }\n            abortStaleFetchLoads(loadId);\n            // If we are currently in a navigation loading state and this fetcher is\n            // more recent than the navigation, we want the newer data so abort the\n            // navigation and complete it with the fetcher data\n            if (state.navigation.state === "loading" && loadId > pendingNavigationLoadId) {\n              invariant(pendingAction, "Expected pending action");\n              pendingNavigationController && pendingNavigationController.abort();\n              completeNavigation(state.navigation.location, {\n                matches: matches,\n                loaderData: loaderData,\n                errors: errors,\n                fetchers: new Map(state.fetchers)\n              });\n            } else {\n              // otherwise just update with the fetcher data, preserving any existing\n              // loaderData for loaders that did not need to reload.  We have to\n              // manually merge here since we aren\'t going through completeNavigation\n              updateState({\n                errors: errors,\n                loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors),\n                fetchers: new Map(state.fetchers)\n              });\n              isRevalidationRequired = false;\n            }\n          case 70:\n          case "end":\n            return _context6.stop();\n        }\n      }, _callee6);\n    }));\n    return _handleFetcherAction.apply(this, arguments);\n  }\n  function handleFetcherLoader(_x29, _x30, _x31, _x32, _x33, _x34, _x35) {\n    return _handleFetcherLoader.apply(this, arguments);\n  }\n  /**\n   * Utility function to handle redirects returned from an action or loader.\n   * Normally, a redirect "replaces" the navigation that triggered it.  So, for\n   * example:\n   *\n   *  - user is on /a\n   *  - user clicks a link to /b\n   *  - loader for /b redirects to /c\n   *\n   * In a non-JS app the browser would track the in-flight navigation to /b and\n   * then replace it with /c when it encountered the redirect response.  In\n   * the end it would only ever update the URL bar with /c.\n   *\n   * In client-side routing using pushState/replaceState, we aim to emulate\n   * this behavior and we also do not update history until the end of the\n   * navigation (including processed redirects).  This means that we never\n   * actually touch history until we\'ve processed redirects, so we just use\n   * the history action from the original navigation (PUSH or REPLACE).\n   */\n  function _handleFetcherLoader() {\n    _handleFetcherLoader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(key, routeId, path, match, matches, flushSync, submission) {\n      var existingFetcher, abortController, fetchRequest, originatingLoadId, result;\n      return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n        while (1) switch (_context7.prev = _context7.next) {\n          case 0:\n            existingFetcher = state.fetchers.get(key);\n            updateFetcherState(key, getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : undefined), {\n              flushSync: flushSync\n            });\n            // Call the loader for this fetcher route match\n            abortController = new AbortController();\n            fetchRequest = createClientSideRequest(init.history, path, abortController.signal);\n            fetchControllers.set(key, abortController);\n            originatingLoadId = incrementingLoadId;\n            _context7.next = 8;\n            return callLoaderOrAction("loader", fetchRequest, match, matches, manifest, mapRouteProperties, basename);\n          case 8:\n            result = _context7.sent;\n            if (!isDeferredResult(result)) {\n              _context7.next = 16;\n              break;\n            }\n            _context7.next = 12;\n            return resolveDeferredData(result, fetchRequest.signal, true);\n          case 12:\n            _context7.t0 = _context7.sent;\n            if (_context7.t0) {\n              _context7.next = 15;\n              break;\n            }\n            _context7.t0 = result;\n          case 15:\n            result = _context7.t0;\n          case 16:\n            // We can delete this so long as we weren\'t aborted by our our own fetcher\n            // re-load which would have put _new_ controller is in fetchControllers\n            if (fetchControllers.get(key) === abortController) {\n              fetchControllers["delete"](key);\n            }\n            if (!fetchRequest.signal.aborted) {\n              _context7.next = 19;\n              break;\n            }\n            return _context7.abrupt("return");\n          case 19:\n            if (!deletedFetchers.has(key)) {\n              _context7.next = 22;\n              break;\n            }\n            updateFetcherState(key, getDoneFetcher(undefined));\n            return _context7.abrupt("return");\n          case 22:\n            if (!isRedirectResult(result)) {\n              _context7.next = 32;\n              break;\n            }\n            if (!(pendingNavigationLoadId > originatingLoadId)) {\n              _context7.next = 28;\n              break;\n            }\n            // A new navigation was kicked off after our loader started, so that\n            // should take precedence over this redirect navigation\n            updateFetcherState(key, getDoneFetcher(undefined));\n            return _context7.abrupt("return");\n          case 28:\n            fetchRedirectIds.add(key);\n            _context7.next = 31;\n            return startRedirectNavigation(state, result);\n          case 31:\n            return _context7.abrupt("return");\n          case 32:\n            if (!isErrorResult(result)) {\n              _context7.next = 35;\n              break;\n            }\n            setFetcherError(key, routeId, result.error);\n            return _context7.abrupt("return");\n          case 35:\n            invariant(!isDeferredResult(result), "Unhandled fetcher deferred data");\n            // Put the fetcher back into an idle state\n            updateFetcherState(key, getDoneFetcher(result.data));\n          case 37:\n          case "end":\n            return _context7.stop();\n        }\n      }, _callee7);\n    }));\n    return _handleFetcherLoader.apply(this, arguments);\n  }\n  function startRedirectNavigation(_x36, _x37, _x38) {\n    return _startRedirectNavigation.apply(this, arguments);\n  }\n  function _startRedirectNavigation() {\n    _startRedirectNavigation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(state, redirect, _temp2) {\n      var _ref8, submission, fetcherSubmission, replace, redirectLocation, isDocumentReload, url, redirectHistoryAction, _state$navigation, formMethod, formAction, formEncType, activeSubmission, overrideNavigation;\n      return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n        while (1) switch (_context8.prev = _context8.next) {\n          case 0:\n            _ref8 = _temp2 === void 0 ? {} : _temp2, submission = _ref8.submission, fetcherSubmission = _ref8.fetcherSubmission, replace = _ref8.replace;\n            if (redirect.revalidate) {\n              isRevalidationRequired = true;\n            }\n            redirectLocation = createLocation(state.location, redirect.location, {\n              _isRedirect: true\n            });\n            invariant(redirectLocation, "Expected a location on the redirect navigation");\n            if (!isBrowser) {\n              _context8.next = 10;\n              break;\n            }\n            isDocumentReload = false;\n            if (redirect.reloadDocument) {\n              // Hard reload if the response contained X-Remix-Reload-Document\n              isDocumentReload = true;\n            } else if (ABSOLUTE_URL_REGEX.test(redirect.location)) {\n              url = init.history.createURL(redirect.location);\n              isDocumentReload =\n              // Hard reload if it\'s an absolute URL to a new origin\n              url.origin !== routerWindow.location.origin ||\n              // Hard reload if it\'s an absolute URL that does not match our basename\n              stripBasename(url.pathname, basename) == null;\n            }\n            if (!isDocumentReload) {\n              _context8.next = 10;\n              break;\n            }\n            if (replace) {\n              routerWindow.location.replace(redirect.location);\n            } else {\n              routerWindow.location.assign(redirect.location);\n            }\n            return _context8.abrupt("return");\n          case 10:\n            // There\'s no need to abort on redirects, since we don\'t detect the\n            // redirect until the action/loaders have settled\n            pendingNavigationController = null;\n            redirectHistoryAction = replace === true ? Action.Replace : Action.Push; // Use the incoming submission if provided, fallback on the active one in\n            // state.navigation\n            _state$navigation = state.navigation, formMethod = _state$navigation.formMethod, formAction = _state$navigation.formAction, formEncType = _state$navigation.formEncType;\n            if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {\n              submission = getSubmissionFromNavigation(state.navigation);\n            }\n            // If this was a 307/308 submission we want to preserve the HTTP method and\n            // re-submit the GET/POST/PUT/PATCH/DELETE as a submission navigation to the\n            // redirected location\n            activeSubmission = submission || fetcherSubmission;\n            if (!(redirectPreserveMethodStatusCodes.has(redirect.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod))) {\n              _context8.next = 20;\n              break;\n            }\n            _context8.next = 18;\n            return startNavigation(redirectHistoryAction, redirectLocation, {\n              submission: _extends({}, activeSubmission, {\n                formAction: redirect.location\n              }),\n              // Preserve this flag across redirects\n              preventScrollReset: pendingPreventScrollReset\n            });\n          case 18:\n            _context8.next = 23;\n            break;\n          case 20:\n            // If we have a navigation submission, we will preserve it through the\n            // redirect navigation\n            overrideNavigation = getLoadingNavigation(redirectLocation, submission);\n            _context8.next = 23;\n            return startNavigation(redirectHistoryAction, redirectLocation, {\n              overrideNavigation: overrideNavigation,\n              // Send fetcher submissions through for shouldRevalidate\n              fetcherSubmission: fetcherSubmission,\n              // Preserve this flag across redirects\n              preventScrollReset: pendingPreventScrollReset\n            });\n          case 23:\n          case "end":\n            return _context8.stop();\n        }\n      }, _callee8);\n    }));\n    return _startRedirectNavigation.apply(this, arguments);\n  }\n  function callLoadersAndMaybeResolveData(_x39, _x40, _x41, _x42, _x43) {\n    return _callLoadersAndMaybeResolveData.apply(this, arguments);\n  }\n  function _callLoadersAndMaybeResolveData() {\n    _callLoadersAndMaybeResolveData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {\n      var results, loaderResults, fetcherResults;\n      return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n        while (1) switch (_context9.prev = _context9.next) {\n          case 0:\n            _context9.next = 2;\n            return Promise.all([].concat(_toConsumableArray(matchesToLoad.map(function (match) {\n              return callLoaderOrAction("loader", request, match, matches, manifest, mapRouteProperties, basename);\n            })), _toConsumableArray(fetchersToLoad.map(function (f) {\n              if (f.matches && f.match && f.controller) {\n                return callLoaderOrAction("loader", createClientSideRequest(init.history, f.path, f.controller.signal), f.match, f.matches, manifest, mapRouteProperties, basename);\n              } else {\n                var _error3 = {\n                  type: ResultType.error,\n                  error: getInternalRouterError(404, {\n                    pathname: f.path\n                  })\n                };\n                return _error3;\n              }\n            }))));\n          case 2:\n            results = _context9.sent;\n            loaderResults = results.slice(0, matchesToLoad.length);\n            fetcherResults = results.slice(matchesToLoad.length);\n            _context9.next = 7;\n            return Promise.all([resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, loaderResults.map(function () {\n              return request.signal;\n            }), false, state.loaderData), resolveDeferredResults(currentMatches, fetchersToLoad.map(function (f) {\n              return f.match;\n            }), fetcherResults, fetchersToLoad.map(function (f) {\n              return f.controller ? f.controller.signal : null;\n            }), true)]);\n          case 7:\n            return _context9.abrupt("return", {\n              results: results,\n              loaderResults: loaderResults,\n              fetcherResults: fetcherResults\n            });\n          case 8:\n          case "end":\n            return _context9.stop();\n        }\n      }, _callee9);\n    }));\n    return _callLoadersAndMaybeResolveData.apply(this, arguments);\n  }\n  function interruptActiveLoads() {\n    var _cancelledDeferredRou;\n    // Every interruption triggers a revalidation\n    isRevalidationRequired = true;\n    // Cancel pending route-level deferreds and mark cancelled routes for\n    // revalidation\n    (_cancelledDeferredRou = cancelledDeferredRoutes).push.apply(_cancelledDeferredRou, _toConsumableArray(cancelActiveDeferreds()));\n    // Abort in-flight fetcher loads\n    fetchLoadMatches.forEach(function (_, key) {\n      if (fetchControllers.has(key)) {\n        cancelledFetcherLoads.push(key);\n        abortFetcher(key);\n      }\n    });\n  }\n  function updateFetcherState(key, fetcher, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    state.fetchers.set(key, fetcher);\n    updateState({\n      fetchers: new Map(state.fetchers)\n    }, {\n      flushSync: (opts && opts.flushSync) === true\n    });\n  }\n  function setFetcherError(key, routeId, error, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    var boundaryMatch = findNearestBoundary(state.matches, routeId);\n    deleteFetcher(key);\n    updateState({\n      errors: _defineProperty({}, boundaryMatch.route.id, error),\n      fetchers: new Map(state.fetchers)\n    }, {\n      flushSync: (opts && opts.flushSync) === true\n    });\n  }\n  function getFetcher(key) {\n    if (future.v7_fetcherPersist) {\n      activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);\n      // If this fetcher was previously marked for deletion, unmark it since we\n      // have a new instance\n      if (deletedFetchers.has(key)) {\n        deletedFetchers["delete"](key);\n      }\n    }\n    return state.fetchers.get(key) || IDLE_FETCHER;\n  }\n  function deleteFetcher(key) {\n    var fetcher = state.fetchers.get(key);\n    // Don\'t abort the controller if this is a deletion of a fetcher.submit()\n    // in it\'s loading phase since - we don\'t want to abort the corresponding\n    // revalidation and want them to complete and land\n    if (fetchControllers.has(key) && !(fetcher && fetcher.state === "loading" && fetchReloadIds.has(key))) {\n      abortFetcher(key);\n    }\n    fetchLoadMatches["delete"](key);\n    fetchReloadIds["delete"](key);\n    fetchRedirectIds["delete"](key);\n    deletedFetchers["delete"](key);\n    state.fetchers["delete"](key);\n  }\n  function deleteFetcherAndUpdateState(key) {\n    if (future.v7_fetcherPersist) {\n      var count = (activeFetchers.get(key) || 0) - 1;\n      if (count <= 0) {\n        activeFetchers["delete"](key);\n        deletedFetchers.add(key);\n      } else {\n        activeFetchers.set(key, count);\n      }\n    } else {\n      deleteFetcher(key);\n    }\n    updateState({\n      fetchers: new Map(state.fetchers)\n    });\n  }\n  function abortFetcher(key) {\n    var controller = fetchControllers.get(key);\n    invariant(controller, "Expected fetch controller: " + key);\n    controller.abort();\n    fetchControllers["delete"](key);\n  }\n  function markFetchersDone(keys) {\n    var _iterator2 = _createForOfIteratorHelper(keys),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var key = _step2.value;\n        var fetcher = getFetcher(key);\n        var doneFetcher = getDoneFetcher(fetcher.data);\n        state.fetchers.set(key, doneFetcher);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n  function markFetchRedirectsDone() {\n    var doneKeys = [];\n    var updatedFetchers = false;\n    var _iterator3 = _createForOfIteratorHelper(fetchRedirectIds),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var key = _step3.value;\n        var fetcher = state.fetchers.get(key);\n        invariant(fetcher, "Expected fetcher: " + key);\n        if (fetcher.state === "loading") {\n          fetchRedirectIds["delete"](key);\n          doneKeys.push(key);\n          updatedFetchers = true;\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    markFetchersDone(doneKeys);\n    return updatedFetchers;\n  }\n  function abortStaleFetchLoads(landedId) {\n    var yeetedKeys = [];\n    var _iterator4 = _createForOfIteratorHelper(fetchReloadIds),\n      _step4;\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var _step4$value = _slicedToArray(_step4.value, 2),\n          key = _step4$value[0],\n          id = _step4$value[1];\n        if (id < landedId) {\n          var fetcher = state.fetchers.get(key);\n          invariant(fetcher, "Expected fetcher: " + key);\n          if (fetcher.state === "loading") {\n            abortFetcher(key);\n            fetchReloadIds["delete"](key);\n            yeetedKeys.push(key);\n          }\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n    markFetchersDone(yeetedKeys);\n    return yeetedKeys.length > 0;\n  }\n  function getBlocker(key, fn) {\n    var blocker = state.blockers.get(key) || IDLE_BLOCKER;\n    if (blockerFunctions.get(key) !== fn) {\n      blockerFunctions.set(key, fn);\n    }\n    return blocker;\n  }\n  function deleteBlocker(key) {\n    state.blockers["delete"](key);\n    blockerFunctions["delete"](key);\n  }\n  // Utility function to update blockers, ensuring valid state transitions\n  function updateBlocker(key, newBlocker) {\n    var blocker = state.blockers.get(key) || IDLE_BLOCKER;\n    // Poor mans state machine :)\n    // https://mermaid.live/edit#pako:eNqVkc9OwzAMxl8l8nnjAYrEtDIOHEBIgwvKJTReGy3_lDpIqO27k6awMG0XcrLlnz87nwdonESogKXXBuE79rq75XZO3-yHds0RJVuv70YrPlUrCEe2HfrORS3rubqZfuhtpg5C9wk5tZ4VKcRUq88q9Z8RS0-48cE1iHJkL0ugbHuFLus9L6spZy8nX9MP2CNdomVaposqu3fGayT8T8-jJQwhepo_UtpgBQaDEUom04dZhAN1aJBDlUKJBxE1ceB2Smj0Mln-IBW5AFU2dwUiktt_2Qaq2dBfaKdEup85UV7Yd-dKjlnkabl2Pvr0DTkTreM\n    invariant(blocker.state === "unblocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "proceeding" || blocker.state === "blocked" && newBlocker.state === "unblocked" || blocker.state === "proceeding" && newBlocker.state === "unblocked", "Invalid blocker state transition: " + blocker.state + " -> " + newBlocker.state);\n    var blockers = new Map(state.blockers);\n    blockers.set(key, newBlocker);\n    updateState({\n      blockers: blockers\n    });\n  }\n  function shouldBlockNavigation(_ref2) {\n    var currentLocation = _ref2.currentLocation,\n      nextLocation = _ref2.nextLocation,\n      historyAction = _ref2.historyAction;\n    if (blockerFunctions.size === 0) {\n      return;\n    }\n    // We ony support a single active blocker at the moment since we don\'t have\n    // any compelling use cases for multi-blocker yet\n    if (blockerFunctions.size > 1) {\n      warning(false, "A router only supports one blocker at a time");\n    }\n    var entries = Array.from(blockerFunctions.entries());\n    var _entries = _slicedToArray(entries[entries.length - 1], 2),\n      blockerKey = _entries[0],\n      blockerFunction = _entries[1];\n    var blocker = state.blockers.get(blockerKey);\n    if (blocker && blocker.state === "proceeding") {\n      // If the blocker is currently proceeding, we don\'t need to re-check\n      // it and can let this navigation continue\n      return;\n    }\n    // At this point, we know we\'re unblocked/blocked so we need to check the\n    // user-provided blocker function\n    if (blockerFunction({\n      currentLocation: currentLocation,\n      nextLocation: nextLocation,\n      historyAction: historyAction\n    })) {\n      return blockerKey;\n    }\n  }\n  function cancelActiveDeferreds(predicate) {\n    var cancelledRouteIds = [];\n    activeDeferreds.forEach(function (dfd, routeId) {\n      if (!predicate || predicate(routeId)) {\n        // Cancel the deferred - but do not remove from activeDeferreds here -\n        // we rely on the subscribers to do that so our tests can assert proper\n        // cleanup via _internalActiveDeferreds\n        dfd.cancel();\n        cancelledRouteIds.push(routeId);\n        activeDeferreds["delete"](routeId);\n      }\n    });\n    return cancelledRouteIds;\n  }\n  // Opt in to capturing and reporting scroll positions during navigations,\n  // used by the <ScrollRestoration> component\n  function enableScrollRestoration(positions, getPosition, getKey) {\n    savedScrollPositions = positions;\n    getScrollPosition = getPosition;\n    getScrollRestorationKey = getKey || null;\n    // Perform initial hydration scroll restoration, since we miss the boat on\n    // the initial updateState() because we\'ve not yet rendered <ScrollRestoration/>\n    // and therefore have no savedScrollPositions available\n    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {\n      initialScrollRestored = true;\n      var y = getSavedScrollPosition(state.location, state.matches);\n      if (y != null) {\n        updateState({\n          restoreScrollPosition: y\n        });\n      }\n    }\n    return function () {\n      savedScrollPositions = null;\n      getScrollPosition = null;\n      getScrollRestorationKey = null;\n    };\n  }\n  function getScrollKey(location, matches) {\n    if (getScrollRestorationKey) {\n      var key = getScrollRestorationKey(location, matches.map(function (m) {\n        return convertRouteMatchToUiMatch(m, state.loaderData);\n      }));\n      return key || location.key;\n    }\n    return location.key;\n  }\n  function saveScrollPosition(location, matches) {\n    if (savedScrollPositions && getScrollPosition) {\n      var key = getScrollKey(location, matches);\n      savedScrollPositions[key] = getScrollPosition();\n    }\n  }\n  function getSavedScrollPosition(location, matches) {\n    if (savedScrollPositions) {\n      var key = getScrollKey(location, matches);\n      var y = savedScrollPositions[key];\n      if (typeof y === "number") {\n        return y;\n      }\n    }\n    return null;\n  }\n  function _internalSetRoutes(newRoutes) {\n    manifest = {};\n    inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties, undefined, manifest);\n  }\n  router = {\n    get basename() {\n      return basename;\n    },\n    get state() {\n      return state;\n    },\n    get routes() {\n      return dataRoutes;\n    },\n    get window() {\n      return routerWindow;\n    },\n    initialize: initialize,\n    subscribe: subscribe,\n    enableScrollRestoration: enableScrollRestoration,\n    navigate: navigate,\n    fetch: fetch,\n    revalidate: revalidate,\n    // Passthrough to history-aware createHref used by useHref so we get proper\n    // hash-aware URLs in DOM paths\n    createHref: function createHref(to) {\n      return init.history.createHref(to);\n    },\n    encodeLocation: function encodeLocation(to) {\n      return init.history.encodeLocation(to);\n    },\n    getFetcher: getFetcher,\n    deleteFetcher: deleteFetcherAndUpdateState,\n    dispose: dispose,\n    getBlocker: getBlocker,\n    deleteBlocker: deleteBlocker,\n    _internalFetchControllers: fetchControllers,\n    _internalActiveDeferreds: activeDeferreds,\n    // TODO: Remove setRoutes, it\'s temporary to avoid dealing with\n    // updating the tree while validating the update algorithm.\n    _internalSetRoutes: _internalSetRoutes\n  };\n  return router;\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createStaticHandler\n////////////////////////////////////////////////////////////////////////////////\nvar UNSAFE_DEFERRED_SYMBOL = Symbol("deferred");\nfunction createStaticHandler(routes, opts) {\n  invariant(routes.length > 0, "You must provide a non-empty routes array to createStaticHandler");\n  var manifest = {};\n  var basename = (opts ? opts.basename : null) || "/";\n  var mapRouteProperties;\n  if (opts != null && opts.mapRouteProperties) {\n    mapRouteProperties = opts.mapRouteProperties;\n  } else if (opts != null && opts.detectErrorBoundary) {\n    // If they are still using the deprecated version, wrap it with the new API\n    var detectErrorBoundary = opts.detectErrorBoundary;\n    mapRouteProperties = function mapRouteProperties(route) {\n      return {\n        hasErrorBoundary: detectErrorBoundary(route)\n      };\n    };\n  } else {\n    mapRouteProperties = defaultMapRouteProperties;\n  }\n  var dataRoutes = convertRoutesToDataRoutes(routes, mapRouteProperties, undefined, manifest);\n  /**\n   * The query() method is intended for document requests, in which we want to\n   * call an optional action and potentially multiple loaders for all nested\n   * routes.  It returns a StaticHandlerContext object, which is very similar\n   * to the router state (location, loaderData, actionData, errors, etc.) and\n   * also adds SSR-specific information such as the statusCode and headers\n   * from action/loaders Responses.\n   *\n   * It _should_ never throw and should report all errors through the\n   * returned context.errors object, properly associating errors to their error\n   * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be\n   * used to emulate React error boundaries during SSr by performing a second\n   * pass only down to the boundaryId.\n   *\n   * The one exception where we do not return a StaticHandlerContext is when a\n   * redirect response is returned or thrown from any action/loader.  We\n   * propagate that out and return the raw Response so the HTTP server can\n   * return it directly.\n   */\n  function query(_x44, _x45) {\n    return _query.apply(this, arguments);\n  }\n  /**\n   * The queryRoute() method is intended for targeted route requests, either\n   * for fetch ?_data requests or resource route requests.  In this case, we\n   * are only ever calling a single action or loader, and we are returning the\n   * returned value directly.  In most cases, this will be a Response returned\n   * from the action/loader, but it may be a primitive or other value as well -\n   * and in such cases the calling context should handle that accordingly.\n   *\n   * We do respect the throw/return differentiation, so if an action/loader\n   * throws, then this method will throw the value.  This is important so we\n   * can do proper boundary identification in Remix where a thrown Response\n   * must go to the Catch Boundary but a returned Response is happy-path.\n   *\n   * One thing to note is that any Router-initiated Errors that make sense\n   * to associate with a status code will be thrown as an ErrorResponse\n   * instance which include the raw Error, such that the calling context can\n   * serialize the error as they see fit while including the proper response\n   * code.  Examples here are 404 and 405 errors that occur prior to reaching\n   * any user-defined loaders.\n   */\n  function _query() {\n    _query = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(request, _temp3) {\n      var _ref9, requestContext, url, method, location, matches, error, _getShortCircuitMatch3, methodNotAllowedMatches, route, _error4, _getShortCircuitMatch4, notFoundMatches, _route2, result;\n      return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n        while (1) switch (_context10.prev = _context10.next) {\n          case 0:\n            _ref9 = _temp3 === void 0 ? {} : _temp3, requestContext = _ref9.requestContext;\n            url = new URL(request.url);\n            method = request.method;\n            location = createLocation("", createPath(url), null, "default");\n            matches = matchRoutes(dataRoutes, location, basename); // SSR supports HEAD requests while SPA doesn\'t\n            if (!(!isValidMethod(method) && method !== "HEAD")) {\n              _context10.next = 11;\n              break;\n            }\n            error = getInternalRouterError(405, {\n              method: method\n            });\n            _getShortCircuitMatch3 = getShortCircuitMatches(dataRoutes), methodNotAllowedMatches = _getShortCircuitMatch3.matches, route = _getShortCircuitMatch3.route;\n            return _context10.abrupt("return", {\n              basename: basename,\n              location: location,\n              matches: methodNotAllowedMatches,\n              loaderData: {},\n              actionData: null,\n              errors: _defineProperty({}, route.id, error),\n              statusCode: error.status,\n              loaderHeaders: {},\n              actionHeaders: {},\n              activeDeferreds: null\n            });\n          case 11:\n            if (matches) {\n              _context10.next = 15;\n              break;\n            }\n            _error4 = getInternalRouterError(404, {\n              pathname: location.pathname\n            });\n            _getShortCircuitMatch4 = getShortCircuitMatches(dataRoutes), notFoundMatches = _getShortCircuitMatch4.matches, _route2 = _getShortCircuitMatch4.route;\n            return _context10.abrupt("return", {\n              basename: basename,\n              location: location,\n              matches: notFoundMatches,\n              loaderData: {},\n              actionData: null,\n              errors: _defineProperty({}, _route2.id, _error4),\n              statusCode: _error4.status,\n              loaderHeaders: {},\n              actionHeaders: {},\n              activeDeferreds: null\n            });\n          case 15:\n            _context10.next = 17;\n            return queryImpl(request, location, matches, requestContext);\n          case 17:\n            result = _context10.sent;\n            if (!isResponse(result)) {\n              _context10.next = 20;\n              break;\n            }\n            return _context10.abrupt("return", result);\n          case 20:\n            return _context10.abrupt("return", _extends({\n              location: location,\n              basename: basename\n            }, result));\n          case 21:\n          case "end":\n            return _context10.stop();\n        }\n      }, _callee10);\n    }));\n    return _query.apply(this, arguments);\n  }\n  function queryRoute(_x46, _x47) {\n    return _queryRoute.apply(this, arguments);\n  }\n  function _queryRoute() {\n    _queryRoute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(request, _temp4) {\n      var _ref10, routeId, requestContext, url, method, location, matches, match, result, error, _result$activeDeferre, data;\n      return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n        while (1) switch (_context11.prev = _context11.next) {\n          case 0:\n            _ref10 = _temp4 === void 0 ? {} : _temp4, routeId = _ref10.routeId, requestContext = _ref10.requestContext;\n            url = new URL(request.url);\n            method = request.method;\n            location = createLocation("", createPath(url), null, "default");\n            matches = matchRoutes(dataRoutes, location, basename); // SSR supports HEAD requests while SPA doesn\'t\n            if (!(!isValidMethod(method) && method !== "HEAD" && method !== "OPTIONS")) {\n              _context11.next = 9;\n              break;\n            }\n            throw getInternalRouterError(405, {\n              method: method\n            });\n          case 9:\n            if (matches) {\n              _context11.next = 11;\n              break;\n            }\n            throw getInternalRouterError(404, {\n              pathname: location.pathname\n            });\n          case 11:\n            match = routeId ? matches.find(function (m) {\n              return m.route.id === routeId;\n            }) : getTargetMatch(matches, location);\n            if (!(routeId && !match)) {\n              _context11.next = 16;\n              break;\n            }\n            throw getInternalRouterError(403, {\n              pathname: location.pathname,\n              routeId: routeId\n            });\n          case 16:\n            if (match) {\n              _context11.next = 18;\n              break;\n            }\n            throw getInternalRouterError(404, {\n              pathname: location.pathname\n            });\n          case 18:\n            _context11.next = 20;\n            return queryImpl(request, location, matches, requestContext, match);\n          case 20:\n            result = _context11.sent;\n            if (!isResponse(result)) {\n              _context11.next = 23;\n              break;\n            }\n            return _context11.abrupt("return", result);\n          case 23:\n            error = result.errors ? Object.values(result.errors)[0] : undefined;\n            if (!(error !== undefined)) {\n              _context11.next = 26;\n              break;\n            }\n            throw error;\n          case 26:\n            if (!result.actionData) {\n              _context11.next = 28;\n              break;\n            }\n            return _context11.abrupt("return", Object.values(result.actionData)[0]);\n          case 28:\n            if (!result.loaderData) {\n              _context11.next = 32;\n              break;\n            }\n            data = Object.values(result.loaderData)[0];\n            if ((_result$activeDeferre = result.activeDeferreds) != null && _result$activeDeferre[match.route.id]) {\n              data[UNSAFE_DEFERRED_SYMBOL] = result.activeDeferreds[match.route.id];\n            }\n            return _context11.abrupt("return", data);\n          case 32:\n            return _context11.abrupt("return", undefined);\n          case 33:\n          case "end":\n            return _context11.stop();\n        }\n      }, _callee11);\n    }));\n    return _queryRoute.apply(this, arguments);\n  }\n  function queryImpl(_x48, _x49, _x50, _x51, _x52) {\n    return _queryImpl.apply(this, arguments);\n  }\n  function _queryImpl() {\n    _queryImpl = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(request, location, matches, requestContext, routeMatch) {\n      var _result, result;\n      return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n        while (1) switch (_context12.prev = _context12.next) {\n          case 0:\n            invariant(request.signal, "query()/queryRoute() requests must contain an AbortController signal");\n            _context12.prev = 1;\n            if (!isMutationMethod(request.method.toLowerCase())) {\n              _context12.next = 7;\n              break;\n            }\n            _context12.next = 5;\n            return submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, routeMatch != null);\n          case 5:\n            _result = _context12.sent;\n            return _context12.abrupt("return", _result);\n          case 7:\n            _context12.next = 9;\n            return loadRouteData(request, matches, requestContext, routeMatch);\n          case 9:\n            result = _context12.sent;\n            return _context12.abrupt("return", isResponse(result) ? result : _extends({}, result, {\n              actionData: null,\n              actionHeaders: {}\n            }));\n          case 13:\n            _context12.prev = 13;\n            _context12.t0 = _context12["catch"](1);\n            if (!isQueryRouteResponse(_context12.t0)) {\n              _context12.next = 19;\n              break;\n            }\n            if (!(_context12.t0.type === ResultType.error)) {\n              _context12.next = 18;\n              break;\n            }\n            throw _context12.t0.response;\n          case 18:\n            return _context12.abrupt("return", _context12.t0.response);\n          case 19:\n            if (!isRedirectResponse(_context12.t0)) {\n              _context12.next = 21;\n              break;\n            }\n            return _context12.abrupt("return", _context12.t0);\n          case 21:\n            throw _context12.t0;\n          case 22:\n          case "end":\n            return _context12.stop();\n        }\n      }, _callee12, null, [[1, 13]]);\n    }));\n    return _queryImpl.apply(this, arguments);\n  }\n  function submit(_x53, _x54, _x55, _x56, _x57) {\n    return _submit.apply(this, arguments);\n  }\n  function _submit() {\n    _submit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(request, matches, actionMatch, requestContext, isRouteRequest) {\n      var result, error, method, _error5, boundaryMatch, _context13, loaderRequest, context;\n      return _regeneratorRuntime().wrap(function _callee13$(_context14) {\n        while (1) switch (_context14.prev = _context14.next) {\n          case 0:\n            if (!(!actionMatch.route.action && !actionMatch.route.lazy)) {\n              _context14.next = 7;\n              break;\n            }\n            error = getInternalRouterError(405, {\n              method: request.method,\n              pathname: new URL(request.url).pathname,\n              routeId: actionMatch.route.id\n            });\n            if (!isRouteRequest) {\n              _context14.next = 4;\n              break;\n            }\n            throw error;\n          case 4:\n            result = {\n              type: ResultType.error,\n              error: error\n            };\n            _context14.next = 13;\n            break;\n          case 7:\n            _context14.next = 9;\n            return callLoaderOrAction("action", request, actionMatch, matches, manifest, mapRouteProperties, basename, {\n              isStaticRequest: true,\n              isRouteRequest: isRouteRequest,\n              requestContext: requestContext\n            });\n          case 9:\n            result = _context14.sent;\n            if (!request.signal.aborted) {\n              _context14.next = 13;\n              break;\n            }\n            method = isRouteRequest ? "queryRoute" : "query";\n            throw new Error(method + "() call aborted: " + request.method + " " + request.url);\n          case 13:\n            if (!isRedirectResult(result)) {\n              _context14.next = 15;\n              break;\n            }\n            throw new Response(null, {\n              status: result.status,\n              headers: {\n                Location: result.location\n              }\n            });\n          case 15:\n            if (!isDeferredResult(result)) {\n              _context14.next = 20;\n              break;\n            }\n            _error5 = getInternalRouterError(400, {\n              type: "defer-action"\n            });\n            if (!isRouteRequest) {\n              _context14.next = 19;\n              break;\n            }\n            throw _error5;\n          case 19:\n            result = {\n              type: ResultType.error,\n              error: _error5\n            };\n          case 20:\n            if (!isRouteRequest) {\n              _context14.next = 24;\n              break;\n            }\n            if (!isErrorResult(result)) {\n              _context14.next = 23;\n              break;\n            }\n            throw result.error;\n          case 23:\n            return _context14.abrupt("return", {\n              matches: [actionMatch],\n              loaderData: {},\n              actionData: _defineProperty({}, actionMatch.route.id, result.data),\n              errors: null,\n              // Note: statusCode + headers are unused here since queryRoute will\n              // return the raw Response or value\n              statusCode: 200,\n              loaderHeaders: {},\n              actionHeaders: {},\n              activeDeferreds: null\n            });\n          case 24:\n            if (!isErrorResult(result)) {\n              _context14.next = 30;\n              break;\n            }\n            // Store off the pending error - we use it to determine which loaders\n            // to call and will commit it when we complete the navigation\n            boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n            _context14.next = 28;\n            return loadRouteData(request, matches, requestContext, undefined, _defineProperty({}, boundaryMatch.route.id, result.error));\n          case 28:\n            _context13 = _context14.sent;\n            return _context14.abrupt("return", _extends({}, _context13, {\n              statusCode: isRouteErrorResponse(result.error) ? result.error.status : 500,\n              actionData: null,\n              actionHeaders: _extends({}, result.headers ? _defineProperty({}, actionMatch.route.id, result.headers) : {})\n            }));\n          case 30:\n            // Create a GET request for the loaders\n            loaderRequest = new Request(request.url, {\n              headers: request.headers,\n              redirect: request.redirect,\n              signal: request.signal\n            });\n            _context14.next = 33;\n            return loadRouteData(loaderRequest, matches, requestContext);\n          case 33:\n            context = _context14.sent;\n            return _context14.abrupt("return", _extends({}, context, result.statusCode ? {\n              statusCode: result.statusCode\n            } : {}, {\n              actionData: _defineProperty({}, actionMatch.route.id, result.data),\n              actionHeaders: _extends({}, result.headers ? _defineProperty({}, actionMatch.route.id, result.headers) : {})\n            }));\n          case 35:\n          case "end":\n            return _context14.stop();\n        }\n      }, _callee13);\n    }));\n    return _submit.apply(this, arguments);\n  }\n  function loadRouteData(_x58, _x59, _x60, _x61, _x62) {\n    return _loadRouteData.apply(this, arguments);\n  }\n  function _loadRouteData() {\n    _loadRouteData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(request, matches, requestContext, routeMatch, pendingActionError) {\n      var isRouteRequest, requestMatches, matchesToLoad, results, method, activeDeferreds, context, executedLoaders;\n      return _regeneratorRuntime().wrap(function _callee14$(_context15) {\n        while (1) switch (_context15.prev = _context15.next) {\n          case 0:\n            isRouteRequest = routeMatch != null; // Short circuit if we have no loaders to run (queryRoute())\n            if (!(isRouteRequest && !(routeMatch != null && routeMatch.route.loader) && !(routeMatch != null && routeMatch.route.lazy))) {\n              _context15.next = 3;\n              break;\n            }\n            throw getInternalRouterError(400, {\n              method: request.method,\n              pathname: new URL(request.url).pathname,\n              routeId: routeMatch == null ? void 0 : routeMatch.route.id\n            });\n          case 3:\n            requestMatches = routeMatch ? [routeMatch] : getLoaderMatchesUntilBoundary(matches, Object.keys(pendingActionError || {})[0]);\n            matchesToLoad = requestMatches.filter(function (m) {\n              return m.route.loader || m.route.lazy;\n            }); // Short circuit if we have no loaders to run (query())\n            if (!(matchesToLoad.length === 0)) {\n              _context15.next = 7;\n              break;\n            }\n            return _context15.abrupt("return", {\n              matches: matches,\n              // Add a null for all matched routes for proper revalidation on the client\n              loaderData: matches.reduce(function (acc, m) {\n                return Object.assign(acc, _defineProperty({}, m.route.id, null));\n              }, {}),\n              errors: pendingActionError || null,\n              statusCode: 200,\n              loaderHeaders: {},\n              activeDeferreds: null\n            });\n          case 7:\n            _context15.next = 9;\n            return Promise.all(_toConsumableArray(matchesToLoad.map(function (match) {\n              return callLoaderOrAction("loader", request, match, matches, manifest, mapRouteProperties, basename, {\n                isStaticRequest: true,\n                isRouteRequest: isRouteRequest,\n                requestContext: requestContext\n              });\n            })));\n          case 9:\n            results = _context15.sent;\n            if (!request.signal.aborted) {\n              _context15.next = 13;\n              break;\n            }\n            method = isRouteRequest ? "queryRoute" : "query";\n            throw new Error(method + "() call aborted: " + request.method + " " + request.url);\n          case 13:\n            // Process and commit output from loaders\n            activeDeferreds = new Map();\n            context = processRouteLoaderData(matches, matchesToLoad, results, pendingActionError, activeDeferreds); // Add a null for any non-loader matches for proper revalidation on the client\n            executedLoaders = new Set(matchesToLoad.map(function (match) {\n              return match.route.id;\n            }));\n            matches.forEach(function (match) {\n              if (!executedLoaders.has(match.route.id)) {\n                context.loaderData[match.route.id] = null;\n              }\n            });\n            return _context15.abrupt("return", _extends({}, context, {\n              matches: matches,\n              activeDeferreds: activeDeferreds.size > 0 ? Object.fromEntries(activeDeferreds.entries()) : null\n            }));\n          case 18:\n          case "end":\n            return _context15.stop();\n        }\n      }, _callee14);\n    }));\n    return _loadRouteData.apply(this, arguments);\n  }\n  return {\n    dataRoutes: dataRoutes,\n    query: query,\n    queryRoute: queryRoute\n  };\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Helpers\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Given an existing StaticHandlerContext and an error thrown at render time,\n * provide an updated StaticHandlerContext suitable for a second SSR render\n */\nfunction getStaticContextFromError(routes, context, error) {\n  var newContext = _extends({}, context, {\n    statusCode: 500,\n    errors: _defineProperty({}, context._deepestRenderedBoundaryId || routes[0].id, error)\n  });\n  return newContext;\n}\nfunction isSubmissionNavigation(opts) {\n  return opts != null && ("formData" in opts && opts.formData != null || "body" in opts && opts.body !== undefined);\n}\nfunction normalizeTo(location, matches, basename, prependBasename, to, fromRouteId, relative) {\n  var contextualMatches;\n  var activeRouteMatch;\n  if (fromRouteId) {\n    // Grab matches up to the calling route so our route-relative logic is\n    // relative to the correct source route\n    contextualMatches = [];\n    var _iterator5 = _createForOfIteratorHelper(matches),\n      _step5;\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var match = _step5.value;\n        contextualMatches.push(match);\n        if (match.route.id === fromRouteId) {\n          activeRouteMatch = match;\n          break;\n        }\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n  } else {\n    contextualMatches = matches;\n    activeRouteMatch = matches[matches.length - 1];\n  }\n  // Resolve the relative path\n  var path = resolveTo(to ? to : ".", getPathContributingMatches(contextualMatches).map(function (m) {\n    return m.pathnameBase;\n  }), stripBasename(location.pathname, basename) || location.pathname, relative === "path");\n  // When `to` is not specified we inherit search/hash from the current\n  // location, unlike when to="." and we just inherit the path.\n  // See https://github.com/remix-run/remix/issues/927\n  if (to == null) {\n    path.search = location.search;\n    path.hash = location.hash;\n  }\n  // Add an ?index param for matched index routes if we don\'t already have one\n  if ((to == null || to === "" || to === ".") && activeRouteMatch && activeRouteMatch.route.index && !hasNakedIndexQuery(path.search)) {\n    path.search = path.search ? path.search.replace(/^\\?/, "?index&") : "?index";\n  }\n  // If we\'re operating within a basename, prepend it to the pathname.  If\n  // this is a root navigation, then just use the raw basename which allows\n  // the basename to have full control over the presence of a trailing slash\n  // on root actions\n  if (prependBasename && basename !== "/") {\n    path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);\n  }\n  return createPath(path);\n}\n// Normalize navigation options by converting formMethod=GET formData objects to\n// URLSearchParams so they behave identically to links with query params\nfunction normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {\n  // Return location verbatim on non-submission navigations\n  if (!opts || !isSubmissionNavigation(opts)) {\n    return {\n      path: path\n    };\n  }\n  if (opts.formMethod && !isValidMethod(opts.formMethod)) {\n    return {\n      path: path,\n      error: getInternalRouterError(405, {\n        method: opts.formMethod\n      })\n    };\n  }\n  var getInvalidBodyError = function getInvalidBodyError() {\n    return {\n      path: path,\n      error: getInternalRouterError(400, {\n        type: "invalid-body"\n      })\n    };\n  };\n  // Create a Submission on non-GET navigations\n  var rawFormMethod = opts.formMethod || "get";\n  var formMethod = normalizeFormMethod ? rawFormMethod.toUpperCase() : rawFormMethod.toLowerCase();\n  var formAction = stripHashFromPath(path);\n  if (opts.body !== undefined) {\n    if (opts.formEncType === "text/plain") {\n      // text only support POST/PUT/PATCH/DELETE submissions\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n      var text = typeof opts.body === "string" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ?\n      // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data\n      Array.from(opts.body.entries()).reduce(function (acc, _ref3) {\n        var _ref13 = _slicedToArray(_ref3, 2),\n          name = _ref13[0],\n          value = _ref13[1];\n        return "" + acc + name + "=" + value + "\\n";\n      }, "") : String(opts.body);\n      return {\n        path: path,\n        submission: {\n          formMethod: formMethod,\n          formAction: formAction,\n          formEncType: opts.formEncType,\n          formData: undefined,\n          json: undefined,\n          text: text\n        }\n      };\n    } else if (opts.formEncType === "application/json") {\n      // json only supports POST/PUT/PATCH/DELETE submissions\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n      try {\n        var _json = typeof opts.body === "string" ? JSON.parse(opts.body) : opts.body;\n        return {\n          path: path,\n          submission: {\n            formMethod: formMethod,\n            formAction: formAction,\n            formEncType: opts.formEncType,\n            formData: undefined,\n            json: _json,\n            text: undefined\n          }\n        };\n      } catch (e) {\n        return getInvalidBodyError();\n      }\n    }\n  }\n  invariant(typeof FormData === "function", "FormData is not available in this environment");\n  var searchParams;\n  var formData;\n  if (opts.formData) {\n    searchParams = convertFormDataToSearchParams(opts.formData);\n    formData = opts.formData;\n  } else if (opts.body instanceof FormData) {\n    searchParams = convertFormDataToSearchParams(opts.body);\n    formData = opts.body;\n  } else if (opts.body instanceof URLSearchParams) {\n    searchParams = opts.body;\n    formData = convertSearchParamsToFormData(searchParams);\n  } else if (opts.body == null) {\n    searchParams = new URLSearchParams();\n    formData = new FormData();\n  } else {\n    try {\n      searchParams = new URLSearchParams(opts.body);\n      formData = convertSearchParamsToFormData(searchParams);\n    } catch (e) {\n      return getInvalidBodyError();\n    }\n  }\n  var submission = {\n    formMethod: formMethod,\n    formAction: formAction,\n    formEncType: opts && opts.formEncType || "application/x-www-form-urlencoded",\n    formData: formData,\n    json: undefined,\n    text: undefined\n  };\n  if (isMutationMethod(submission.formMethod)) {\n    return {\n      path: path,\n      submission: submission\n    };\n  }\n  // Flatten submission onto URLSearchParams for GET submissions\n  var parsedPath = parsePath(path);\n  // On GET navigation submissions we can drop the ?index param from the\n  // resulting location since all loaders will run.  But fetcher GET submissions\n  // only run a single loader so we need to preserve any incoming ?index params\n  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {\n    searchParams.append("index", "");\n  }\n  parsedPath.search = "?" + searchParams;\n  return {\n    path: createPath(parsedPath),\n    submission: submission\n  };\n}\n// Filter out all routes below any caught error as they aren\'t going to\n// render so we don\'t need to load them\nfunction getLoaderMatchesUntilBoundary(matches, boundaryId) {\n  var boundaryMatches = matches;\n  if (boundaryId) {\n    var index = matches.findIndex(function (m) {\n      return m.route.id === boundaryId;\n    });\n    if (index >= 0) {\n      boundaryMatches = matches.slice(0, index);\n    }\n  }\n  return boundaryMatches;\n}\nfunction getMatchesToLoad(history, state, matches, submission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError) {\n  var actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : undefined;\n  var currentUrl = history.createURL(state.location);\n  var nextUrl = history.createURL(location);\n  // Pick navigation matches that are net-new or qualify for revalidation\n  var boundaryId = pendingError ? Object.keys(pendingError)[0] : undefined;\n  var boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);\n  var navigationMatches = boundaryMatches.filter(function (match, index) {\n    if (match.route.lazy) {\n      // We haven\'t loaded this route yet so we don\'t know if it\'s got a loader!\n      return true;\n    }\n    if (match.route.loader == null) {\n      return false;\n    }\n    // Always call the loader on new route instances and pending defer cancellations\n    if (isNewLoader(state.loaderData, state.matches[index], match) || cancelledDeferredRoutes.some(function (id) {\n      return id === match.route.id;\n    })) {\n      return true;\n    }\n    // This is the default implementation for when we revalidate.  If the route\n    // provides it\'s own implementation, then we give them full control but\n    // provide this value so they can leverage it if needed after they check\n    // their own specific use cases\n    var currentRouteMatch = state.matches[index];\n    var nextRouteMatch = match;\n    return shouldRevalidateLoader(match, _extends({\n      currentUrl: currentUrl,\n      currentParams: currentRouteMatch.params,\n      nextUrl: nextUrl,\n      nextParams: nextRouteMatch.params\n    }, submission, {\n      actionResult: actionResult,\n      defaultShouldRevalidate:\n      // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate\n      isRevalidationRequired ||\n      // Clicked the same link, resubmitted a GET form\n      currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search ||\n      // Search params affect all loaders\n      currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)\n    }));\n  });\n  // Pick fetcher.loads that need to be revalidated\n  var revalidatingFetchers = [];\n  fetchLoadMatches.forEach(function (f, key) {\n    // Don\'t revalidate if fetcher won\'t be present in the subsequent render\n    if (!matches.some(function (m) {\n      return m.route.id === f.routeId;\n    })) {\n      return;\n    }\n    var fetcherMatches = matchRoutes(routesToUse, f.path, basename);\n    // If the fetcher path no longer matches, push it in with null matches so\n    // we can trigger a 404 in callLoadersAndMaybeResolveData.  Note this is\n    // currently only a use-case for Remix HMR where the route tree can change\n    // at runtime and remove a route previously loaded via a fetcher\n    if (!fetcherMatches) {\n      revalidatingFetchers.push({\n        key: key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: null,\n        match: null,\n        controller: null\n      });\n      return;\n    }\n    // Revalidating fetchers are decoupled from the route matches since they\n    // load from a static href.  They revalidate based on explicit revalidation\n    // (submission, useRevalidator, or X-Remix-Revalidate)\n    var fetcher = state.fetchers.get(key);\n    var fetcherMatch = getTargetMatch(fetcherMatches, f.path);\n    var shouldRevalidate = false;\n    if (fetchRedirectIds.has(key)) {\n      // Never trigger a revalidation of an actively redirecting fetcher\n      shouldRevalidate = false;\n    } else if (cancelledFetcherLoads.includes(key)) {\n      // Always revalidate if the fetcher was cancelled\n      shouldRevalidate = true;\n    } else if (fetcher && fetcher.state !== "idle" && fetcher.data === undefined) {\n      // If the fetcher hasn\'t ever completed loading yet, then this isn\'t a\n      // revalidation, it would just be a brand new load if an explicit\n      // revalidation is required\n      shouldRevalidate = isRevalidationRequired;\n    } else {\n      // Otherwise fall back on any user-defined shouldRevalidate, defaulting\n      // to explicit revalidations only\n      shouldRevalidate = shouldRevalidateLoader(fetcherMatch, _extends({\n        currentUrl: currentUrl,\n        currentParams: state.matches[state.matches.length - 1].params,\n        nextUrl: nextUrl,\n        nextParams: matches[matches.length - 1].params\n      }, submission, {\n        actionResult: actionResult,\n        defaultShouldRevalidate: isRevalidationRequired\n      }));\n    }\n    if (shouldRevalidate) {\n      revalidatingFetchers.push({\n        key: key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: fetcherMatches,\n        match: fetcherMatch,\n        controller: new AbortController()\n      });\n    }\n  });\n  return [navigationMatches, revalidatingFetchers];\n}\nfunction isNewLoader(currentLoaderData, currentMatch, match) {\n  var isNew =\n  // [a] -> [a, b]\n  !currentMatch ||\n  // [a, b] -> [a, c]\n  match.route.id !== currentMatch.route.id;\n  // Handle the case that we don\'t have data for a re-used route, potentially\n  // from a prior error or from a cancelled pending deferred\n  var isMissingData = currentLoaderData[match.route.id] === undefined;\n  // Always load if this is a net-new route or we don\'t yet have data\n  return isNew || isMissingData;\n}\nfunction isNewRouteInstance(currentMatch, match) {\n  var currentPath = currentMatch.route.path;\n  return (\n    // param change for this match, /users/123 -> /users/456\n    currentMatch.pathname !== match.pathname ||\n    // splat param changed, which is not present in match.path\n    // e.g. /files/images/avatar.jpg -> files/finances.xls\n    currentPath != null && currentPath.endsWith("*") && currentMatch.params["*"] !== match.params["*"]\n  );\n}\nfunction shouldRevalidateLoader(loaderMatch, arg) {\n  if (loaderMatch.route.shouldRevalidate) {\n    var routeChoice = loaderMatch.route.shouldRevalidate(arg);\n    if (typeof routeChoice === "boolean") {\n      return routeChoice;\n    }\n  }\n  return arg.defaultShouldRevalidate;\n}\n/**\n * Execute route.lazy() methods to lazily load route modules (loader, action,\n * shouldRevalidate) and update the routeManifest in place which shares objects\n * with dataRoutes so those get updated as well.\n */\nfunction loadLazyRouteModule(_x63, _x64, _x65) {\n  return _loadLazyRouteModule.apply(this, arguments);\n}\nfunction _loadLazyRouteModule() {\n  _loadLazyRouteModule = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(route, mapRouteProperties, manifest) {\n    var lazyRoute, routeToUpdate, routeUpdates, lazyRouteProperty, staticRouteValue, isPropertyStaticallyDefined;\n    return _regeneratorRuntime().wrap(function _callee15$(_context16) {\n      while (1) switch (_context16.prev = _context16.next) {\n        case 0:\n          if (route.lazy) {\n            _context16.next = 2;\n            break;\n          }\n          return _context16.abrupt("return");\n        case 2:\n          _context16.next = 4;\n          return route.lazy();\n        case 4:\n          lazyRoute = _context16.sent;\n          if (route.lazy) {\n            _context16.next = 7;\n            break;\n          }\n          return _context16.abrupt("return");\n        case 7:\n          routeToUpdate = manifest[route.id];\n          invariant(routeToUpdate, "No route found in manifest");\n          // Update the route in place.  This should be safe because there\'s no way\n          // we could yet be sitting on this route as we can\'t get there without\n          // resolving lazy() first.\n          //\n          // This is different than the HMR "update" use-case where we may actively be\n          // on the route being updated.  The main concern boils down to "does this\n          // mutation affect any ongoing navigations or any current state.matches\n          // values?".  If not, it should be safe to update in place.\n          routeUpdates = {};\n          for (lazyRouteProperty in lazyRoute) {\n            staticRouteValue = routeToUpdate[lazyRouteProperty];\n            isPropertyStaticallyDefined = staticRouteValue !== undefined &&\n            // This property isn\'t static since it should always be updated based\n            // on the route updates\n            lazyRouteProperty !== "hasErrorBoundary";\n            warning(!isPropertyStaticallyDefined, "Route \\"" + routeToUpdate.id + "\\" has a static property \\"" + lazyRouteProperty + "\\" " + "defined but its lazy function is also returning a value for this property. " + ("The lazy route property \\"" + lazyRouteProperty + "\\" will be ignored."));\n            if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {\n              routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];\n            }\n          }\n          // Mutate the route with the provided updates.  Do this first so we pass\n          // the updated version to mapRouteProperties\n          Object.assign(routeToUpdate, routeUpdates);\n          // Mutate the `hasErrorBoundary` property on the route based on the route\n          // updates and remove the `lazy` function so we don\'t resolve the lazy\n          // route again.\n          Object.assign(routeToUpdate, _extends({}, mapRouteProperties(routeToUpdate), {\n            lazy: undefined\n          }));\n        case 13:\n        case "end":\n          return _context16.stop();\n      }\n    }, _callee15);\n  }));\n  return _loadLazyRouteModule.apply(this, arguments);\n}\nfunction callLoaderOrAction(_x66, _x67, _x68, _x69, _x70, _x71, _x72, _x73) {\n  return _callLoaderOrAction.apply(this, arguments);\n} // Utility method for creating the Request instances for loaders/actions during\n// client-side navigations and fetches.  During SSR we will always have a\n// Request instance from the static handler (query/queryRoute)\nfunction _callLoaderOrAction() {\n  _callLoaderOrAction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(type, request, match, matches, manifest, mapRouteProperties, basename, opts) {\n    var resultType, result, onReject, runHandler, handler, handlerError, values, url, pathname, _url, _pathname, status, location, currentUrl, _url2, isSameBasename, queryRouteResponse, data, contentType, _result$init, _result$init2;\n    return _regeneratorRuntime().wrap(function _callee16$(_context17) {\n      while (1) switch (_context17.prev = _context17.next) {\n        case 0:\n          if (opts === void 0) {\n            opts = {};\n          }\n          runHandler = function runHandler(handler) {\n            // Setup a promise we can race against so that abort signals short circuit\n            var reject;\n            var abortPromise = new Promise(function (_, r) {\n              return reject = r;\n            });\n            onReject = function onReject() {\n              return reject();\n            };\n            request.signal.addEventListener("abort", onReject);\n            return Promise.race([handler({\n              request: request,\n              params: match.params,\n              context: opts.requestContext\n            }), abortPromise]);\n          };\n          _context17.prev = 2;\n          handler = match.route[type];\n          if (!match.route.lazy) {\n            _context17.next = 32;\n            break;\n          }\n          if (!handler) {\n            _context17.next = 14;\n            break;\n          }\n          _context17.next = 8;\n          return Promise.all([\n          // If the handler throws, don\'t let it immediately bubble out,\n          // since we need to let the lazy() execution finish so we know if this\n          // route has a boundary that can handle the error\n          runHandler(handler)["catch"](function (e) {\n            handlerError = e;\n          }), loadLazyRouteModule(match.route, mapRouteProperties, manifest)]);\n        case 8:\n          values = _context17.sent;\n          if (!handlerError) {\n            _context17.next = 11;\n            break;\n          }\n          throw handlerError;\n        case 11:\n          result = values[0];\n          _context17.next = 30;\n          break;\n        case 14:\n          _context17.next = 16;\n          return loadLazyRouteModule(match.route, mapRouteProperties, manifest);\n        case 16:\n          handler = match.route[type];\n          if (!handler) {\n            _context17.next = 23;\n            break;\n          }\n          _context17.next = 20;\n          return runHandler(handler);\n        case 20:\n          result = _context17.sent;\n          _context17.next = 30;\n          break;\n        case 23:\n          if (!(type === "action")) {\n            _context17.next = 29;\n            break;\n          }\n          url = new URL(request.url);\n          pathname = url.pathname + url.search;\n          throw getInternalRouterError(405, {\n            method: request.method,\n            pathname: pathname,\n            routeId: match.route.id\n          });\n        case 29:\n          return _context17.abrupt("return", {\n            type: ResultType.data,\n            data: undefined\n          });\n        case 30:\n          _context17.next = 41;\n          break;\n        case 32:\n          if (handler) {\n            _context17.next = 38;\n            break;\n          }\n          _url = new URL(request.url);\n          _pathname = _url.pathname + _url.search;\n          throw getInternalRouterError(404, {\n            pathname: _pathname\n          });\n        case 38:\n          _context17.next = 40;\n          return runHandler(handler);\n        case 40:\n          result = _context17.sent;\n        case 41:\n          invariant(result !== undefined, "You defined " + (type === "action" ? "an action" : "a loader") + " for route " + ("\\"" + match.route.id + "\\" but didn\'t return anything from your `" + type + "` ") + "function. Please return a value or `null`.");\n          _context17.next = 48;\n          break;\n        case 44:\n          _context17.prev = 44;\n          _context17.t0 = _context17["catch"](2);\n          resultType = ResultType.error;\n          result = _context17.t0;\n        case 48:\n          _context17.prev = 48;\n          if (onReject) {\n            request.signal.removeEventListener("abort", onReject);\n          }\n          return _context17.finish(48);\n        case 51:\n          if (!isResponse(result)) {\n            _context17.next = 77;\n            break;\n          }\n          status = result.status; // Process redirects\n          if (!redirectStatusCodes.has(status)) {\n            _context17.next = 61;\n            break;\n          }\n          location = result.headers.get("Location");\n          invariant(location, "Redirects returned/thrown from loaders/actions must have a Location header");\n          // Support relative routing in internal redirects\n          if (!ABSOLUTE_URL_REGEX.test(location)) {\n            location = normalizeTo(new URL(request.url), matches.slice(0, matches.indexOf(match) + 1), basename, true, location);\n          } else if (!opts.isStaticRequest) {\n            // Strip off the protocol+origin for same-origin + same-basename absolute\n            // redirects. If this is a static request, we can let it go back to the\n            // browser as-is\n            currentUrl = new URL(request.url);\n            _url2 = location.startsWith("//") ? new URL(currentUrl.protocol + location) : new URL(location);\n            isSameBasename = stripBasename(_url2.pathname, basename) != null;\n            if (_url2.origin === currentUrl.origin && isSameBasename) {\n              location = _url2.pathname + _url2.search + _url2.hash;\n            }\n          }\n          // Don\'t process redirects in the router during static requests requests.\n          // Instead, throw the Response and let the server handle it with an HTTP\n          // redirect.  We also update the Location header in place in this flow so\n          // basename and relative routing is taken into account\n          if (!opts.isStaticRequest) {\n            _context17.next = 60;\n            break;\n          }\n          result.headers.set("Location", location);\n          throw result;\n        case 60:\n          return _context17.abrupt("return", {\n            type: ResultType.redirect,\n            status: status,\n            location: location,\n            revalidate: result.headers.get("X-Remix-Revalidate") !== null,\n            reloadDocument: result.headers.get("X-Remix-Reload-Document") !== null\n          });\n        case 61:\n          if (!opts.isRouteRequest) {\n            _context17.next = 64;\n            break;\n          }\n          queryRouteResponse = {\n            type: resultType === ResultType.error ? ResultType.error : ResultType.data,\n            response: result\n          };\n          throw queryRouteResponse;\n        case 64:\n          contentType = result.headers.get("Content-Type"); // Check between word boundaries instead of startsWith() due to the last\n          // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type\n          if (!(contentType && /\\bapplication\\/json\\b/.test(contentType))) {\n            _context17.next = 71;\n            break;\n          }\n          _context17.next = 68;\n          return result.json();\n        case 68:\n          data = _context17.sent;\n          _context17.next = 74;\n          break;\n        case 71:\n          _context17.next = 73;\n          return result.text();\n        case 73:\n          data = _context17.sent;\n        case 74:\n          if (!(resultType === ResultType.error)) {\n            _context17.next = 76;\n            break;\n          }\n          return _context17.abrupt("return", {\n            type: resultType,\n            error: new ErrorResponseImpl(status, result.statusText, data),\n            headers: result.headers\n          });\n        case 76:\n          return _context17.abrupt("return", {\n            type: ResultType.data,\n            data: data,\n            statusCode: result.status,\n            headers: result.headers\n          });\n        case 77:\n          if (!(resultType === ResultType.error)) {\n            _context17.next = 79;\n            break;\n          }\n          return _context17.abrupt("return", {\n            type: resultType,\n            error: result\n          });\n        case 79:\n          if (!isDeferredData(result)) {\n            _context17.next = 81;\n            break;\n          }\n          return _context17.abrupt("return", {\n            type: ResultType.deferred,\n            deferredData: result,\n            statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,\n            headers: ((_result$init2 = result.init) == null ? void 0 : _result$init2.headers) && new Headers(result.init.headers)\n          });\n        case 81:\n          return _context17.abrupt("return", {\n            type: ResultType.data,\n            data: result\n          });\n        case 82:\n        case "end":\n          return _context17.stop();\n      }\n    }, _callee16, null, [[2, 44, 48, 51]]);\n  }));\n  return _callLoaderOrAction.apply(this, arguments);\n}\nfunction createClientSideRequest(history, location, signal, submission) {\n  var url = history.createURL(stripHashFromPath(location)).toString();\n  var init = {\n    signal: signal\n  };\n  if (submission && isMutationMethod(submission.formMethod)) {\n    var formMethod = submission.formMethod,\n      formEncType = submission.formEncType;\n    // Didn\'t think we needed this but it turns out unlike other methods, patch\n    // won\'t be properly normalized to uppercase and results in a 405 error.\n    // See: https://fetch.spec.whatwg.org/#concept-method\n    init.method = formMethod.toUpperCase();\n    if (formEncType === "application/json") {\n      init.headers = new Headers({\n        "Content-Type": formEncType\n      });\n      init.body = JSON.stringify(submission.json);\n    } else if (formEncType === "text/plain") {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = submission.text;\n    } else if (formEncType === "application/x-www-form-urlencoded" && submission.formData) {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = convertFormDataToSearchParams(submission.formData);\n    } else {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = submission.formData;\n    }\n  }\n  return new Request(url, init);\n}\nfunction convertFormDataToSearchParams(formData) {\n  var searchParams = new URLSearchParams();\n  var _iterator6 = _createForOfIteratorHelper(formData.entries()),\n    _step6;\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var _step6$value = _slicedToArray(_step6.value, 2),\n        key = _step6$value[0],\n        value = _step6$value[1];\n      // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs\n      searchParams.append(key, typeof value === "string" ? value : value.name);\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n  return searchParams;\n}\nfunction convertSearchParamsToFormData(searchParams) {\n  var formData = new FormData();\n  var _iterator7 = _createForOfIteratorHelper(searchParams.entries()),\n    _step7;\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var _step7$value = _slicedToArray(_step7.value, 2),\n        key = _step7$value[0],\n        value = _step7$value[1];\n      formData.append(key, value);\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n  return formData;\n}\nfunction processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds) {\n  // Fill in loaderData/errors from our loaders\n  var loaderData = {};\n  var errors = null;\n  var statusCode;\n  var foundError = false;\n  var loaderHeaders = {};\n  // Process loader results into state.loaderData/state.errors\n  results.forEach(function (result, index) {\n    var id = matchesToLoad[index].route.id;\n    invariant(!isRedirectResult(result), "Cannot handle redirect results in processLoaderData");\n    if (isErrorResult(result)) {\n      // Look upwards from the matched route for the closest ancestor\n      // error boundary, defaulting to the root match\n      var boundaryMatch = findNearestBoundary(matches, id);\n      var error = result.error;\n      // If we have a pending action error, we report it at the highest-route\n      // that throws a loader error, and then clear it out to indicate that\n      // it was consumed\n      if (pendingError) {\n        error = Object.values(pendingError)[0];\n        pendingError = undefined;\n      }\n      errors = errors || {};\n      // Prefer higher error values if lower errors bubble to the same boundary\n      if (errors[boundaryMatch.route.id] == null) {\n        errors[boundaryMatch.route.id] = error;\n      }\n      // Clear our any prior loaderData for the throwing route\n      loaderData[id] = undefined;\n      // Once we find our first (highest) error, we set the status code and\n      // prevent deeper status codes from overriding\n      if (!foundError) {\n        foundError = true;\n        statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    } else {\n      if (isDeferredResult(result)) {\n        activeDeferreds.set(id, result.deferredData);\n        loaderData[id] = result.deferredData.data;\n      } else {\n        loaderData[id] = result.data;\n      }\n      // Error status codes always override success status codes, but if all\n      // loaders are successful we take the deepest status code.\n      if (result.statusCode != null && result.statusCode !== 200 && !foundError) {\n        statusCode = result.statusCode;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    }\n  });\n  // If we didn\'t consume the pending action error (i.e., all loaders\n  // resolved), then consume it here.  Also clear out any loaderData for the\n  // throwing route\n  if (pendingError) {\n    errors = pendingError;\n    loaderData[Object.keys(pendingError)[0]] = undefined;\n  }\n  return {\n    loaderData: loaderData,\n    errors: errors,\n    statusCode: statusCode || 200,\n    loaderHeaders: loaderHeaders\n  };\n}\nfunction processLoaderData(state, matches, matchesToLoad, results, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) {\n  var _processRouteLoaderDa = processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds),\n    loaderData = _processRouteLoaderDa.loaderData,\n    errors = _processRouteLoaderDa.errors;\n  // Process results from our revalidating fetchers\n  for (var index = 0; index < revalidatingFetchers.length; index++) {\n    var _revalidatingFetchers = revalidatingFetchers[index],\n      key = _revalidatingFetchers.key,\n      match = _revalidatingFetchers.match,\n      controller = _revalidatingFetchers.controller;\n    invariant(fetcherResults !== undefined && fetcherResults[index] !== undefined, "Did not find corresponding fetcher result");\n    var result = fetcherResults[index];\n    // Process fetcher non-redirect errors\n    if (controller && controller.signal.aborted) {\n      // Nothing to do for aborted fetchers\n      continue;\n    } else if (isErrorResult(result)) {\n      var boundaryMatch = findNearestBoundary(state.matches, match == null ? void 0 : match.route.id);\n      if (!(errors && errors[boundaryMatch.route.id])) {\n        errors = _extends({}, errors, _defineProperty({}, boundaryMatch.route.id, result.error));\n      }\n      state.fetchers["delete"](key);\n    } else if (isRedirectResult(result)) {\n      // Should never get here, redirects should get processed above, but we\n      // keep this to type narrow to a success result in the else\n      invariant(false, "Unhandled fetcher revalidation redirect");\n    } else if (isDeferredResult(result)) {\n      // Should never get here, deferred data should be awaited for fetchers\n      // in resolveDeferredResults\n      invariant(false, "Unhandled fetcher deferred data");\n    } else {\n      var doneFetcher = getDoneFetcher(result.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n  return {\n    loaderData: loaderData,\n    errors: errors\n  };\n}\nfunction mergeLoaderData(loaderData, newLoaderData, matches, errors) {\n  var mergedLoaderData = _extends({}, newLoaderData);\n  var _iterator8 = _createForOfIteratorHelper(matches),\n    _step8;\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var match = _step8.value;\n      var id = match.route.id;\n      if (newLoaderData.hasOwnProperty(id)) {\n        if (newLoaderData[id] !== undefined) {\n          mergedLoaderData[id] = newLoaderData[id];\n        }\n      } else if (loaderData[id] !== undefined && match.route.loader) {\n        // Preserve existing keys not included in newLoaderData and where a loader\n        // wasn\'t removed by HMR\n        mergedLoaderData[id] = loaderData[id];\n      }\n      if (errors && errors.hasOwnProperty(id)) {\n        // Don\'t keep any loader data below the boundary\n        break;\n      }\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n  return mergedLoaderData;\n}\n// Find the nearest error boundary, looking upwards from the leaf route (or the\n// route specified by routeId) for the closest ancestor error boundary,\n// defaulting to the root match\nfunction findNearestBoundary(matches, routeId) {\n  var eligibleMatches = routeId ? matches.slice(0, matches.findIndex(function (m) {\n    return m.route.id === routeId;\n  }) + 1) : _toConsumableArray(matches);\n  return eligibleMatches.reverse().find(function (m) {\n    return m.route.hasErrorBoundary === true;\n  }) || matches[0];\n}\nfunction getShortCircuitMatches(routes) {\n  // Prefer a root layout route if present, otherwise shim in a route object\n  var route = routes.length === 1 ? routes[0] : routes.find(function (r) {\n    return r.index || !r.path || r.path === "/";\n  }) || {\n    id: "__shim-error-route__"\n  };\n  return {\n    matches: [{\n      params: {},\n      pathname: "",\n      pathnameBase: "",\n      route: route\n    }],\n    route: route\n  };\n}\nfunction getInternalRouterError(status, _temp5) {\n  var _ref14 = _temp5 === void 0 ? {} : _temp5,\n    pathname = _ref14.pathname,\n    routeId = _ref14.routeId,\n    method = _ref14.method,\n    type = _ref14.type;\n  var statusText = "Unknown Server Error";\n  var errorMessage = "Unknown @remix-run/router error";\n  if (status === 400) {\n    statusText = "Bad Request";\n    if (method && pathname && routeId) {\n      errorMessage = "You made a " + method + " request to \\"" + pathname + "\\" but " + ("did not provide a `loader` for route \\"" + routeId + "\\", ") + "so there is no way to handle the request.";\n    } else if (type === "defer-action") {\n      errorMessage = "defer() is not supported in actions";\n    } else if (type === "invalid-body") {\n      errorMessage = "Unable to encode submission body";\n    }\n  } else if (status === 403) {\n    statusText = "Forbidden";\n    errorMessage = "Route \\"" + routeId + "\\" does not match URL \\"" + pathname + "\\"";\n  } else if (status === 404) {\n    statusText = "Not Found";\n    errorMessage = "No route matches URL \\"" + pathname + "\\"";\n  } else if (status === 405) {\n    statusText = "Method Not Allowed";\n    if (method && pathname && routeId) {\n      errorMessage = "You made a " + method.toUpperCase() + " request to \\"" + pathname + "\\" but " + ("did not provide an `action` for route \\"" + routeId + "\\", ") + "so there is no way to handle the request.";\n    } else if (method) {\n      errorMessage = "Invalid request method \\"" + method.toUpperCase() + "\\"";\n    }\n  }\n  return new ErrorResponseImpl(status || 500, statusText, new Error(errorMessage), true);\n}\n// Find any returned redirect errors, starting from the lowest match\nfunction findRedirect(results) {\n  for (var i = results.length - 1; i >= 0; i--) {\n    var result = results[i];\n    if (isRedirectResult(result)) {\n      return {\n        result: result,\n        idx: i\n      };\n    }\n  }\n}\nfunction stripHashFromPath(path) {\n  var parsedPath = typeof path === "string" ? parsePath(path) : path;\n  return createPath(_extends({}, parsedPath, {\n    hash: ""\n  }));\n}\nfunction isHashChangeOnly(a, b) {\n  if (a.pathname !== b.pathname || a.search !== b.search) {\n    return false;\n  }\n  if (a.hash === "") {\n    // /page -> /page#hash\n    return b.hash !== "";\n  } else if (a.hash === b.hash) {\n    // /page#hash -> /page#hash\n    return true;\n  } else if (b.hash !== "") {\n    // /page#hash -> /page#other\n    return true;\n  }\n  // If the hash is removed the browser will re-perform a request to the server\n  // /page#hash -> /page\n  return false;\n}\nfunction isDeferredResult(result) {\n  return result.type === ResultType.deferred;\n}\nfunction isErrorResult(result) {\n  return result.type === ResultType.error;\n}\nfunction isRedirectResult(result) {\n  return (result && result.type) === ResultType.redirect;\n}\nfunction isDeferredData(value) {\n  var deferred = value;\n  return deferred && _typeof(deferred) === "object" && _typeof(deferred.data) === "object" && typeof deferred.subscribe === "function" && typeof deferred.cancel === "function" && typeof deferred.resolveData === "function";\n}\nfunction isResponse(value) {\n  return value != null && typeof value.status === "number" && typeof value.statusText === "string" && _typeof(value.headers) === "object" && typeof value.body !== "undefined";\n}\nfunction isRedirectResponse(result) {\n  if (!isResponse(result)) {\n    return false;\n  }\n  var status = result.status;\n  var location = result.headers.get("Location");\n  return status >= 300 && status <= 399 && location != null;\n}\nfunction isQueryRouteResponse(obj) {\n  return obj && isResponse(obj.response) && (obj.type === ResultType.data || obj.type === ResultType.error);\n}\nfunction isValidMethod(method) {\n  return validRequestMethods.has(method.toLowerCase());\n}\nfunction isMutationMethod(method) {\n  return validMutationMethods.has(method.toLowerCase());\n}\nfunction resolveDeferredResults(_x74, _x75, _x76, _x77, _x78, _x79) {\n  return _resolveDeferredResults.apply(this, arguments);\n}\nfunction _resolveDeferredResults() {\n  _resolveDeferredResults = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(currentMatches, matchesToLoad, results, signals, isFetcher, currentLoaderData) {\n    var _loop, index;\n    return _regeneratorRuntime().wrap(function _callee17$(_context19) {\n      while (1) switch (_context19.prev = _context19.next) {\n        case 0:\n          _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop(index) {\n            var result, match, currentMatch, isRevalidatingLoader, signal;\n            return _regeneratorRuntime().wrap(function _loop$(_context18) {\n              while (1) switch (_context18.prev = _context18.next) {\n                case 0:\n                  result = results[index];\n                  match = matchesToLoad[index]; // If we don\'t have a match, then we can have a deferred result to do\n                  // anything with.  This is for revalidating fetchers where the route was\n                  // removed during HMR\n                  if (match) {\n                    _context18.next = 4;\n                    break;\n                  }\n                  return _context18.abrupt("return", 1);\n                case 4:\n                  currentMatch = currentMatches.find(function (m) {\n                    return m.route.id === match.route.id;\n                  });\n                  isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;\n                  if (!(isDeferredResult(result) && (isFetcher || isRevalidatingLoader))) {\n                    _context18.next = 11;\n                    break;\n                  }\n                  // Note: we do not have to touch activeDeferreds here since we race them\n                  // against the signal in resolveDeferredData and they\'ll get aborted\n                  // there if needed\n                  signal = signals[index];\n                  invariant(signal, "Expected an AbortSignal for revalidating fetcher deferred result");\n                  _context18.next = 11;\n                  return resolveDeferredData(result, signal, isFetcher).then(function (result) {\n                    if (result) {\n                      results[index] = result || results[index];\n                    }\n                  });\n                case 11:\n                case "end":\n                  return _context18.stop();\n              }\n            }, _loop);\n          });\n          index = 0;\n        case 2:\n          if (!(index < results.length)) {\n            _context19.next = 9;\n            break;\n          }\n          return _context19.delegateYield(_loop(index), "t0", 4);\n        case 4:\n          if (!_context19.t0) {\n            _context19.next = 6;\n            break;\n          }\n          return _context19.abrupt("continue", 6);\n        case 6:\n          index++;\n          _context19.next = 2;\n          break;\n        case 9:\n        case "end":\n          return _context19.stop();\n      }\n    }, _callee17);\n  }));\n  return _resolveDeferredResults.apply(this, arguments);\n}\nfunction resolveDeferredData(_x80, _x81, _x82) {\n  return _resolveDeferredData.apply(this, arguments);\n}\nfunction _resolveDeferredData() {\n  _resolveDeferredData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(result, signal, unwrap) {\n    var aborted;\n    return _regeneratorRuntime().wrap(function _callee18$(_context20) {\n      while (1) switch (_context20.prev = _context20.next) {\n        case 0:\n          if (unwrap === void 0) {\n            unwrap = false;\n          }\n          _context20.next = 3;\n          return result.deferredData.resolveData(signal);\n        case 3:\n          aborted = _context20.sent;\n          if (!aborted) {\n            _context20.next = 6;\n            break;\n          }\n          return _context20.abrupt("return");\n        case 6:\n          if (!unwrap) {\n            _context20.next = 14;\n            break;\n          }\n          _context20.prev = 7;\n          return _context20.abrupt("return", {\n            type: ResultType.data,\n            data: result.deferredData.unwrappedData\n          });\n        case 11:\n          _context20.prev = 11;\n          _context20.t0 = _context20["catch"](7);\n          return _context20.abrupt("return", {\n            type: ResultType.error,\n            error: _context20.t0\n          });\n        case 14:\n          return _context20.abrupt("return", {\n            type: ResultType.data,\n            data: result.deferredData.data\n          });\n        case 15:\n        case "end":\n          return _context20.stop();\n      }\n    }, _callee18, null, [[7, 11]]);\n  }));\n  return _resolveDeferredData.apply(this, arguments);\n}\nfunction hasNakedIndexQuery(search) {\n  return new URLSearchParams(search).getAll("index").some(function (v) {\n    return v === "";\n  });\n}\nfunction getTargetMatch(matches, location) {\n  var search = typeof location === "string" ? parsePath(location).search : location.search;\n  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || "")) {\n    // Return the leaf index route when index is present\n    return matches[matches.length - 1];\n  }\n  // Otherwise grab the deepest "path contributing" match (ignoring index and\n  // pathless layout routes)\n  var pathMatches = getPathContributingMatches(matches);\n  return pathMatches[pathMatches.length - 1];\n}\nfunction getSubmissionFromNavigation(navigation) {\n  var formMethod = navigation.formMethod,\n    formAction = navigation.formAction,\n    formEncType = navigation.formEncType,\n    text = navigation.text,\n    formData = navigation.formData,\n    json = navigation.json;\n  if (!formMethod || !formAction || !formEncType) {\n    return;\n  }\n  if (text != null) {\n    return {\n      formMethod: formMethod,\n      formAction: formAction,\n      formEncType: formEncType,\n      formData: undefined,\n      json: undefined,\n      text: text\n    };\n  } else if (formData != null) {\n    return {\n      formMethod: formMethod,\n      formAction: formAction,\n      formEncType: formEncType,\n      formData: formData,\n      json: undefined,\n      text: undefined\n    };\n  } else if (json !== undefined) {\n    return {\n      formMethod: formMethod,\n      formAction: formAction,\n      formEncType: formEncType,\n      formData: undefined,\n      json: json,\n      text: undefined\n    };\n  }\n}\nfunction getLoadingNavigation(location, submission) {\n  if (submission) {\n    var navigation = {\n      state: "loading",\n      location: location,\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text\n    };\n    return navigation;\n  } else {\n    var _navigation = {\n      state: "loading",\n      location: location,\n      formMethod: undefined,\n      formAction: undefined,\n      formEncType: undefined,\n      formData: undefined,\n      json: undefined,\n      text: undefined\n    };\n    return _navigation;\n  }\n}\nfunction getSubmittingNavigation(location, submission) {\n  var navigation = {\n    state: "submitting",\n    location: location,\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text\n  };\n  return navigation;\n}\nfunction getLoadingFetcher(submission, data) {\n  if (submission) {\n    var fetcher = {\n      state: "loading",\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text,\n      data: data\n    };\n    return fetcher;\n  } else {\n    var _fetcher = {\n      state: "loading",\n      formMethod: undefined,\n      formAction: undefined,\n      formEncType: undefined,\n      formData: undefined,\n      json: undefined,\n      text: undefined,\n      data: data\n    };\n    return _fetcher;\n  }\n}\nfunction getSubmittingFetcher(submission, existingFetcher) {\n  var fetcher = {\n    state: "submitting",\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text,\n    data: existingFetcher ? existingFetcher.data : undefined\n  };\n  return fetcher;\n}\nfunction getDoneFetcher(data) {\n  var fetcher = {\n    state: "idle",\n    formMethod: undefined,\n    formAction: undefined,\n    formEncType: undefined,\n    formData: undefined,\n    json: undefined,\n    text: undefined,\n    data: data\n  };\n  return fetcher;\n}\nfunction restoreAppliedTransitions(_window, transitions) {\n  try {\n    var sessionPositions = _window.sessionStorage.getItem(TRANSITIONS_STORAGE_KEY);\n    if (sessionPositions) {\n      var _json2 = JSON.parse(sessionPositions);\n      for (var _i = 0, _Object$entries = Object.entries(_json2 || {}); _i < _Object$entries.length; _i++) {\n        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n          k = _Object$entries$_i[0],\n          v = _Object$entries$_i[1];\n        if (v && Array.isArray(v)) {\n          transitions.set(k, new Set(v || []));\n        }\n      }\n    }\n  } catch (e) {\n    // no-op, use default empty object\n  }\n}\nfunction persistAppliedTransitions(_window, transitions) {\n  if (transitions.size > 0) {\n    var _json3 = {};\n    var _iterator9 = _createForOfIteratorHelper(transitions),\n      _step9;\n    try {\n      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n        var _step9$value = _slicedToArray(_step9.value, 2),\n          k = _step9$value[0],\n          v = _step9$value[1];\n        _json3[k] = _toConsumableArray(v);\n      }\n    } catch (err) {\n      _iterator9.e(err);\n    } finally {\n      _iterator9.f();\n    }\n    try {\n      _window.sessionStorage.setItem(TRANSITIONS_STORAGE_KEY, JSON.stringify(_json3));\n    } catch (error) {\n      warning(false, "Failed to save applied view transitions in sessionStorage (" + error + ").");\n    }\n  }\n}\n//#endregion\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUk7TUFDRm12QixPQUFPLENBQUNHLGNBQWMsQ0FBQ1EsT0FBTyxDQUM1QnBpQix1QkFBdUIsRUFDdkIzVyxJQUFJLENBQUNDLFNBQVMsQ0FBQ3lQLE1BQUksQ0FBQyxDQUNyQjtLQUNGLENBQUMsT0FBT3hLLEtBQUssRUFBRTtNQUNkcEYsT0FBTyxDQUNMLEtBQUssRUFDeUQsZ0VBQUFvRixLQUFLLE9BQUksQ0FDeEU7SUFDRjtFQUNGO0FBQ0g7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3F1aWwvLi4vaGlzdG9yeS50cz83MWY5Iiwid2VicGFjazovL3F1aWwvLi4vdXRpbHMudHM/YWMxMSIsIndlYnBhY2s6Ly9xdWlsLy4uL3JvdXRlci50cz9hNjQwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gVHlwZXMgYW5kIENvbnN0YW50c1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBBY3Rpb25zIHJlcHJlc2VudCB0aGUgdHlwZSBvZiBjaGFuZ2UgdG8gYSBsb2NhdGlvbiB2YWx1ZS5cbiAqL1xuZXhwb3J0IGVudW0gQWN0aW9uIHtcbiAgLyoqXG4gICAqIEEgUE9QIGluZGljYXRlcyBhIGNoYW5nZSB0byBhbiBhcmJpdHJhcnkgaW5kZXggaW4gdGhlIGhpc3Rvcnkgc3RhY2ssIHN1Y2hcbiAgICogYXMgYSBiYWNrIG9yIGZvcndhcmQgbmF2aWdhdGlvbi4gSXQgZG9lcyBub3QgZGVzY3JpYmUgdGhlIGRpcmVjdGlvbiBvZiB0aGVcbiAgICogbmF2aWdhdGlvbiwgb25seSB0aGF0IHRoZSBjdXJyZW50IGluZGV4IGNoYW5nZWQuXG4gICAqXG4gICAqIE5vdGU6IFRoaXMgaXMgdGhlIGRlZmF1bHQgYWN0aW9uIGZvciBuZXdseSBjcmVhdGVkIGhpc3Rvcnkgb2JqZWN0cy5cbiAgICovXG4gIFBvcCA9IFwiUE9QXCIsXG5cbiAgLyoqXG4gICAqIEEgUFVTSCBpbmRpY2F0ZXMgYSBuZXcgZW50cnkgYmVpbmcgYWRkZWQgdG8gdGhlIGhpc3Rvcnkgc3RhY2ssIHN1Y2ggYXMgd2hlblxuICAgKiBhIGxpbmsgaXMgY2xpY2tlZCBhbmQgYSBuZXcgcGFnZSBsb2Fkcy4gV2hlbiB0aGlzIGhhcHBlbnMsIGFsbCBzdWJzZXF1ZW50XG4gICAqIGVudHJpZXMgaW4gdGhlIHN0YWNrIGFyZSBsb3N0LlxuICAgKi9cbiAgUHVzaCA9IFwiUFVTSFwiLFxuXG4gIC8qKlxuICAgKiBBIFJFUExBQ0UgaW5kaWNhdGVzIHRoZSBlbnRyeSBhdCB0aGUgY3VycmVudCBpbmRleCBpbiB0aGUgaGlzdG9yeSBzdGFja1xuICAgKiBiZWluZyByZXBsYWNlZCBieSBhIG5ldyBvbmUuXG4gICAqL1xuICBSZXBsYWNlID0gXCJSRVBMQUNFXCIsXG59XG5cbi8qKlxuICogVGhlIHBhdGhuYW1lLCBzZWFyY2gsIGFuZCBoYXNoIHZhbHVlcyBvZiBhIFVSTC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQYXRoIHtcbiAgLyoqXG4gICAqIEEgVVJMIHBhdGhuYW1lLCBiZWdpbm5pbmcgd2l0aCBhIC8uXG4gICAqL1xuICBwYXRobmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBIFVSTCBzZWFyY2ggc3RyaW5nLCBiZWdpbm5pbmcgd2l0aCBhID8uXG4gICAqL1xuICBzZWFyY2g6IHN0cmluZztcblxuICAvKipcbiAgICogQSBVUkwgZnJhZ21lbnQgaWRlbnRpZmllciwgYmVnaW5uaW5nIHdpdGggYSAjLlxuICAgKi9cbiAgaGFzaDogc3RyaW5nO1xufVxuXG4vLyBUT0RPOiAodjcpIENoYW5nZSB0aGUgTG9jYXRpb24gZ2VuZXJpYyBkZWZhdWx0IGZyb20gYGFueWAgdG8gYHVua25vd25gIGFuZFxuLy8gcmVtb3ZlIFJlbWl4IGB1c2VMb2NhdGlvbmAgd3JhcHBlci5cblxuLyoqXG4gKiBBbiBlbnRyeSBpbiBhIGhpc3Rvcnkgc3RhY2suIEEgbG9jYXRpb24gY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlXG4gKiBVUkwgcGF0aCwgYXMgd2VsbCBhcyBwb3NzaWJseSBzb21lIGFyYml0cmFyeSBzdGF0ZSBhbmQgYSBrZXkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTG9jYXRpb248U3RhdGUgPSBhbnk+IGV4dGVuZHMgUGF0aCB7XG4gIC8qKlxuICAgKiBBIHZhbHVlIG9mIGFyYml0cmFyeSBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGxvY2F0aW9uLlxuICAgKi9cbiAgc3RhdGU6IFN0YXRlO1xuXG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBzdHJpbmcgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbG9jYXRpb24uIE1heSBiZSB1c2VkIHRvIHNhZmVseSBzdG9yZVxuICAgKiBhbmQgcmV0cmlldmUgZGF0YSBpbiBzb21lIG90aGVyIHN0b3JhZ2UgQVBJLCBsaWtlIGBsb2NhbFN0b3JhZ2VgLlxuICAgKlxuICAgKiBOb3RlOiBUaGlzIHZhbHVlIGlzIGFsd2F5cyBcImRlZmF1bHRcIiBvbiB0aGUgaW5pdGlhbCBsb2NhdGlvbi5cbiAgICovXG4gIGtleTogc3RyaW5nO1xufVxuXG4vKipcbiAqIEEgY2hhbmdlIHRvIHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFVwZGF0ZSB7XG4gIC8qKlxuICAgKiBUaGUgYWN0aW9uIHRoYXQgdHJpZ2dlcmVkIHRoZSBjaGFuZ2UuXG4gICAqL1xuICBhY3Rpb246IEFjdGlvbjtcblxuICAvKipcbiAgICogVGhlIG5ldyBsb2NhdGlvbi5cbiAgICovXG4gIGxvY2F0aW9uOiBMb2NhdGlvbjtcblxuICAvKipcbiAgICogVGhlIGRlbHRhIGJldHdlZW4gdGhpcyBsb2NhdGlvbiBhbmQgdGhlIGZvcm1lciBsb2NhdGlvbiBpbiB0aGUgaGlzdG9yeSBzdGFja1xuICAgKi9cbiAgZGVsdGE6IG51bWJlciB8IG51bGw7XG59XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIG5vdGlmaWNhdGlvbnMgYWJvdXQgbG9jYXRpb24gY2hhbmdlcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMaXN0ZW5lciB7XG4gICh1cGRhdGU6IFVwZGF0ZSk6IHZvaWQ7XG59XG5cbi8qKlxuICogRGVzY3JpYmVzIGEgbG9jYXRpb24gdGhhdCBpcyB0aGUgZGVzdGluYXRpb24gb2Ygc29tZSBuYXZpZ2F0aW9uLCBlaXRoZXIgdmlhXG4gKiBgaGlzdG9yeS5wdXNoYCBvciBgaGlzdG9yeS5yZXBsYWNlYC4gVGhpcyBtYXkgYmUgZWl0aGVyIGEgVVJMIG9yIHRoZSBwaWVjZXNcbiAqIG9mIGEgVVJMIHBhdGguXG4gKi9cbmV4cG9ydCB0eXBlIFRvID0gc3RyaW5nIHwgUGFydGlhbDxQYXRoPjtcblxuLyoqXG4gKiBBIGhpc3RvcnkgaXMgYW4gaW50ZXJmYWNlIHRvIHRoZSBuYXZpZ2F0aW9uIHN0YWNrLiBUaGUgaGlzdG9yeSBzZXJ2ZXMgYXMgdGhlXG4gKiBzb3VyY2Ugb2YgdHJ1dGggZm9yIHRoZSBjdXJyZW50IGxvY2F0aW9uLCBhcyB3ZWxsIGFzIHByb3ZpZGVzIGEgc2V0IG9mXG4gKiBtZXRob2RzIHRoYXQgbWF5IGJlIHVzZWQgdG8gY2hhbmdlIGl0LlxuICpcbiAqIEl0IGlzIHNpbWlsYXIgdG8gdGhlIERPTSdzIGB3aW5kb3cuaGlzdG9yeWAgb2JqZWN0LCBidXQgd2l0aCBhIHNtYWxsZXIsIG1vcmVcbiAqIGZvY3VzZWQgQVBJLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEhpc3Rvcnkge1xuICAvKipcbiAgICogVGhlIGxhc3QgYWN0aW9uIHRoYXQgbW9kaWZpZWQgdGhlIGN1cnJlbnQgbG9jYXRpb24uIFRoaXMgd2lsbCBhbHdheXMgYmVcbiAgICogQWN0aW9uLlBvcCB3aGVuIGEgaGlzdG9yeSBpbnN0YW5jZSBpcyBmaXJzdCBjcmVhdGVkLiBUaGlzIHZhbHVlIGlzIG11dGFibGUuXG4gICAqL1xuICByZWFkb25seSBhY3Rpb246IEFjdGlvbjtcblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgbG9jYXRpb24uIFRoaXMgdmFsdWUgaXMgbXV0YWJsZS5cbiAgICovXG4gIHJlYWRvbmx5IGxvY2F0aW9uOiBMb2NhdGlvbjtcblxuICAvKipcbiAgICogUmV0dXJucyBhIHZhbGlkIGhyZWYgZm9yIHRoZSBnaXZlbiBgdG9gIHZhbHVlIHRoYXQgbWF5IGJlIHVzZWQgYXNcbiAgICogdGhlIHZhbHVlIG9mIGFuIDxhIGhyZWY+IGF0dHJpYnV0ZS5cbiAgICpcbiAgICogQHBhcmFtIHRvIC0gVGhlIGRlc3RpbmF0aW9uIFVSTFxuICAgKi9cbiAgY3JlYXRlSHJlZih0bzogVG8pOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBVUkwgZm9yIHRoZSBnaXZlbiBgdG9gIHZhbHVlXG4gICAqXG4gICAqIEBwYXJhbSB0byAtIFRoZSBkZXN0aW5hdGlvbiBVUkxcbiAgICovXG4gIGNyZWF0ZVVSTCh0bzogVG8pOiBVUkw7XG5cbiAgLyoqXG4gICAqIEVuY29kZSBhIGxvY2F0aW9uIHRoZSBzYW1lIHdheSB3aW5kb3cuaGlzdG9yeSB3b3VsZCBkbyAobm8tb3AgZm9yIG1lbW9yeVxuICAgKiBoaXN0b3J5KSBzbyB3ZSBlbnN1cmUgb3VyIFBVU0gvUkVQTEFDRSBuYXZpZ2F0aW9ucyBmb3IgZGF0YSByb3V0ZXJzXG4gICAqIGJlaGF2ZSB0aGUgc2FtZSBhcyBQT1BcbiAgICpcbiAgICogQHBhcmFtIHRvIFVuZW5jb2RlZCBwYXRoXG4gICAqL1xuICBlbmNvZGVMb2NhdGlvbih0bzogVG8pOiBQYXRoO1xuXG4gIC8qKlxuICAgKiBQdXNoZXMgYSBuZXcgbG9jYXRpb24gb250byB0aGUgaGlzdG9yeSBzdGFjaywgaW5jcmVhc2luZyBpdHMgbGVuZ3RoIGJ5IG9uZS5cbiAgICogSWYgdGhlcmUgd2VyZSBhbnkgZW50cmllcyBpbiB0aGUgc3RhY2sgYWZ0ZXIgdGhlIGN1cnJlbnQgb25lLCB0aGV5IGFyZVxuICAgKiBsb3N0LlxuICAgKlxuICAgKiBAcGFyYW0gdG8gLSBUaGUgbmV3IFVSTFxuICAgKiBAcGFyYW0gc3RhdGUgLSBEYXRhIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBuZXcgbG9jYXRpb25cbiAgICovXG4gIHB1c2godG86IFRvLCBzdGF0ZT86IGFueSk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSBjdXJyZW50IGxvY2F0aW9uIGluIHRoZSBoaXN0b3J5IHN0YWNrIHdpdGggYSBuZXcgb25lLiAgVGhlXG4gICAqIGxvY2F0aW9uIHRoYXQgd2FzIHJlcGxhY2VkIHdpbGwgbm8gbG9uZ2VyIGJlIGF2YWlsYWJsZS5cbiAgICpcbiAgICogQHBhcmFtIHRvIC0gVGhlIG5ldyBVUkxcbiAgICogQHBhcmFtIHN0YXRlIC0gRGF0YSB0byBhc3NvY2lhdGUgd2l0aCB0aGUgbmV3IGxvY2F0aW9uXG4gICAqL1xuICByZXBsYWNlKHRvOiBUbywgc3RhdGU/OiBhbnkpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBOYXZpZ2F0ZXMgYG5gIGVudHJpZXMgYmFja3dhcmQvZm9yd2FyZCBpbiB0aGUgaGlzdG9yeSBzdGFjayByZWxhdGl2ZSB0byB0aGVcbiAgICogY3VycmVudCBpbmRleC4gRm9yIGV4YW1wbGUsIGEgXCJiYWNrXCIgbmF2aWdhdGlvbiB3b3VsZCB1c2UgZ28oLTEpLlxuICAgKlxuICAgKiBAcGFyYW0gZGVsdGEgLSBUaGUgZGVsdGEgaW4gdGhlIHN0YWNrIGluZGV4XG4gICAqL1xuICBnbyhkZWx0YTogbnVtYmVyKTogdm9pZDtcblxuICAvKipcbiAgICogU2V0cyB1cCBhIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlIGN1cnJlbnQgbG9jYXRpb25cbiAgICogY2hhbmdlcy5cbiAgICpcbiAgICogQHBhcmFtIGxpc3RlbmVyIC0gQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGxvY2F0aW9uIGNoYW5nZXNcbiAgICogQHJldHVybnMgdW5saXN0ZW4gLSBBIGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gc3RvcCBsaXN0ZW5pbmdcbiAgICovXG4gIGxpc3RlbihsaXN0ZW5lcjogTGlzdGVuZXIpOiAoKSA9PiB2b2lkO1xufVxuXG50eXBlIEhpc3RvcnlTdGF0ZSA9IHtcbiAgdXNyOiBhbnk7XG4gIGtleT86IHN0cmluZztcbiAgaWR4OiBudW1iZXI7XG59O1xuXG5jb25zdCBQb3BTdGF0ZUV2ZW50VHlwZSA9IFwicG9wc3RhdGVcIjtcbi8vI2VuZHJlZ2lvblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIE1lbW9yeSBIaXN0b3J5XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEEgdXNlci1zdXBwbGllZCBvYmplY3QgdGhhdCBkZXNjcmliZXMgYSBsb2NhdGlvbi4gVXNlZCB3aGVuIHByb3ZpZGluZ1xuICogZW50cmllcyB0byBgY3JlYXRlTWVtb3J5SGlzdG9yeWAgdmlhIGl0cyBgaW5pdGlhbEVudHJpZXNgIG9wdGlvbi5cbiAqL1xuZXhwb3J0IHR5cGUgSW5pdGlhbEVudHJ5ID0gc3RyaW5nIHwgUGFydGlhbDxMb2NhdGlvbj47XG5cbmV4cG9ydCB0eXBlIE1lbW9yeUhpc3RvcnlPcHRpb25zID0ge1xuICBpbml0aWFsRW50cmllcz86IEluaXRpYWxFbnRyeVtdO1xuICBpbml0aWFsSW5kZXg/OiBudW1iZXI7XG4gIHY1Q29tcGF0PzogYm9vbGVhbjtcbn07XG5cbi8qKlxuICogQSBtZW1vcnkgaGlzdG9yeSBzdG9yZXMgbG9jYXRpb25zIGluIG1lbW9yeS4gVGhpcyBpcyB1c2VmdWwgaW4gc3RhdGVmdWxcbiAqIGVudmlyb25tZW50cyB3aGVyZSB0aGVyZSBpcyBubyB3ZWIgYnJvd3Nlciwgc3VjaCBhcyBub2RlIHRlc3RzIG9yIFJlYWN0XG4gKiBOYXRpdmUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWVtb3J5SGlzdG9yeSBleHRlbmRzIEhpc3Rvcnkge1xuICAvKipcbiAgICogVGhlIGN1cnJlbnQgaW5kZXggaW4gdGhlIGhpc3Rvcnkgc3RhY2suXG4gICAqL1xuICByZWFkb25seSBpbmRleDogbnVtYmVyO1xufVxuXG4vKipcbiAqIE1lbW9yeSBoaXN0b3J5IHN0b3JlcyB0aGUgY3VycmVudCBsb2NhdGlvbiBpbiBtZW1vcnkuIEl0IGlzIGRlc2lnbmVkIGZvciB1c2VcbiAqIGluIHN0YXRlZnVsIG5vbi1icm93c2VyIGVudmlyb25tZW50cyBsaWtlIHRlc3RzIGFuZCBSZWFjdCBOYXRpdmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNZW1vcnlIaXN0b3J5KFxuICBvcHRpb25zOiBNZW1vcnlIaXN0b3J5T3B0aW9ucyA9IHt9XG4pOiBNZW1vcnlIaXN0b3J5IHtcbiAgbGV0IHsgaW5pdGlhbEVudHJpZXMgPSBbXCIvXCJdLCBpbml0aWFsSW5kZXgsIHY1Q29tcGF0ID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gIGxldCBlbnRyaWVzOiBMb2NhdGlvbltdOyAvLyBEZWNsYXJlIHNvIHdlIGNhbiBhY2Nlc3MgZnJvbSBjcmVhdGVNZW1vcnlMb2NhdGlvblxuICBlbnRyaWVzID0gaW5pdGlhbEVudHJpZXMubWFwKChlbnRyeSwgaW5kZXgpID0+XG4gICAgY3JlYXRlTWVtb3J5TG9jYXRpb24oXG4gICAgICBlbnRyeSxcbiAgICAgIHR5cGVvZiBlbnRyeSA9PT0gXCJzdHJpbmdcIiA/IG51bGwgOiBlbnRyeS5zdGF0ZSxcbiAgICAgIGluZGV4ID09PSAwID8gXCJkZWZhdWx0XCIgOiB1bmRlZmluZWRcbiAgICApXG4gICk7XG4gIGxldCBpbmRleCA9IGNsYW1wSW5kZXgoXG4gICAgaW5pdGlhbEluZGV4ID09IG51bGwgPyBlbnRyaWVzLmxlbmd0aCAtIDEgOiBpbml0aWFsSW5kZXhcbiAgKTtcbiAgbGV0IGFjdGlvbiA9IEFjdGlvbi5Qb3A7XG4gIGxldCBsaXN0ZW5lcjogTGlzdGVuZXIgfCBudWxsID0gbnVsbDtcblxuICBmdW5jdGlvbiBjbGFtcEluZGV4KG46IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG4sIDApLCBlbnRyaWVzLmxlbmd0aCAtIDEpO1xuICB9XG4gIGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbigpOiBMb2NhdGlvbiB7XG4gICAgcmV0dXJuIGVudHJpZXNbaW5kZXhdO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUxvY2F0aW9uKFxuICAgIHRvOiBUbyxcbiAgICBzdGF0ZTogYW55ID0gbnVsbCxcbiAgICBrZXk/OiBzdHJpbmdcbiAgKTogTG9jYXRpb24ge1xuICAgIGxldCBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKFxuICAgICAgZW50cmllcyA/IGdldEN1cnJlbnRMb2NhdGlvbigpLnBhdGhuYW1lIDogXCIvXCIsXG4gICAgICB0byxcbiAgICAgIHN0YXRlLFxuICAgICAga2V5XG4gICAgKTtcbiAgICB3YXJuaW5nKFxuICAgICAgbG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApID09PSBcIi9cIixcbiAgICAgIGByZWxhdGl2ZSBwYXRobmFtZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gbWVtb3J5IGhpc3Rvcnk6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgIHRvXG4gICAgICApfWBcbiAgICApO1xuICAgIHJldHVybiBsb2NhdGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUhyZWYodG86IFRvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG4gIH1cblxuICBsZXQgaGlzdG9yeTogTWVtb3J5SGlzdG9yeSA9IHtcbiAgICBnZXQgaW5kZXgoKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSxcbiAgICBnZXQgYWN0aW9uKCkge1xuICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICB9LFxuICAgIGdldCBsb2NhdGlvbigpIHtcbiAgICAgIHJldHVybiBnZXRDdXJyZW50TG9jYXRpb24oKTtcbiAgICB9LFxuICAgIGNyZWF0ZUhyZWYsXG4gICAgY3JlYXRlVVJMKHRvKSB7XG4gICAgICByZXR1cm4gbmV3IFVSTChjcmVhdGVIcmVmKHRvKSwgXCJodHRwOi8vbG9jYWxob3N0XCIpO1xuICAgIH0sXG4gICAgZW5jb2RlTG9jYXRpb24odG86IFRvKSB7XG4gICAgICBsZXQgcGF0aCA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aCh0bykgOiB0bztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGhuYW1lOiBwYXRoLnBhdGhuYW1lIHx8IFwiXCIsXG4gICAgICAgIHNlYXJjaDogcGF0aC5zZWFyY2ggfHwgXCJcIixcbiAgICAgICAgaGFzaDogcGF0aC5oYXNoIHx8IFwiXCIsXG4gICAgICB9O1xuICAgIH0sXG4gICAgcHVzaCh0bywgc3RhdGUpIHtcbiAgICAgIGFjdGlvbiA9IEFjdGlvbi5QdXNoO1xuICAgICAgbGV0IG5leHRMb2NhdGlvbiA9IGNyZWF0ZU1lbW9yeUxvY2F0aW9uKHRvLCBzdGF0ZSk7XG4gICAgICBpbmRleCArPSAxO1xuICAgICAgZW50cmllcy5zcGxpY2UoaW5kZXgsIGVudHJpZXMubGVuZ3RoLCBuZXh0TG9jYXRpb24pO1xuICAgICAgaWYgKHY1Q29tcGF0ICYmIGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVyKHsgYWN0aW9uLCBsb2NhdGlvbjogbmV4dExvY2F0aW9uLCBkZWx0YTogMSB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlcGxhY2UodG8sIHN0YXRlKSB7XG4gICAgICBhY3Rpb24gPSBBY3Rpb24uUmVwbGFjZTtcbiAgICAgIGxldCBuZXh0TG9jYXRpb24gPSBjcmVhdGVNZW1vcnlMb2NhdGlvbih0bywgc3RhdGUpO1xuICAgICAgZW50cmllc1tpbmRleF0gPSBuZXh0TG9jYXRpb247XG4gICAgICBpZiAodjVDb21wYXQgJiYgbGlzdGVuZXIpIHtcbiAgICAgICAgbGlzdGVuZXIoeyBhY3Rpb24sIGxvY2F0aW9uOiBuZXh0TG9jYXRpb24sIGRlbHRhOiAwIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ28oZGVsdGEpIHtcbiAgICAgIGFjdGlvbiA9IEFjdGlvbi5Qb3A7XG4gICAgICBsZXQgbmV4dEluZGV4ID0gY2xhbXBJbmRleChpbmRleCArIGRlbHRhKTtcbiAgICAgIGxldCBuZXh0TG9jYXRpb24gPSBlbnRyaWVzW25leHRJbmRleF07XG4gICAgICBpbmRleCA9IG5leHRJbmRleDtcbiAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lcih7IGFjdGlvbiwgbG9jYXRpb246IG5leHRMb2NhdGlvbiwgZGVsdGEgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBsaXN0ZW4oZm46IExpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lciA9IGZuO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgbGlzdGVuZXIgPSBudWxsO1xuICAgICAgfTtcbiAgICB9LFxuICB9O1xuXG4gIHJldHVybiBoaXN0b3J5O1xufVxuLy8jZW5kcmVnaW9uXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gQnJvd3NlciBIaXN0b3J5XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEEgYnJvd3NlciBoaXN0b3J5IHN0b3JlcyB0aGUgY3VycmVudCBsb2NhdGlvbiBpbiByZWd1bGFyIFVSTHMgaW4gYSB3ZWJcbiAqIGJyb3dzZXIgZW52aXJvbm1lbnQuIFRoaXMgaXMgdGhlIHN0YW5kYXJkIGZvciBtb3N0IHdlYiBhcHBzIGFuZCBwcm92aWRlcyB0aGVcbiAqIGNsZWFuZXN0IFVSTHMgdGhlIGJyb3dzZXIncyBhZGRyZXNzIGJhci5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vaGlzdG9yeS90cmVlL21haW4vZG9jcy9hcGktcmVmZXJlbmNlLm1kI2Jyb3dzZXJoaXN0b3J5XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQnJvd3Nlckhpc3RvcnkgZXh0ZW5kcyBVcmxIaXN0b3J5IHt9XG5cbmV4cG9ydCB0eXBlIEJyb3dzZXJIaXN0b3J5T3B0aW9ucyA9IFVybEhpc3RvcnlPcHRpb25zO1xuXG4vKipcbiAqIEJyb3dzZXIgaGlzdG9yeSBzdG9yZXMgdGhlIGxvY2F0aW9uIGluIHJlZ3VsYXIgVVJMcy4gVGhpcyBpcyB0aGUgc3RhbmRhcmQgZm9yXG4gKiBtb3N0IHdlYiBhcHBzLCBidXQgaXQgcmVxdWlyZXMgc29tZSBjb25maWd1cmF0aW9uIG9uIHRoZSBzZXJ2ZXIgdG8gZW5zdXJlIHlvdVxuICogc2VydmUgdGhlIHNhbWUgYXBwIGF0IG11bHRpcGxlIFVSTHMuXG4gKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL2hpc3RvcnkvdHJlZS9tYWluL2RvY3MvYXBpLXJlZmVyZW5jZS5tZCNjcmVhdGVicm93c2VyaGlzdG9yeVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQnJvd3Nlckhpc3RvcnkoXG4gIG9wdGlvbnM6IEJyb3dzZXJIaXN0b3J5T3B0aW9ucyA9IHt9XG4pOiBCcm93c2VySGlzdG9yeSB7XG4gIGZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJMb2NhdGlvbihcbiAgICB3aW5kb3c6IFdpbmRvdyxcbiAgICBnbG9iYWxIaXN0b3J5OiBXaW5kb3dbXCJoaXN0b3J5XCJdXG4gICkge1xuICAgIGxldCB7IHBhdGhuYW1lLCBzZWFyY2gsIGhhc2ggfSA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICByZXR1cm4gY3JlYXRlTG9jYXRpb24oXG4gICAgICBcIlwiLFxuICAgICAgeyBwYXRobmFtZSwgc2VhcmNoLCBoYXNoIH0sXG4gICAgICAvLyBzdGF0ZSBkZWZhdWx0cyB0byBgbnVsbGAgYmVjYXVzZSBgd2luZG93Lmhpc3Rvcnkuc3RhdGVgIGRvZXNcbiAgICAgIChnbG9iYWxIaXN0b3J5LnN0YXRlICYmIGdsb2JhbEhpc3Rvcnkuc3RhdGUudXNyKSB8fCBudWxsLFxuICAgICAgKGdsb2JhbEhpc3Rvcnkuc3RhdGUgJiYgZ2xvYmFsSGlzdG9yeS5zdGF0ZS5rZXkpIHx8IFwiZGVmYXVsdFwiXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJIcmVmKHdpbmRvdzogV2luZG93LCB0bzogVG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gdG8gOiBjcmVhdGVQYXRoKHRvKTtcbiAgfVxuXG4gIHJldHVybiBnZXRVcmxCYXNlZEhpc3RvcnkoXG4gICAgY3JlYXRlQnJvd3NlckxvY2F0aW9uLFxuICAgIGNyZWF0ZUJyb3dzZXJIcmVmLFxuICAgIG51bGwsXG4gICAgb3B0aW9uc1xuICApO1xufVxuLy8jZW5kcmVnaW9uXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gSGFzaCBIaXN0b3J5XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEEgaGFzaCBoaXN0b3J5IHN0b3JlcyB0aGUgY3VycmVudCBsb2NhdGlvbiBpbiB0aGUgZnJhZ21lbnQgaWRlbnRpZmllciBwb3J0aW9uXG4gKiBvZiB0aGUgVVJMIGluIGEgd2ViIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gKlxuICogVGhpcyBpcyBpZGVhbCBmb3IgYXBwcyB0aGF0IGRvIG5vdCBjb250cm9sIHRoZSBzZXJ2ZXIgZm9yIHNvbWUgcmVhc29uXG4gKiAoYmVjYXVzZSB0aGUgZnJhZ21lbnQgaWRlbnRpZmllciBpcyBuZXZlciBzZW50IHRvIHRoZSBzZXJ2ZXIpLCBpbmNsdWRpbmcgc29tZVxuICogc2hhcmVkIGhvc3RpbmcgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IHByb3ZpZGUgZmluZS1ncmFpbmVkIGNvbnRyb2xzIG92ZXJcbiAqIHdoaWNoIHBhZ2VzIGFyZSBzZXJ2ZWQgYXQgd2hpY2ggVVJMcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vaGlzdG9yeS90cmVlL21haW4vZG9jcy9hcGktcmVmZXJlbmNlLm1kI2hhc2hoaXN0b3J5XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSGFzaEhpc3RvcnkgZXh0ZW5kcyBVcmxIaXN0b3J5IHt9XG5cbmV4cG9ydCB0eXBlIEhhc2hIaXN0b3J5T3B0aW9ucyA9IFVybEhpc3RvcnlPcHRpb25zO1xuXG4vKipcbiAqIEhhc2ggaGlzdG9yeSBzdG9yZXMgdGhlIGxvY2F0aW9uIGluIHdpbmRvdy5sb2NhdGlvbi5oYXNoLiBUaGlzIG1ha2VzIGl0IGlkZWFsXG4gKiBmb3Igc2l0dWF0aW9ucyB3aGVyZSB5b3UgZG9uJ3Qgd2FudCB0byBzZW5kIHRoZSBsb2NhdGlvbiB0byB0aGUgc2VydmVyIGZvclxuICogc29tZSByZWFzb24sIGVpdGhlciBiZWNhdXNlIHlvdSBkbyBjYW5ub3QgY29uZmlndXJlIGl0IG9yIHRoZSBVUkwgc3BhY2UgaXNcbiAqIHJlc2VydmVkIGZvciBzb21ldGhpbmcgZWxzZS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vaGlzdG9yeS90cmVlL21haW4vZG9jcy9hcGktcmVmZXJlbmNlLm1kI2NyZWF0ZWhhc2hoaXN0b3J5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIYXNoSGlzdG9yeShcbiAgb3B0aW9uczogSGFzaEhpc3RvcnlPcHRpb25zID0ge31cbik6IEhhc2hIaXN0b3J5IHtcbiAgZnVuY3Rpb24gY3JlYXRlSGFzaExvY2F0aW9uKFxuICAgIHdpbmRvdzogV2luZG93LFxuICAgIGdsb2JhbEhpc3Rvcnk6IFdpbmRvd1tcImhpc3RvcnlcIl1cbiAgKSB7XG4gICAgbGV0IHtcbiAgICAgIHBhdGhuYW1lID0gXCIvXCIsXG4gICAgICBzZWFyY2ggPSBcIlwiLFxuICAgICAgaGFzaCA9IFwiXCIsXG4gICAgfSA9IHBhcnNlUGF0aCh3aW5kb3cubG9jYXRpb24uaGFzaC5zdWJzdHIoMSkpO1xuXG4gICAgLy8gSGFzaCBVUkwgc2hvdWxkIGFsd2F5cyBoYXZlIGEgbGVhZGluZyAvIGp1c3QgbGlrZSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWVcbiAgICAvLyBkb2VzLCBzbyBpZiBhbiBhcHAgZW5kcyB1cCBhdCBhIHJvdXRlIGxpa2UgLyNzb21ldGhpbmcgdGhlbiB3ZSBhZGQgYVxuICAgIC8vIGxlYWRpbmcgc2xhc2ggc28gYWxsIG9mIG91ciBwYXRoLW1hdGNoaW5nIGJlaGF2ZXMgdGhlIHNhbWUgYXMgaWYgaXQgd291bGRcbiAgICAvLyBpbiBhIGJyb3dzZXIgcm91dGVyLiAgVGhpcyBpcyBwYXJ0aWN1bGFybHkgaW1wb3J0YW50IHdoZW4gdGhlcmUgZXhpc3RzIGFcbiAgICAvLyByb290IHNwbGF0IHJvdXRlICg8Um91dGUgcGF0aD1cIipcIj4pIHNpbmNlIHRoYXQgbWF0Y2hlcyBpbnRlcm5hbGx5IGFnYWluc3RcbiAgICAvLyBcIi8qXCIgYW5kIHdlJ2QgZXhwZWN0IC8jc29tZXRoaW5nIHRvIDQwNCBpbiBhIGhhc2ggcm91dGVyIGFwcC5cbiAgICBpZiAoIXBhdGhuYW1lLnN0YXJ0c1dpdGgoXCIvXCIpICYmICFwYXRobmFtZS5zdGFydHNXaXRoKFwiLlwiKSkge1xuICAgICAgcGF0aG5hbWUgPSBcIi9cIiArIHBhdGhuYW1lO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVMb2NhdGlvbihcbiAgICAgIFwiXCIsXG4gICAgICB7IHBhdGhuYW1lLCBzZWFyY2gsIGhhc2ggfSxcbiAgICAgIC8vIHN0YXRlIGRlZmF1bHRzIHRvIGBudWxsYCBiZWNhdXNlIGB3aW5kb3cuaGlzdG9yeS5zdGF0ZWAgZG9lc1xuICAgICAgKGdsb2JhbEhpc3Rvcnkuc3RhdGUgJiYgZ2xvYmFsSGlzdG9yeS5zdGF0ZS51c3IpIHx8IG51bGwsXG4gICAgICAoZ2xvYmFsSGlzdG9yeS5zdGF0ZSAmJiBnbG9iYWxIaXN0b3J5LnN0YXRlLmtleSkgfHwgXCJkZWZhdWx0XCJcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSGFzaEhyZWYod2luZG93OiBXaW5kb3csIHRvOiBUbykge1xuICAgIGxldCBiYXNlID0gd2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJiYXNlXCIpO1xuICAgIGxldCBocmVmID0gXCJcIjtcblxuICAgIGlmIChiYXNlICYmIGJhc2UuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSkge1xuICAgICAgbGV0IHVybCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICAgICAgbGV0IGhhc2hJbmRleCA9IHVybC5pbmRleE9mKFwiI1wiKTtcbiAgICAgIGhyZWYgPSBoYXNoSW5kZXggPT09IC0xID8gdXJsIDogdXJsLnNsaWNlKDAsIGhhc2hJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhyZWYgKyBcIiNcIiArICh0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyB0byA6IGNyZWF0ZVBhdGgodG8pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlSGFzaExvY2F0aW9uKGxvY2F0aW9uOiBMb2NhdGlvbiwgdG86IFRvKSB7XG4gICAgd2FybmluZyhcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gXCIvXCIsXG4gICAgICBgcmVsYXRpdmUgcGF0aG5hbWVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIGhhc2ggaGlzdG9yeS5wdXNoKCR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgIHRvXG4gICAgICApfSlgXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBnZXRVcmxCYXNlZEhpc3RvcnkoXG4gICAgY3JlYXRlSGFzaExvY2F0aW9uLFxuICAgIGNyZWF0ZUhhc2hIcmVmLFxuICAgIHZhbGlkYXRlSGFzaExvY2F0aW9uLFxuICAgIG9wdGlvbnNcbiAgKTtcbn1cbi8vI2VuZHJlZ2lvblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIFVUSUxTXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZhcmlhbnQodmFsdWU6IGJvb2xlYW4sIG1lc3NhZ2U/OiBzdHJpbmcpOiBhc3NlcnRzIHZhbHVlO1xuZXhwb3J0IGZ1bmN0aW9uIGludmFyaWFudDxUPihcbiAgdmFsdWU6IFQgfCBudWxsIHwgdW5kZWZpbmVkLFxuICBtZXNzYWdlPzogc3RyaW5nXG4pOiBhc3NlcnRzIHZhbHVlIGlzIFQ7XG5leHBvcnQgZnVuY3Rpb24gaW52YXJpYW50KHZhbHVlOiBhbnksIG1lc3NhZ2U/OiBzdHJpbmcpIHtcbiAgaWYgKHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdhcm5pbmcoY29uZDogYW55LCBtZXNzYWdlOiBzdHJpbmcpIHtcbiAgaWYgKCFjb25kKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIpIGNvbnNvbGUud2FybihtZXNzYWdlKTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBXZWxjb21lIHRvIGRlYnVnZ2luZyBoaXN0b3J5IVxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgZXJyb3IgaXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2UsIHNvIHlvdSBjYW4gbW9yZSBlYXNpbHlcbiAgICAgIC8vIGZpbmQgdGhlIHNvdXJjZSBmb3IgYSB3YXJuaW5nIHRoYXQgYXBwZWFycyBpbiB0aGUgY29uc29sZSBieVxuICAgICAgLy8gZW5hYmxpbmcgXCJwYXVzZSBvbiBleGNlcHRpb25zXCIgaW4geW91ciBKYXZhU2NyaXB0IGRlYnVnZ2VyLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOCk7XG59XG5cbi8qKlxuICogRm9yIGJyb3dzZXItYmFzZWQgaGlzdG9yaWVzLCB3ZSBjb21iaW5lIHRoZSBzdGF0ZSBhbmQga2V5IGludG8gYW4gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGdldEhpc3RvcnlTdGF0ZShsb2NhdGlvbjogTG9jYXRpb24sIGluZGV4OiBudW1iZXIpOiBIaXN0b3J5U3RhdGUge1xuICByZXR1cm4ge1xuICAgIHVzcjogbG9jYXRpb24uc3RhdGUsXG4gICAga2V5OiBsb2NhdGlvbi5rZXksXG4gICAgaWR4OiBpbmRleCxcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgTG9jYXRpb24gb2JqZWN0IHdpdGggYSB1bmlxdWUga2V5IGZyb20gdGhlIGdpdmVuIFBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKFxuICBjdXJyZW50OiBzdHJpbmcgfCBMb2NhdGlvbixcbiAgdG86IFRvLFxuICBzdGF0ZTogYW55ID0gbnVsbCxcbiAga2V5Pzogc3RyaW5nXG4pOiBSZWFkb25seTxMb2NhdGlvbj4ge1xuICBsZXQgbG9jYXRpb246IFJlYWRvbmx5PExvY2F0aW9uPiA9IHtcbiAgICBwYXRobmFtZTogdHlwZW9mIGN1cnJlbnQgPT09IFwic3RyaW5nXCIgPyBjdXJyZW50IDogY3VycmVudC5wYXRobmFtZSxcbiAgICBzZWFyY2g6IFwiXCIsXG4gICAgaGFzaDogXCJcIixcbiAgICAuLi4odHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHRvKSA6IHRvKSxcbiAgICBzdGF0ZSxcbiAgICAvLyBUT0RPOiBUaGlzIGNvdWxkIGJlIGNsZWFuZWQgdXAuICBwdXNoL3JlcGxhY2Ugc2hvdWxkIHByb2JhYmx5IGp1c3QgdGFrZVxuICAgIC8vIGZ1bGwgTG9jYXRpb25zIG5vdyBhbmQgYXZvaWQgdGhlIG5lZWQgdG8gcnVuIHRocm91Z2ggdGhpcyBmbG93IGF0IGFsbFxuICAgIC8vIEJ1dCB0aGF0J3MgYSBwcmV0dHkgYmlnIHJlZmFjdG9yIHRvIHRoZSBjdXJyZW50IHRlc3Qgc3VpdGUgc28gZ29pbmcgdG9cbiAgICAvLyBrZWVwIGFzIGlzIGZvciB0aGUgdGltZSBiZWluZyBhbmQganVzdCBsZXQgYW55IGluY29taW5nIGtleXMgdGFrZSBwcmVjZWRlbmNlXG4gICAga2V5OiAodG8gJiYgKHRvIGFzIExvY2F0aW9uKS5rZXkpIHx8IGtleSB8fCBjcmVhdGVLZXkoKSxcbiAgfTtcbiAgcmV0dXJuIGxvY2F0aW9uO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzdHJpbmcgVVJMIHBhdGggZnJvbSB0aGUgZ2l2ZW4gcGF0aG5hbWUsIHNlYXJjaCwgYW5kIGhhc2ggY29tcG9uZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVBhdGgoe1xuICBwYXRobmFtZSA9IFwiL1wiLFxuICBzZWFyY2ggPSBcIlwiLFxuICBoYXNoID0gXCJcIixcbn06IFBhcnRpYWw8UGF0aD4pIHtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2ggIT09IFwiP1wiKVxuICAgIHBhdGhuYW1lICs9IHNlYXJjaC5jaGFyQXQoMCkgPT09IFwiP1wiID8gc2VhcmNoIDogXCI/XCIgKyBzZWFyY2g7XG4gIGlmIChoYXNoICYmIGhhc2ggIT09IFwiI1wiKVxuICAgIHBhdGhuYW1lICs9IGhhc2guY2hhckF0KDApID09PSBcIiNcIiA/IGhhc2ggOiBcIiNcIiArIGhhc2g7XG4gIHJldHVybiBwYXRobmFtZTtcbn1cblxuLyoqXG4gKiBQYXJzZXMgYSBzdHJpbmcgVVJMIHBhdGggaW50byBpdHMgc2VwYXJhdGUgcGF0aG5hbWUsIHNlYXJjaCwgYW5kIGhhc2ggY29tcG9uZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoOiBzdHJpbmcpOiBQYXJ0aWFsPFBhdGg+IHtcbiAgbGV0IHBhcnNlZFBhdGg6IFBhcnRpYWw8UGF0aD4gPSB7fTtcblxuICBpZiAocGF0aCkge1xuICAgIGxldCBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoXCIjXCIpO1xuICAgIGlmIChoYXNoSW5kZXggPj0gMCkge1xuICAgICAgcGFyc2VkUGF0aC5oYXNoID0gcGF0aC5zdWJzdHIoaGFzaEluZGV4KTtcbiAgICAgIHBhdGggPSBwYXRoLnN1YnN0cigwLCBoYXNoSW5kZXgpO1xuICAgIH1cblxuICAgIGxldCBzZWFyY2hJbmRleCA9IHBhdGguaW5kZXhPZihcIj9cIik7XG4gICAgaWYgKHNlYXJjaEluZGV4ID49IDApIHtcbiAgICAgIHBhcnNlZFBhdGguc2VhcmNoID0gcGF0aC5zdWJzdHIoc2VhcmNoSW5kZXgpO1xuICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKDAsIHNlYXJjaEluZGV4KTtcbiAgICB9XG5cbiAgICBpZiAocGF0aCkge1xuICAgICAgcGFyc2VkUGF0aC5wYXRobmFtZSA9IHBhdGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnNlZFBhdGg7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXJsSGlzdG9yeSBleHRlbmRzIEhpc3Rvcnkge31cblxuZXhwb3J0IHR5cGUgVXJsSGlzdG9yeU9wdGlvbnMgPSB7XG4gIHdpbmRvdz86IFdpbmRvdztcbiAgdjVDb21wYXQ/OiBib29sZWFuO1xufTtcblxuZnVuY3Rpb24gZ2V0VXJsQmFzZWRIaXN0b3J5KFxuICBnZXRMb2NhdGlvbjogKHdpbmRvdzogV2luZG93LCBnbG9iYWxIaXN0b3J5OiBXaW5kb3dbXCJoaXN0b3J5XCJdKSA9PiBMb2NhdGlvbixcbiAgY3JlYXRlSHJlZjogKHdpbmRvdzogV2luZG93LCB0bzogVG8pID0+IHN0cmluZyxcbiAgdmFsaWRhdGVMb2NhdGlvbjogKChsb2NhdGlvbjogTG9jYXRpb24sIHRvOiBUbykgPT4gdm9pZCkgfCBudWxsLFxuICBvcHRpb25zOiBVcmxIaXN0b3J5T3B0aW9ucyA9IHt9XG4pOiBVcmxIaXN0b3J5IHtcbiAgbGV0IHsgd2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXchLCB2NUNvbXBhdCA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICBsZXQgZ2xvYmFsSGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuICBsZXQgYWN0aW9uID0gQWN0aW9uLlBvcDtcbiAgbGV0IGxpc3RlbmVyOiBMaXN0ZW5lciB8IG51bGwgPSBudWxsO1xuXG4gIGxldCBpbmRleCA9IGdldEluZGV4KCkhO1xuICAvLyBJbmRleCBzaG91bGQgb25seSBiZSBudWxsIHdoZW4gd2UgaW5pdGlhbGl6ZS4gSWYgbm90LCBpdCdzIGJlY2F1c2UgdGhlXG4gIC8vIHVzZXIgY2FsbGVkIGhpc3RvcnkucHVzaFN0YXRlIG9yIGhpc3RvcnkucmVwbGFjZVN0YXRlIGRpcmVjdGx5LCBpbiB3aGljaFxuICAvLyBjYXNlIHdlIHNob3VsZCBsb2cgYSB3YXJuaW5nIGFzIGl0IHdpbGwgcmVzdWx0IGluIGJ1Z3MuXG4gIGlmIChpbmRleCA9PSBudWxsKSB7XG4gICAgaW5kZXggPSAwO1xuICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKHsgLi4uZ2xvYmFsSGlzdG9yeS5zdGF0ZSwgaWR4OiBpbmRleCB9LCBcIlwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEluZGV4KCk6IG51bWJlciB7XG4gICAgbGV0IHN0YXRlID0gZ2xvYmFsSGlzdG9yeS5zdGF0ZSB8fCB7IGlkeDogbnVsbCB9O1xuICAgIHJldHVybiBzdGF0ZS5pZHg7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVQb3AoKSB7XG4gICAgYWN0aW9uID0gQWN0aW9uLlBvcDtcbiAgICBsZXQgbmV4dEluZGV4ID0gZ2V0SW5kZXgoKTtcbiAgICBsZXQgZGVsdGEgPSBuZXh0SW5kZXggPT0gbnVsbCA/IG51bGwgOiBuZXh0SW5kZXggLSBpbmRleDtcbiAgICBpbmRleCA9IG5leHRJbmRleDtcbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIGxpc3RlbmVyKHsgYWN0aW9uLCBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvbiwgZGVsdGEgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHVzaCh0bzogVG8sIHN0YXRlPzogYW55KSB7XG4gICAgYWN0aW9uID0gQWN0aW9uLlB1c2g7XG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oaGlzdG9yeS5sb2NhdGlvbiwgdG8sIHN0YXRlKTtcbiAgICBpZiAodmFsaWRhdGVMb2NhdGlvbikgdmFsaWRhdGVMb2NhdGlvbihsb2NhdGlvbiwgdG8pO1xuXG4gICAgaW5kZXggPSBnZXRJbmRleCgpICsgMTtcbiAgICBsZXQgaGlzdG9yeVN0YXRlID0gZ2V0SGlzdG9yeVN0YXRlKGxvY2F0aW9uLCBpbmRleCk7XG4gICAgbGV0IHVybCA9IGhpc3RvcnkuY3JlYXRlSHJlZihsb2NhdGlvbik7XG5cbiAgICAvLyB0cnkuLi5jYXRjaCBiZWNhdXNlIGlPUyBsaW1pdHMgdXMgdG8gMTAwIHB1c2hTdGF0ZSBjYWxscyA6L1xuICAgIHRyeSB7XG4gICAgICBnbG9iYWxIaXN0b3J5LnB1c2hTdGF0ZShoaXN0b3J5U3RhdGUsIFwiXCIsIHVybCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIElmIHRoZSBleGNlcHRpb24gaXMgYmVjYXVzZSBgc3RhdGVgIGNhbid0IGJlIHNlcmlhbGl6ZWQsIGxldCB0aGF0IHRocm93XG4gICAgICAvLyBvdXR3YXJkcyBqdXN0IGxpa2UgYSByZXBsYWNlIGNhbGwgd291bGQgc28gdGhlIGRldiBrbm93cyB0aGUgY2F1c2VcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL25hdi1oaXN0b3J5LWFwaXMuaHRtbCNzaGFyZWQtaGlzdG9yeS1wdXNoL3JlcGxhY2Utc3RhdGUtc3RlcHNcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N0cnVjdHVyZWQtZGF0YS5odG1sI3N0cnVjdHVyZWRzZXJpYWxpemVpbnRlcm5hbFxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uICYmIGVycm9yLm5hbWUgPT09IFwiRGF0YUNsb25lRXJyb3JcIikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIC8vIFRoZXkgYXJlIGdvaW5nIHRvIGxvc2Ugc3RhdGUgaGVyZSwgYnV0IHRoZXJlIGlzIG5vIHJlYWxcbiAgICAgIC8vIHdheSB0byB3YXJuIHRoZW0gYWJvdXQgaXQgc2luY2UgdGhlIHBhZ2Ugd2lsbCByZWZyZXNoLi4uXG4gICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKHVybCk7XG4gICAgfVxuXG4gICAgaWYgKHY1Q29tcGF0ICYmIGxpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lcih7IGFjdGlvbiwgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb24sIGRlbHRhOiAxIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcGxhY2UodG86IFRvLCBzdGF0ZT86IGFueSkge1xuICAgIGFjdGlvbiA9IEFjdGlvbi5SZXBsYWNlO1xuICAgIGxldCBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKGhpc3RvcnkubG9jYXRpb24sIHRvLCBzdGF0ZSk7XG4gICAgaWYgKHZhbGlkYXRlTG9jYXRpb24pIHZhbGlkYXRlTG9jYXRpb24obG9jYXRpb24sIHRvKTtcblxuICAgIGluZGV4ID0gZ2V0SW5kZXgoKTtcbiAgICBsZXQgaGlzdG9yeVN0YXRlID0gZ2V0SGlzdG9yeVN0YXRlKGxvY2F0aW9uLCBpbmRleCk7XG4gICAgbGV0IHVybCA9IGhpc3RvcnkuY3JlYXRlSHJlZihsb2NhdGlvbik7XG4gICAgZ2xvYmFsSGlzdG9yeS5yZXBsYWNlU3RhdGUoaGlzdG9yeVN0YXRlLCBcIlwiLCB1cmwpO1xuXG4gICAgaWYgKHY1Q29tcGF0ICYmIGxpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lcih7IGFjdGlvbiwgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb24sIGRlbHRhOiAwIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVSTCh0bzogVG8pOiBVUkwge1xuICAgIC8vIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gaXMgXCJudWxsXCIgKHRoZSBsaXRlcmFsIHN0cmluZyB2YWx1ZSkgaW4gRmlyZWZveFxuICAgIC8vIHVuZGVyIGNlcnRhaW4gY29uZGl0aW9ucywgbm90YWJseSB3aGVuIHNlcnZpbmcgZnJvbSBhIGxvY2FsIEhUTUwgZmlsZVxuICAgIC8vIFNlZSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD04NzgyOTdcbiAgICBsZXQgYmFzZSA9XG4gICAgICB3aW5kb3cubG9jYXRpb24ub3JpZ2luICE9PSBcIm51bGxcIlxuICAgICAgICA/IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW5cbiAgICAgICAgOiB3aW5kb3cubG9jYXRpb24uaHJlZjtcblxuICAgIGxldCBocmVmID0gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gdG8gOiBjcmVhdGVQYXRoKHRvKTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICBiYXNlLFxuICAgICAgYE5vIHdpbmRvdy5sb2NhdGlvbi4ob3JpZ2lufGhyZWYpIGF2YWlsYWJsZSB0byBjcmVhdGUgVVJMIGZvciBocmVmOiAke2hyZWZ9YFxuICAgICk7XG4gICAgcmV0dXJuIG5ldyBVUkwoaHJlZiwgYmFzZSk7XG4gIH1cblxuICBsZXQgaGlzdG9yeTogSGlzdG9yeSA9IHtcbiAgICBnZXQgYWN0aW9uKCkge1xuICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICB9LFxuICAgIGdldCBsb2NhdGlvbigpIHtcbiAgICAgIHJldHVybiBnZXRMb2NhdGlvbih3aW5kb3csIGdsb2JhbEhpc3RvcnkpO1xuICAgIH0sXG4gICAgbGlzdGVuKGZuOiBMaXN0ZW5lcikge1xuICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgaGlzdG9yeSBvbmx5IGFjY2VwdHMgb25lIGFjdGl2ZSBsaXN0ZW5lclwiKTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFBvcFN0YXRlRXZlbnRUeXBlLCBoYW5kbGVQb3ApO1xuICAgICAgbGlzdGVuZXIgPSBmbjtcblxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoUG9wU3RhdGVFdmVudFR5cGUsIGhhbmRsZVBvcCk7XG4gICAgICAgIGxpc3RlbmVyID0gbnVsbDtcbiAgICAgIH07XG4gICAgfSxcbiAgICBjcmVhdGVIcmVmKHRvKSB7XG4gICAgICByZXR1cm4gY3JlYXRlSHJlZih3aW5kb3csIHRvKTtcbiAgICB9LFxuICAgIGNyZWF0ZVVSTCxcbiAgICBlbmNvZGVMb2NhdGlvbih0bykge1xuICAgICAgLy8gRW5jb2RlIGEgTG9jYXRpb24gdGhlIHNhbWUgd2F5IHdpbmRvdy5sb2NhdGlvbiB3b3VsZFxuICAgICAgbGV0IHVybCA9IGNyZWF0ZVVSTCh0byk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRobmFtZTogdXJsLnBhdGhuYW1lLFxuICAgICAgICBzZWFyY2g6IHVybC5zZWFyY2gsXG4gICAgICAgIGhhc2g6IHVybC5oYXNoLFxuICAgICAgfTtcbiAgICB9LFxuICAgIHB1c2gsXG4gICAgcmVwbGFjZSxcbiAgICBnbyhuKSB7XG4gICAgICByZXR1cm4gZ2xvYmFsSGlzdG9yeS5nbyhuKTtcbiAgICB9LFxuICB9O1xuXG4gIHJldHVybiBoaXN0b3J5O1xufVxuXG4vLyNlbmRyZWdpb25cbiIsImltcG9ydCB0eXBlIHsgTG9jYXRpb24sIFBhdGgsIFRvIH0gZnJvbSBcIi4vaGlzdG9yeVwiO1xuaW1wb3J0IHsgaW52YXJpYW50LCBwYXJzZVBhdGgsIHdhcm5pbmcgfSBmcm9tIFwiLi9oaXN0b3J5XCI7XG5cbi8qKlxuICogTWFwIG9mIHJvdXRlSWQgLT4gZGF0YSByZXR1cm5lZCBmcm9tIGEgbG9hZGVyL2FjdGlvbi9lcnJvclxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlRGF0YSB7XG4gIFtyb3V0ZUlkOiBzdHJpbmddOiBhbnk7XG59XG5cbmV4cG9ydCBlbnVtIFJlc3VsdFR5cGUge1xuICBkYXRhID0gXCJkYXRhXCIsXG4gIGRlZmVycmVkID0gXCJkZWZlcnJlZFwiLFxuICByZWRpcmVjdCA9IFwicmVkaXJlY3RcIixcbiAgZXJyb3IgPSBcImVycm9yXCIsXG59XG5cbi8qKlxuICogU3VjY2Vzc2Z1bCByZXN1bHQgZnJvbSBhIGxvYWRlciBvciBhY3Rpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdWNjZXNzUmVzdWx0IHtcbiAgdHlwZTogUmVzdWx0VHlwZS5kYXRhO1xuICBkYXRhOiBhbnk7XG4gIHN0YXR1c0NvZGU/OiBudW1iZXI7XG4gIGhlYWRlcnM/OiBIZWFkZXJzO1xufVxuXG4vKipcbiAqIFN1Y2Nlc3NmdWwgZGVmZXIoKSByZXN1bHQgZnJvbSBhIGxvYWRlciBvciBhY3Rpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEZWZlcnJlZFJlc3VsdCB7XG4gIHR5cGU6IFJlc3VsdFR5cGUuZGVmZXJyZWQ7XG4gIGRlZmVycmVkRGF0YTogRGVmZXJyZWREYXRhO1xuICBzdGF0dXNDb2RlPzogbnVtYmVyO1xuICBoZWFkZXJzPzogSGVhZGVycztcbn1cblxuLyoqXG4gKiBSZWRpcmVjdCByZXN1bHQgZnJvbSBhIGxvYWRlciBvciBhY3Rpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZWRpcmVjdFJlc3VsdCB7XG4gIHR5cGU6IFJlc3VsdFR5cGUucmVkaXJlY3Q7XG4gIHN0YXR1czogbnVtYmVyO1xuICBsb2NhdGlvbjogc3RyaW5nO1xuICByZXZhbGlkYXRlOiBib29sZWFuO1xuICByZWxvYWREb2N1bWVudD86IGJvb2xlYW47XG59XG5cbi8qKlxuICogVW5zdWNjZXNzZnVsIHJlc3VsdCBmcm9tIGEgbG9hZGVyIG9yIGFjdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIEVycm9yUmVzdWx0IHtcbiAgdHlwZTogUmVzdWx0VHlwZS5lcnJvcjtcbiAgZXJyb3I6IGFueTtcbiAgaGVhZGVycz86IEhlYWRlcnM7XG59XG5cbi8qKlxuICogUmVzdWx0IGZyb20gYSBsb2FkZXIgb3IgYWN0aW9uIC0gcG90ZW50aWFsbHkgc3VjY2Vzc2Z1bCBvciB1bnN1Y2Nlc3NmdWxcbiAqL1xuZXhwb3J0IHR5cGUgRGF0YVJlc3VsdCA9XG4gIHwgU3VjY2Vzc1Jlc3VsdFxuICB8IERlZmVycmVkUmVzdWx0XG4gIHwgUmVkaXJlY3RSZXN1bHRcbiAgfCBFcnJvclJlc3VsdDtcblxudHlwZSBMb3dlckNhc2VGb3JtTWV0aG9kID0gXCJnZXRcIiB8IFwicG9zdFwiIHwgXCJwdXRcIiB8IFwicGF0Y2hcIiB8IFwiZGVsZXRlXCI7XG50eXBlIFVwcGVyQ2FzZUZvcm1NZXRob2QgPSBVcHBlcmNhc2U8TG93ZXJDYXNlRm9ybU1ldGhvZD47XG5cbi8qKlxuICogVXNlcnMgY2FuIHNwZWNpZnkgZWl0aGVyIGxvd2VyY2FzZSBvciB1cHBlcmNhc2UgZm9ybSBtZXRob2RzIG9uIGA8Rm9ybT5gLFxuICogdXNlU3VibWl0KCksIGA8ZmV0Y2hlci5Gb3JtPmAsIGV0Yy5cbiAqL1xuZXhwb3J0IHR5cGUgSFRNTEZvcm1NZXRob2QgPSBMb3dlckNhc2VGb3JtTWV0aG9kIHwgVXBwZXJDYXNlRm9ybU1ldGhvZDtcblxuLyoqXG4gKiBBY3RpdmUgbmF2aWdhdGlvbi9mZXRjaGVyIGZvcm0gbWV0aG9kcyBhcmUgZXhwb3NlZCBpbiBsb3dlcmNhc2Ugb24gdGhlXG4gKiBSb3V0ZXJTdGF0ZVxuICovXG5leHBvcnQgdHlwZSBGb3JtTWV0aG9kID0gTG93ZXJDYXNlRm9ybU1ldGhvZDtcbmV4cG9ydCB0eXBlIE11dGF0aW9uRm9ybU1ldGhvZCA9IEV4Y2x1ZGU8Rm9ybU1ldGhvZCwgXCJnZXRcIj47XG5cbi8qKlxuICogSW4gdjcsIGFjdGl2ZSBuYXZpZ2F0aW9uL2ZldGNoZXIgZm9ybSBtZXRob2RzIGFyZSBleHBvc2VkIGluIHVwcGVyY2FzZSBvbiB0aGVcbiAqIFJvdXRlclN0YXRlLiAgVGhpcyBpcyB0byBhbGlnbiB3aXRoIHRoZSBub3JtYWxpemF0aW9uIGRvbmUgdmlhIGZldGNoKCkuXG4gKi9cbmV4cG9ydCB0eXBlIFY3X0Zvcm1NZXRob2QgPSBVcHBlckNhc2VGb3JtTWV0aG9kO1xuZXhwb3J0IHR5cGUgVjdfTXV0YXRpb25Gb3JtTWV0aG9kID0gRXhjbHVkZTxWN19Gb3JtTWV0aG9kLCBcIkdFVFwiPjtcblxuZXhwb3J0IHR5cGUgRm9ybUVuY1R5cGUgPVxuICB8IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCJcbiAgfCBcIm11bHRpcGFydC9mb3JtLWRhdGFcIlxuICB8IFwiYXBwbGljYXRpb24vanNvblwiXG4gIHwgXCJ0ZXh0L3BsYWluXCI7XG5cbi8vIFRoYW5rcyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3R5cGUtZmVzdCFcbnR5cGUgSnNvbk9iamVjdCA9IHsgW0tleSBpbiBzdHJpbmddOiBKc29uVmFsdWUgfSAmIHtcbiAgW0tleSBpbiBzdHJpbmddPzogSnNvblZhbHVlIHwgdW5kZWZpbmVkO1xufTtcbnR5cGUgSnNvbkFycmF5ID0gSnNvblZhbHVlW10gfCByZWFkb25seSBKc29uVmFsdWVbXTtcbnR5cGUgSnNvblByaW1pdGl2ZSA9IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBudWxsO1xudHlwZSBKc29uVmFsdWUgPSBKc29uUHJpbWl0aXZlIHwgSnNvbk9iamVjdCB8IEpzb25BcnJheTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogSW50ZXJuYWwgaW50ZXJmYWNlIHRvIHBhc3MgYXJvdW5kIGZvciBhY3Rpb24gc3VibWlzc2lvbnMsIG5vdCBpbnRlbmRlZCBmb3JcbiAqIGV4dGVybmFsIGNvbnN1bXB0aW9uXG4gKi9cbmV4cG9ydCB0eXBlIFN1Ym1pc3Npb24gPVxuICB8IHtcbiAgICAgIGZvcm1NZXRob2Q6IEZvcm1NZXRob2QgfCBWN19Gb3JtTWV0aG9kO1xuICAgICAgZm9ybUFjdGlvbjogc3RyaW5nO1xuICAgICAgZm9ybUVuY1R5cGU6IEZvcm1FbmNUeXBlO1xuICAgICAgZm9ybURhdGE6IEZvcm1EYXRhO1xuICAgICAganNvbjogdW5kZWZpbmVkO1xuICAgICAgdGV4dDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfCB7XG4gICAgICBmb3JtTWV0aG9kOiBGb3JtTWV0aG9kIHwgVjdfRm9ybU1ldGhvZDtcbiAgICAgIGZvcm1BY3Rpb246IHN0cmluZztcbiAgICAgIGZvcm1FbmNUeXBlOiBGb3JtRW5jVHlwZTtcbiAgICAgIGZvcm1EYXRhOiB1bmRlZmluZWQ7XG4gICAgICBqc29uOiBKc29uVmFsdWU7XG4gICAgICB0ZXh0OiB1bmRlZmluZWQ7XG4gICAgfVxuICB8IHtcbiAgICAgIGZvcm1NZXRob2Q6IEZvcm1NZXRob2QgfCBWN19Gb3JtTWV0aG9kO1xuICAgICAgZm9ybUFjdGlvbjogc3RyaW5nO1xuICAgICAgZm9ybUVuY1R5cGU6IEZvcm1FbmNUeXBlO1xuICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZDtcbiAgICAgIGpzb246IHVuZGVmaW5lZDtcbiAgICAgIHRleHQ6IHN0cmluZztcbiAgICB9O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBBcmd1bWVudHMgcGFzc2VkIHRvIHJvdXRlIGxvYWRlci9hY3Rpb24gZnVuY3Rpb25zLiAgU2FtZSBmb3Igbm93IGJ1dCB3ZSBrZWVwXG4gKiB0aGlzIGFzIGEgcHJpdmF0ZSBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgaW4gY2FzZSB0aGV5IGRpdmVyZ2UgaW4gdGhlIGZ1dHVyZS5cbiAqL1xuaW50ZXJmYWNlIERhdGFGdW5jdGlvbkFyZ3M8Q29udGV4dD4ge1xuICByZXF1ZXN0OiBSZXF1ZXN0O1xuICBwYXJhbXM6IFBhcmFtcztcbiAgY29udGV4dD86IENvbnRleHQ7XG59XG5cbi8vIFRPRE86ICh2NykgQ2hhbmdlIHRoZSBkZWZhdWx0cyBmcm9tIGFueSB0byB1bmtub3duIGluIGFuZCByZW1vdmUgUmVtaXggd3JhcHBlcnM6XG4vLyAgIEFjdGlvbkZ1bmN0aW9uLCBBY3Rpb25GdW5jdGlvbkFyZ3MsIExvYWRlckZ1bmN0aW9uLCBMb2FkZXJGdW5jdGlvbkFyZ3Ncbi8vICAgQWxzbywgbWFrZSB0aGVtIGEgdHlwZSBhbGlhcyBpbnN0ZWFkIG9mIGFuIGludGVyZmFjZVxuXG4vKipcbiAqIEFyZ3VtZW50cyBwYXNzZWQgdG8gbG9hZGVyIGZ1bmN0aW9uc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIExvYWRlckZ1bmN0aW9uQXJnczxDb250ZXh0ID0gYW55PlxuICBleHRlbmRzIERhdGFGdW5jdGlvbkFyZ3M8Q29udGV4dD4ge31cblxuLyoqXG4gKiBBcmd1bWVudHMgcGFzc2VkIHRvIGFjdGlvbiBmdW5jdGlvbnNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBY3Rpb25GdW5jdGlvbkFyZ3M8Q29udGV4dCA9IGFueT5cbiAgZXh0ZW5kcyBEYXRhRnVuY3Rpb25BcmdzPENvbnRleHQ+IHt9XG5cbi8qKlxuICogTG9hZGVycyBhbmQgYWN0aW9ucyBjYW4gcmV0dXJuIGFueXRoaW5nIGV4Y2VwdCBgdW5kZWZpbmVkYCAoYG51bGxgIGlzIGFcbiAqIHZhbGlkIHJldHVybiB2YWx1ZSBpZiB0aGVyZSBpcyBubyBkYXRhIHRvIHJldHVybikuICBSZXNwb25zZXMgYXJlIHByZWZlcnJlZFxuICogYW5kIHdpbGwgZWFzZSBhbnkgZnV0dXJlIG1pZ3JhdGlvbiB0byBSZW1peFxuICovXG50eXBlIERhdGFGdW5jdGlvblZhbHVlID0gUmVzcG9uc2UgfCBOb25OdWxsYWJsZTx1bmtub3duPiB8IG51bGw7XG5cbi8qKlxuICogUm91dGUgbG9hZGVyIGZ1bmN0aW9uIHNpZ25hdHVyZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIExvYWRlckZ1bmN0aW9uPENvbnRleHQgPSBhbnk+IHtcbiAgKGFyZ3M6IExvYWRlckZ1bmN0aW9uQXJnczxDb250ZXh0Pik6XG4gICAgfCBQcm9taXNlPERhdGFGdW5jdGlvblZhbHVlPlxuICAgIHwgRGF0YUZ1bmN0aW9uVmFsdWU7XG59XG5cbi8qKlxuICogUm91dGUgYWN0aW9uIGZ1bmN0aW9uIHNpZ25hdHVyZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFjdGlvbkZ1bmN0aW9uPENvbnRleHQgPSBhbnk+IHtcbiAgKGFyZ3M6IEFjdGlvbkZ1bmN0aW9uQXJnczxDb250ZXh0Pik6XG4gICAgfCBQcm9taXNlPERhdGFGdW5jdGlvblZhbHVlPlxuICAgIHwgRGF0YUZ1bmN0aW9uVmFsdWU7XG59XG5cbi8qKlxuICogQXJndW1lbnRzIHBhc3NlZCB0byBzaG91bGRSZXZhbGlkYXRlIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2hvdWxkUmV2YWxpZGF0ZUZ1bmN0aW9uQXJncyB7XG4gIGN1cnJlbnRVcmw6IFVSTDtcbiAgY3VycmVudFBhcmFtczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtcInBhcmFtc1wiXTtcbiAgbmV4dFVybDogVVJMO1xuICBuZXh0UGFyYW1zOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW1wicGFyYW1zXCJdO1xuICBmb3JtTWV0aG9kPzogU3VibWlzc2lvbltcImZvcm1NZXRob2RcIl07XG4gIGZvcm1BY3Rpb24/OiBTdWJtaXNzaW9uW1wiZm9ybUFjdGlvblwiXTtcbiAgZm9ybUVuY1R5cGU/OiBTdWJtaXNzaW9uW1wiZm9ybUVuY1R5cGVcIl07XG4gIHRleHQ/OiBTdWJtaXNzaW9uW1widGV4dFwiXTtcbiAgZm9ybURhdGE/OiBTdWJtaXNzaW9uW1wiZm9ybURhdGFcIl07XG4gIGpzb24/OiBTdWJtaXNzaW9uW1wianNvblwiXTtcbiAgYWN0aW9uUmVzdWx0PzogYW55O1xuICBkZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZTogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBSb3V0ZSBzaG91bGRSZXZhbGlkYXRlIGZ1bmN0aW9uIHNpZ25hdHVyZS4gIFRoaXMgcnVucyBhZnRlciBhbnkgc3VibWlzc2lvblxuICogKG5hdmlnYXRpb24gb3IgZmV0Y2hlciksIHNvIHdlIGZsYXR0ZW4gdGhlIG5hdmlnYXRpb24vZmV0Y2hlciBzdWJtaXNzaW9uXG4gKiBvbnRvIHRoZSBhcmd1bWVudHMuICBJdCBzaG91bGRuJ3QgbWF0dGVyIHdoZXRoZXIgaXQgY2FtZSBmcm9tIGEgbmF2aWdhdGlvblxuICogb3IgYSBmZXRjaGVyLCB3aGF0IHJlYWxseSBtYXR0ZXJzIGlzIHRoZSBVUkxzIGFuZCB0aGUgZm9ybURhdGEgc2luY2UgbG9hZGVyc1xuICogaGF2ZSB0byByZS1ydW4gYmFzZWQgb24gdGhlIGRhdGEgbW9kZWxzIHRoYXQgd2VyZSBwb3RlbnRpYWxseSBtdXRhdGVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNob3VsZFJldmFsaWRhdGVGdW5jdGlvbiB7XG4gIChhcmdzOiBTaG91bGRSZXZhbGlkYXRlRnVuY3Rpb25BcmdzKTogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBwcm92aWRlZCBieSB0aGUgZnJhbWV3b3JrLWF3YXJlIGxheWVycyB0byBzZXQgYGhhc0Vycm9yQm91bmRhcnlgXG4gKiBmcm9tIHRoZSBmcmFtZXdvcmstYXdhcmUgYGVycm9yRWxlbWVudGAgcHJvcFxuICpcbiAqIEBkZXByZWNhdGVkIFVzZSBgbWFwUm91dGVQcm9wZXJ0aWVzYCBpbnN0ZWFkXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRGV0ZWN0RXJyb3JCb3VuZGFyeUZ1bmN0aW9uIHtcbiAgKHJvdXRlOiBBZ25vc3RpY1JvdXRlT2JqZWN0KTogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBwcm92aWRlZCBieSB0aGUgZnJhbWV3b3JrLWF3YXJlIGxheWVycyB0byBzZXQgYW55IGZyYW1ld29yay1zcGVjaWZpY1xuICogcHJvcGVydGllcyBmcm9tIGZyYW1ld29yay1hZ25vc3RpYyBwcm9wZXJ0aWVzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWFwUm91dGVQcm9wZXJ0aWVzRnVuY3Rpb24ge1xuICAocm91dGU6IEFnbm9zdGljUm91dGVPYmplY3QpOiB7XG4gICAgaGFzRXJyb3JCb3VuZGFyeTogYm9vbGVhbjtcbiAgfSAmIFJlY29yZDxzdHJpbmcsIGFueT47XG59XG5cbi8qKlxuICogS2V5cyB3ZSBjYW5ub3QgY2hhbmdlIGZyb20gd2l0aGluIGEgbGF6eSgpIGZ1bmN0aW9uLiBXZSBzcHJlYWQgYWxsIG90aGVyIGtleXNcbiAqIG9udG8gdGhlIHJvdXRlLiBFaXRoZXIgdGhleSdyZSBtZWFuaW5nZnVsIHRvIHRoZSByb3V0ZXIsIG9yIHRoZXknbGwgZ2V0XG4gKiBpZ25vcmVkLlxuICovXG5leHBvcnQgdHlwZSBJbW11dGFibGVSb3V0ZUtleSA9XG4gIHwgXCJsYXp5XCJcbiAgfCBcImNhc2VTZW5zaXRpdmVcIlxuICB8IFwicGF0aFwiXG4gIHwgXCJpZFwiXG4gIHwgXCJpbmRleFwiXG4gIHwgXCJjaGlsZHJlblwiO1xuXG5leHBvcnQgY29uc3QgaW1tdXRhYmxlUm91dGVLZXlzID0gbmV3IFNldDxJbW11dGFibGVSb3V0ZUtleT4oW1xuICBcImxhenlcIixcbiAgXCJjYXNlU2Vuc2l0aXZlXCIsXG4gIFwicGF0aFwiLFxuICBcImlkXCIsXG4gIFwiaW5kZXhcIixcbiAgXCJjaGlsZHJlblwiLFxuXSk7XG5cbnR5cGUgUmVxdWlyZU9uZTxULCBLZXkgPSBrZXlvZiBUPiA9IEV4Y2x1ZGU8XG4gIHtcbiAgICBbSyBpbiBrZXlvZiBUXTogSyBleHRlbmRzIEtleSA/IE9taXQ8VCwgSz4gJiBSZXF1aXJlZDxQaWNrPFQsIEs+PiA6IG5ldmVyO1xuICB9W2tleW9mIFRdLFxuICB1bmRlZmluZWRcbj47XG5cbi8qKlxuICogbGF6eSgpIGZ1bmN0aW9uIHRvIGxvYWQgYSByb3V0ZSBkZWZpbml0aW9uLCB3aGljaCBjYW4gYWRkIG5vbi1tYXRjaGluZ1xuICogcmVsYXRlZCBwcm9wZXJ0aWVzIHRvIGEgcm91dGVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMYXp5Um91dGVGdW5jdGlvbjxSIGV4dGVuZHMgQWdub3N0aWNSb3V0ZU9iamVjdD4ge1xuICAoKTogUHJvbWlzZTxSZXF1aXJlT25lPE9taXQ8UiwgSW1tdXRhYmxlUm91dGVLZXk+Pj47XG59XG5cbi8qKlxuICogQmFzZSBSb3V0ZU9iamVjdCB3aXRoIGNvbW1vbiBwcm9wcyBzaGFyZWQgYnkgYWxsIHR5cGVzIG9mIHJvdXRlc1xuICovXG50eXBlIEFnbm9zdGljQmFzZVJvdXRlT2JqZWN0ID0ge1xuICBjYXNlU2Vuc2l0aXZlPzogYm9vbGVhbjtcbiAgcGF0aD86IHN0cmluZztcbiAgaWQ/OiBzdHJpbmc7XG4gIGxvYWRlcj86IExvYWRlckZ1bmN0aW9uO1xuICBhY3Rpb24/OiBBY3Rpb25GdW5jdGlvbjtcbiAgaGFzRXJyb3JCb3VuZGFyeT86IGJvb2xlYW47XG4gIHNob3VsZFJldmFsaWRhdGU/OiBTaG91bGRSZXZhbGlkYXRlRnVuY3Rpb247XG4gIGhhbmRsZT86IGFueTtcbiAgbGF6eT86IExhenlSb3V0ZUZ1bmN0aW9uPEFnbm9zdGljQmFzZVJvdXRlT2JqZWN0Pjtcbn07XG5cbi8qKlxuICogSW5kZXggcm91dGVzIG11c3Qgbm90IGhhdmUgY2hpbGRyZW5cbiAqL1xuZXhwb3J0IHR5cGUgQWdub3N0aWNJbmRleFJvdXRlT2JqZWN0ID0gQWdub3N0aWNCYXNlUm91dGVPYmplY3QgJiB7XG4gIGNoaWxkcmVuPzogdW5kZWZpbmVkO1xuICBpbmRleDogdHJ1ZTtcbn07XG5cbi8qKlxuICogTm9uLWluZGV4IHJvdXRlcyBtYXkgaGF2ZSBjaGlsZHJlbiwgYnV0IGNhbm5vdCBoYXZlIGluZGV4XG4gKi9cbmV4cG9ydCB0eXBlIEFnbm9zdGljTm9uSW5kZXhSb3V0ZU9iamVjdCA9IEFnbm9zdGljQmFzZVJvdXRlT2JqZWN0ICYge1xuICBjaGlsZHJlbj86IEFnbm9zdGljUm91dGVPYmplY3RbXTtcbiAgaW5kZXg/OiBmYWxzZTtcbn07XG5cbi8qKlxuICogQSByb3V0ZSBvYmplY3QgcmVwcmVzZW50cyBhIGxvZ2ljYWwgcm91dGUsIHdpdGggKG9wdGlvbmFsbHkpIGl0cyBjaGlsZFxuICogcm91dGVzIG9yZ2FuaXplZCBpbiBhIHRyZWUtbGlrZSBzdHJ1Y3R1cmUuXG4gKi9cbmV4cG9ydCB0eXBlIEFnbm9zdGljUm91dGVPYmplY3QgPVxuICB8IEFnbm9zdGljSW5kZXhSb3V0ZU9iamVjdFxuICB8IEFnbm9zdGljTm9uSW5kZXhSb3V0ZU9iamVjdDtcblxuZXhwb3J0IHR5cGUgQWdub3N0aWNEYXRhSW5kZXhSb3V0ZU9iamVjdCA9IEFnbm9zdGljSW5kZXhSb3V0ZU9iamVjdCAmIHtcbiAgaWQ6IHN0cmluZztcbn07XG5cbmV4cG9ydCB0eXBlIEFnbm9zdGljRGF0YU5vbkluZGV4Um91dGVPYmplY3QgPSBBZ25vc3RpY05vbkluZGV4Um91dGVPYmplY3QgJiB7XG4gIGNoaWxkcmVuPzogQWdub3N0aWNEYXRhUm91dGVPYmplY3RbXTtcbiAgaWQ6IHN0cmluZztcbn07XG5cbi8qKlxuICogQSBkYXRhIHJvdXRlIG9iamVjdCwgd2hpY2ggaXMganVzdCBhIFJvdXRlT2JqZWN0IHdpdGggYSByZXF1aXJlZCB1bmlxdWUgSURcbiAqL1xuZXhwb3J0IHR5cGUgQWdub3N0aWNEYXRhUm91dGVPYmplY3QgPVxuICB8IEFnbm9zdGljRGF0YUluZGV4Um91dGVPYmplY3RcbiAgfCBBZ25vc3RpY0RhdGFOb25JbmRleFJvdXRlT2JqZWN0O1xuXG5leHBvcnQgdHlwZSBSb3V0ZU1hbmlmZXN0ID0gUmVjb3JkPHN0cmluZywgQWdub3N0aWNEYXRhUm91dGVPYmplY3QgfCB1bmRlZmluZWQ+O1xuXG4vLyBSZWN1cnNpdmUgaGVscGVyIGZvciBmaW5kaW5nIHBhdGggcGFyYW1ldGVycyBpbiB0aGUgYWJzZW5jZSBvZiB3aWxkY2FyZHNcbnR5cGUgX1BhdGhQYXJhbTxQYXRoIGV4dGVuZHMgc3RyaW5nPiA9XG4gIC8vIHNwbGl0IHBhdGggaW50byBpbmRpdmlkdWFsIHBhdGggc2VnbWVudHNcbiAgUGF0aCBleHRlbmRzIGAke2luZmVyIEx9LyR7aW5mZXIgUn1gXG4gICAgPyBfUGF0aFBhcmFtPEw+IHwgX1BhdGhQYXJhbTxSPlxuICAgIDogLy8gZmluZCBwYXJhbXMgYWZ0ZXIgYDpgXG4gICAgUGF0aCBleHRlbmRzIGA6JHtpbmZlciBQYXJhbX1gXG4gICAgPyBQYXJhbSBleHRlbmRzIGAke2luZmVyIE9wdGlvbmFsfT9gXG4gICAgICA/IE9wdGlvbmFsXG4gICAgICA6IFBhcmFtXG4gICAgOiAvLyBvdGhlcndpc2UsIHRoZXJlIGFyZW4ndCBhbnkgcGFyYW1zIHByZXNlbnRcbiAgICAgIG5ldmVyO1xuXG4vKipcbiAqIEV4YW1wbGVzOlxuICogXCIvYS9iLypcIiAtPiBcIipcIlxuICogXCI6YVwiIC0+IFwiYVwiXG4gKiBcIi9hLzpiXCIgLT4gXCJiXCJcbiAqIFwiL2EvYmxhaGJsYWhibGFoOmJcIiAtPiBcImJcIlxuICogXCIvOmEvOmJcIiAtPiBcImFcIiB8IFwiYlwiXG4gKiBcIi86YS9iLzpjLypcIiAtPiBcImFcIiB8IFwiY1wiIHwgXCIqXCJcbiAqL1xudHlwZSBQYXRoUGFyYW08UGF0aCBleHRlbmRzIHN0cmluZz4gPVxuICAvLyBjaGVjayBpZiBwYXRoIGlzIGp1c3QgYSB3aWxkY2FyZFxuICBQYXRoIGV4dGVuZHMgXCIqXCIgfCBcIi8qXCJcbiAgICA/IFwiKlwiXG4gICAgOiAvLyBsb29rIGZvciB3aWxkY2FyZCBhdCB0aGUgZW5kIG9mIHRoZSBwYXRoXG4gICAgUGF0aCBleHRlbmRzIGAke2luZmVyIFJlc3R9LypgXG4gICAgPyBcIipcIiB8IF9QYXRoUGFyYW08UmVzdD5cbiAgICA6IC8vIGxvb2sgZm9yIHBhcmFtcyBpbiB0aGUgYWJzZW5jZSBvZiB3aWxkY2FyZHNcbiAgICAgIF9QYXRoUGFyYW08UGF0aD47XG5cbi8vIEF0dGVtcHQgdG8gcGFyc2UgdGhlIGdpdmVuIHN0cmluZyBzZWdtZW50LiBJZiBpdCBmYWlscywgdGhlbiBqdXN0IHJldHVybiB0aGVcbi8vIHBsYWluIHN0cmluZyB0eXBlIGFzIGEgZGVmYXVsdCBmYWxsYmFjay4gT3RoZXJ3aXNlLCByZXR1cm4gdGhlIHVuaW9uIG9mIHRoZVxuLy8gcGFyc2VkIHN0cmluZyBsaXRlcmFscyB0aGF0IHdlcmUgcmVmZXJlbmNlZCBhcyBkeW5hbWljIHNlZ21lbnRzIGluIHRoZSByb3V0ZS5cbmV4cG9ydCB0eXBlIFBhcmFtUGFyc2VLZXk8U2VnbWVudCBleHRlbmRzIHN0cmluZz4gPVxuICAvLyBpZiB5b3UgY291bGQgbm90IGZpbmQgcGF0aCBwYXJhbXMsIGZhbGxiYWNrIHRvIGBzdHJpbmdgXG4gIFtQYXRoUGFyYW08U2VnbWVudD5dIGV4dGVuZHMgW25ldmVyXSA/IHN0cmluZyA6IFBhdGhQYXJhbTxTZWdtZW50PjtcblxuLyoqXG4gKiBUaGUgcGFyYW1ldGVycyB0aGF0IHdlcmUgcGFyc2VkIGZyb20gdGhlIFVSTCBwYXRoLlxuICovXG5leHBvcnQgdHlwZSBQYXJhbXM8S2V5IGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiA9IHtcbiAgcmVhZG9ubHkgW2tleSBpbiBLZXldOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIEEgUm91dGVNYXRjaCBjb250YWlucyBpbmZvIGFib3V0IGhvdyBhIHJvdXRlIG1hdGNoZWQgYSBVUkwuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQWdub3N0aWNSb3V0ZU1hdGNoPFxuICBQYXJhbUtleSBleHRlbmRzIHN0cmluZyA9IHN0cmluZyxcbiAgUm91dGVPYmplY3RUeXBlIGV4dGVuZHMgQWdub3N0aWNSb3V0ZU9iamVjdCA9IEFnbm9zdGljUm91dGVPYmplY3Rcbj4ge1xuICAvKipcbiAgICogVGhlIG5hbWVzIGFuZCB2YWx1ZXMgb2YgZHluYW1pYyBwYXJhbWV0ZXJzIGluIHRoZSBVUkwuXG4gICAqL1xuICBwYXJhbXM6IFBhcmFtczxQYXJhbUtleT47XG4gIC8qKlxuICAgKiBUaGUgcG9ydGlvbiBvZiB0aGUgVVJMIHBhdGhuYW1lIHRoYXQgd2FzIG1hdGNoZWQuXG4gICAqL1xuICBwYXRobmFtZTogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHBvcnRpb24gb2YgdGhlIFVSTCBwYXRobmFtZSB0aGF0IHdhcyBtYXRjaGVkIGJlZm9yZSBjaGlsZCByb3V0ZXMuXG4gICAqL1xuICBwYXRobmFtZUJhc2U6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSByb3V0ZSBvYmplY3QgdGhhdCB3YXMgdXNlZCB0byBtYXRjaC5cbiAgICovXG4gIHJvdXRlOiBSb3V0ZU9iamVjdFR5cGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWdub3N0aWNEYXRhUm91dGVNYXRjaFxuICBleHRlbmRzIEFnbm9zdGljUm91dGVNYXRjaDxzdHJpbmcsIEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0PiB7fVxuXG5mdW5jdGlvbiBpc0luZGV4Um91dGUoXG4gIHJvdXRlOiBBZ25vc3RpY1JvdXRlT2JqZWN0XG4pOiByb3V0ZSBpcyBBZ25vc3RpY0luZGV4Um91dGVPYmplY3Qge1xuICByZXR1cm4gcm91dGUuaW5kZXggPT09IHRydWU7XG59XG5cbi8vIFdhbGsgdGhlIHJvdXRlIHRyZWUgZ2VuZXJhdGluZyB1bmlxdWUgSURzIHdoZXJlIG5lY2Vzc2FyeSwgc28gd2UgYXJlIHdvcmtpbmdcbi8vIHNvbGVseSB3aXRoIEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0J3Mgd2l0aGluIHRoZSBSb3V0ZXJcbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKFxuICByb3V0ZXM6IEFnbm9zdGljUm91dGVPYmplY3RbXSxcbiAgbWFwUm91dGVQcm9wZXJ0aWVzOiBNYXBSb3V0ZVByb3BlcnRpZXNGdW5jdGlvbixcbiAgcGFyZW50UGF0aDogbnVtYmVyW10gPSBbXSxcbiAgbWFuaWZlc3Q6IFJvdXRlTWFuaWZlc3QgPSB7fVxuKTogQWdub3N0aWNEYXRhUm91dGVPYmplY3RbXSB7XG4gIHJldHVybiByb3V0ZXMubWFwKChyb3V0ZSwgaW5kZXgpID0+IHtcbiAgICBsZXQgdHJlZVBhdGggPSBbLi4ucGFyZW50UGF0aCwgaW5kZXhdO1xuICAgIGxldCBpZCA9IHR5cGVvZiByb3V0ZS5pZCA9PT0gXCJzdHJpbmdcIiA/IHJvdXRlLmlkIDogdHJlZVBhdGguam9pbihcIi1cIik7XG4gICAgaW52YXJpYW50KFxuICAgICAgcm91dGUuaW5kZXggIT09IHRydWUgfHwgIXJvdXRlLmNoaWxkcmVuLFxuICAgICAgYENhbm5vdCBzcGVjaWZ5IGNoaWxkcmVuIG9uIGFuIGluZGV4IHJvdXRlYFxuICAgICk7XG4gICAgaW52YXJpYW50KFxuICAgICAgIW1hbmlmZXN0W2lkXSxcbiAgICAgIGBGb3VuZCBhIHJvdXRlIGlkIGNvbGxpc2lvbiBvbiBpZCBcIiR7aWR9XCIuICBSb3V0ZSBgICtcbiAgICAgICAgXCJpZCdzIG11c3QgYmUgZ2xvYmFsbHkgdW5pcXVlIHdpdGhpbiBEYXRhIFJvdXRlciB1c2FnZXNcIlxuICAgICk7XG5cbiAgICBpZiAoaXNJbmRleFJvdXRlKHJvdXRlKSkge1xuICAgICAgbGV0IGluZGV4Um91dGU6IEFnbm9zdGljRGF0YUluZGV4Um91dGVPYmplY3QgPSB7XG4gICAgICAgIC4uLnJvdXRlLFxuICAgICAgICAuLi5tYXBSb3V0ZVByb3BlcnRpZXMocm91dGUpLFxuICAgICAgICBpZCxcbiAgICAgIH07XG4gICAgICBtYW5pZmVzdFtpZF0gPSBpbmRleFJvdXRlO1xuICAgICAgcmV0dXJuIGluZGV4Um91dGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwYXRoT3JMYXlvdXRSb3V0ZTogQWdub3N0aWNEYXRhTm9uSW5kZXhSb3V0ZU9iamVjdCA9IHtcbiAgICAgICAgLi4ucm91dGUsXG4gICAgICAgIC4uLm1hcFJvdXRlUHJvcGVydGllcyhyb3V0ZSksXG4gICAgICAgIGlkLFxuICAgICAgICBjaGlsZHJlbjogdW5kZWZpbmVkLFxuICAgICAgfTtcbiAgICAgIG1hbmlmZXN0W2lkXSA9IHBhdGhPckxheW91dFJvdXRlO1xuXG4gICAgICBpZiAocm91dGUuY2hpbGRyZW4pIHtcbiAgICAgICAgcGF0aE9yTGF5b3V0Um91dGUuY2hpbGRyZW4gPSBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKFxuICAgICAgICAgIHJvdXRlLmNoaWxkcmVuLFxuICAgICAgICAgIG1hcFJvdXRlUHJvcGVydGllcyxcbiAgICAgICAgICB0cmVlUGF0aCxcbiAgICAgICAgICBtYW5pZmVzdFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGF0aE9yTGF5b3V0Um91dGU7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBNYXRjaGVzIHRoZSBnaXZlbiByb3V0ZXMgdG8gYSBsb2NhdGlvbiBhbmQgcmV0dXJucyB0aGUgbWF0Y2ggZGF0YS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3V0aWxzL21hdGNoLXJvdXRlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0Y2hSb3V0ZXM8XG4gIFJvdXRlT2JqZWN0VHlwZSBleHRlbmRzIEFnbm9zdGljUm91dGVPYmplY3QgPSBBZ25vc3RpY1JvdXRlT2JqZWN0XG4+KFxuICByb3V0ZXM6IFJvdXRlT2JqZWN0VHlwZVtdLFxuICBsb2NhdGlvbkFyZzogUGFydGlhbDxMb2NhdGlvbj4gfCBzdHJpbmcsXG4gIGJhc2VuYW1lID0gXCIvXCJcbik6IEFnbm9zdGljUm91dGVNYXRjaDxzdHJpbmcsIFJvdXRlT2JqZWN0VHlwZT5bXSB8IG51bGwge1xuICBsZXQgbG9jYXRpb24gPVxuICAgIHR5cGVvZiBsb2NhdGlvbkFyZyA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChsb2NhdGlvbkFyZykgOiBsb2NhdGlvbkFyZztcblxuICBsZXQgcGF0aG5hbWUgPSBzdHJpcEJhc2VuYW1lKGxvY2F0aW9uLnBhdGhuYW1lIHx8IFwiL1wiLCBiYXNlbmFtZSk7XG5cbiAgaWYgKHBhdGhuYW1lID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGxldCBicmFuY2hlcyA9IGZsYXR0ZW5Sb3V0ZXMocm91dGVzKTtcbiAgcmFua1JvdXRlQnJhbmNoZXMoYnJhbmNoZXMpO1xuXG4gIGxldCBtYXRjaGVzID0gbnVsbDtcbiAgZm9yIChsZXQgaSA9IDA7IG1hdGNoZXMgPT0gbnVsbCAmJiBpIDwgYnJhbmNoZXMubGVuZ3RoOyArK2kpIHtcbiAgICBtYXRjaGVzID0gbWF0Y2hSb3V0ZUJyYW5jaDxzdHJpbmcsIFJvdXRlT2JqZWN0VHlwZT4oXG4gICAgICBicmFuY2hlc1tpXSxcbiAgICAgIC8vIEluY29taW5nIHBhdGhuYW1lcyBhcmUgZ2VuZXJhbGx5IGVuY29kZWQgZnJvbSBlaXRoZXIgd2luZG93LmxvY2F0aW9uXG4gICAgICAvLyBvciBmcm9tIHJvdXRlci5uYXZpZ2F0ZSwgYnV0IHdlIHdhbnQgdG8gbWF0Y2ggYWdhaW5zdCB0aGUgdW5lbmNvZGVkXG4gICAgICAvLyBwYXRocyBpbiB0aGUgcm91dGUgZGVmaW5pdGlvbnMuICBNZW1vcnkgcm91dGVyIGxvY2F0aW9ucyB3b24ndCBiZVxuICAgICAgLy8gZW5jb2RlZCBoZXJlIGJ1dCB0aGVyZSBhbHNvIHNob3VsZG4ndCBiZSBhbnl0aGluZyB0byBkZWNvZGUgc28gdGhpc1xuICAgICAgLy8gc2hvdWxkIGJlIGEgc2FmZSBvcGVyYXRpb24uICBUaGlzIGF2b2lkcyBuZWVkaW5nIG1hdGNoUm91dGVzIHRvIGJlXG4gICAgICAvLyBoaXN0b3J5LWF3YXJlLlxuICAgICAgc2FmZWx5RGVjb2RlVVJJKHBhdGhuYW1lKVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gbWF0Y2hlcztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVSU1hdGNoPERhdGEgPSB1bmtub3duLCBIYW5kbGUgPSB1bmtub3duPiB7XG4gIGlkOiBzdHJpbmc7XG4gIHBhdGhuYW1lOiBzdHJpbmc7XG4gIHBhcmFtczogQWdub3N0aWNSb3V0ZU1hdGNoW1wicGFyYW1zXCJdO1xuICBkYXRhOiBEYXRhO1xuICBoYW5kbGU6IEhhbmRsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRSb3V0ZU1hdGNoVG9VaU1hdGNoKFxuICBtYXRjaDogQWdub3N0aWNEYXRhUm91dGVNYXRjaCxcbiAgbG9hZGVyRGF0YTogUm91dGVEYXRhXG4pOiBVSU1hdGNoIHtcbiAgbGV0IHsgcm91dGUsIHBhdGhuYW1lLCBwYXJhbXMgfSA9IG1hdGNoO1xuICByZXR1cm4ge1xuICAgIGlkOiByb3V0ZS5pZCxcbiAgICBwYXRobmFtZSxcbiAgICBwYXJhbXMsXG4gICAgZGF0YTogbG9hZGVyRGF0YVtyb3V0ZS5pZF0sXG4gICAgaGFuZGxlOiByb3V0ZS5oYW5kbGUsXG4gIH07XG59XG5cbmludGVyZmFjZSBSb3V0ZU1ldGE8XG4gIFJvdXRlT2JqZWN0VHlwZSBleHRlbmRzIEFnbm9zdGljUm91dGVPYmplY3QgPSBBZ25vc3RpY1JvdXRlT2JqZWN0XG4+IHtcbiAgcmVsYXRpdmVQYXRoOiBzdHJpbmc7XG4gIGNhc2VTZW5zaXRpdmU6IGJvb2xlYW47XG4gIGNoaWxkcmVuSW5kZXg6IG51bWJlcjtcbiAgcm91dGU6IFJvdXRlT2JqZWN0VHlwZTtcbn1cblxuaW50ZXJmYWNlIFJvdXRlQnJhbmNoPFxuICBSb3V0ZU9iamVjdFR5cGUgZXh0ZW5kcyBBZ25vc3RpY1JvdXRlT2JqZWN0ID0gQWdub3N0aWNSb3V0ZU9iamVjdFxuPiB7XG4gIHBhdGg6IHN0cmluZztcbiAgc2NvcmU6IG51bWJlcjtcbiAgcm91dGVzTWV0YTogUm91dGVNZXRhPFJvdXRlT2JqZWN0VHlwZT5bXTtcbn1cblxuZnVuY3Rpb24gZmxhdHRlblJvdXRlczxcbiAgUm91dGVPYmplY3RUeXBlIGV4dGVuZHMgQWdub3N0aWNSb3V0ZU9iamVjdCA9IEFnbm9zdGljUm91dGVPYmplY3Rcbj4oXG4gIHJvdXRlczogUm91dGVPYmplY3RUeXBlW10sXG4gIGJyYW5jaGVzOiBSb3V0ZUJyYW5jaDxSb3V0ZU9iamVjdFR5cGU+W10gPSBbXSxcbiAgcGFyZW50c01ldGE6IFJvdXRlTWV0YTxSb3V0ZU9iamVjdFR5cGU+W10gPSBbXSxcbiAgcGFyZW50UGF0aCA9IFwiXCJcbik6IFJvdXRlQnJhbmNoPFJvdXRlT2JqZWN0VHlwZT5bXSB7XG4gIGxldCBmbGF0dGVuUm91dGUgPSAoXG4gICAgcm91dGU6IFJvdXRlT2JqZWN0VHlwZSxcbiAgICBpbmRleDogbnVtYmVyLFxuICAgIHJlbGF0aXZlUGF0aD86IHN0cmluZ1xuICApID0+IHtcbiAgICBsZXQgbWV0YTogUm91dGVNZXRhPFJvdXRlT2JqZWN0VHlwZT4gPSB7XG4gICAgICByZWxhdGl2ZVBhdGg6XG4gICAgICAgIHJlbGF0aXZlUGF0aCA9PT0gdW5kZWZpbmVkID8gcm91dGUucGF0aCB8fCBcIlwiIDogcmVsYXRpdmVQYXRoLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogcm91dGUuY2FzZVNlbnNpdGl2ZSA9PT0gdHJ1ZSxcbiAgICAgIGNoaWxkcmVuSW5kZXg6IGluZGV4LFxuICAgICAgcm91dGUsXG4gICAgfTtcblxuICAgIGlmIChtZXRhLnJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICBtZXRhLnJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKHBhcmVudFBhdGgpLFxuICAgICAgICBgQWJzb2x1dGUgcm91dGUgcGF0aCBcIiR7bWV0YS5yZWxhdGl2ZVBhdGh9XCIgbmVzdGVkIHVuZGVyIHBhdGggYCArXG4gICAgICAgICAgYFwiJHtwYXJlbnRQYXRofVwiIGlzIG5vdCB2YWxpZC4gQW4gYWJzb2x1dGUgY2hpbGQgcm91dGUgcGF0aCBgICtcbiAgICAgICAgICBgbXVzdCBzdGFydCB3aXRoIHRoZSBjb21iaW5lZCBwYXRoIG9mIGFsbCBpdHMgcGFyZW50IHJvdXRlcy5gXG4gICAgICApO1xuXG4gICAgICBtZXRhLnJlbGF0aXZlUGF0aCA9IG1ldGEucmVsYXRpdmVQYXRoLnNsaWNlKHBhcmVudFBhdGgubGVuZ3RoKTtcbiAgICB9XG5cbiAgICBsZXQgcGF0aCA9IGpvaW5QYXRocyhbcGFyZW50UGF0aCwgbWV0YS5yZWxhdGl2ZVBhdGhdKTtcbiAgICBsZXQgcm91dGVzTWV0YSA9IHBhcmVudHNNZXRhLmNvbmNhdChtZXRhKTtcblxuICAgIC8vIEFkZCB0aGUgY2hpbGRyZW4gYmVmb3JlIGFkZGluZyB0aGlzIHJvdXRlIHRvIHRoZSBhcnJheSwgc28gd2UgdHJhdmVyc2UgdGhlXG4gICAgLy8gcm91dGUgdHJlZSBkZXB0aC1maXJzdCBhbmQgY2hpbGQgcm91dGVzIGFwcGVhciBiZWZvcmUgdGhlaXIgcGFyZW50cyBpblxuICAgIC8vIHRoZSBcImZsYXR0ZW5lZFwiIHZlcnNpb24uXG4gICAgaWYgKHJvdXRlLmNoaWxkcmVuICYmIHJvdXRlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgLy8gT3VyIHR5cGVzIGtub3cgYmV0dGVyLCBidXQgcnVudGltZSBKUyBtYXkgbm90IVxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIHJvdXRlLmluZGV4ICE9PSB0cnVlLFxuICAgICAgICBgSW5kZXggcm91dGVzIG11c3Qgbm90IGhhdmUgY2hpbGQgcm91dGVzLiBQbGVhc2UgcmVtb3ZlIGAgK1xuICAgICAgICAgIGBhbGwgY2hpbGQgcm91dGVzIGZyb20gcm91dGUgcGF0aCBcIiR7cGF0aH1cIi5gXG4gICAgICApO1xuXG4gICAgICBmbGF0dGVuUm91dGVzKHJvdXRlLmNoaWxkcmVuLCBicmFuY2hlcywgcm91dGVzTWV0YSwgcGF0aCk7XG4gICAgfVxuXG4gICAgLy8gUm91dGVzIHdpdGhvdXQgYSBwYXRoIHNob3VsZG4ndCBldmVyIG1hdGNoIGJ5IHRoZW1zZWx2ZXMgdW5sZXNzIHRoZXkgYXJlXG4gICAgLy8gaW5kZXggcm91dGVzLCBzbyBkb24ndCBhZGQgdGhlbSB0byB0aGUgbGlzdCBvZiBwb3NzaWJsZSBicmFuY2hlcy5cbiAgICBpZiAocm91dGUucGF0aCA9PSBudWxsICYmICFyb3V0ZS5pbmRleCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGJyYW5jaGVzLnB1c2goe1xuICAgICAgcGF0aCxcbiAgICAgIHNjb3JlOiBjb21wdXRlU2NvcmUocGF0aCwgcm91dGUuaW5kZXgpLFxuICAgICAgcm91dGVzTWV0YSxcbiAgICB9KTtcbiAgfTtcbiAgcm91dGVzLmZvckVhY2goKHJvdXRlLCBpbmRleCkgPT4ge1xuICAgIC8vIGNvYXJzZS1ncmFpbiBjaGVjayBmb3Igb3B0aW9uYWwgcGFyYW1zXG4gICAgaWYgKHJvdXRlLnBhdGggPT09IFwiXCIgfHwgIXJvdXRlLnBhdGg/LmluY2x1ZGVzKFwiP1wiKSkge1xuICAgICAgZmxhdHRlblJvdXRlKHJvdXRlLCBpbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGV4cGxvZGVkIG9mIGV4cGxvZGVPcHRpb25hbFNlZ21lbnRzKHJvdXRlLnBhdGgpKSB7XG4gICAgICAgIGZsYXR0ZW5Sb3V0ZShyb3V0ZSwgaW5kZXgsIGV4cGxvZGVkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBicmFuY2hlcztcbn1cblxuLyoqXG4gKiBDb21wdXRlcyBhbGwgY29tYmluYXRpb25zIG9mIG9wdGlvbmFsIHBhdGggc2VnbWVudHMgZm9yIGEgZ2l2ZW4gcGF0aCxcbiAqIGV4Y2x1ZGluZyBjb21iaW5hdGlvbnMgdGhhdCBhcmUgYW1iaWd1b3VzIGFuZCBvZiBsb3dlciBwcmlvcml0eS5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgYC9vbmUvOnR3bz8vdGhyZWUvOmZvdXI/LzpmaXZlP2AgZXhwbG9kZXMgdG86XG4gKiAtIGAvb25lL3RocmVlYFxuICogLSBgL29uZS86dHdvL3RocmVlYFxuICogLSBgL29uZS90aHJlZS86Zm91cmBcbiAqIC0gYC9vbmUvdGhyZWUvOmZpdmVgXG4gKiAtIGAvb25lLzp0d28vdGhyZWUvOmZvdXJgXG4gKiAtIGAvb25lLzp0d28vdGhyZWUvOmZpdmVgXG4gKiAtIGAvb25lL3RocmVlLzpmb3VyLzpmaXZlYFxuICogLSBgL29uZS86dHdvL3RocmVlLzpmb3VyLzpmaXZlYFxuICovXG5mdW5jdGlvbiBleHBsb2RlT3B0aW9uYWxTZWdtZW50cyhwYXRoOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gIGxldCBzZWdtZW50cyA9IHBhdGguc3BsaXQoXCIvXCIpO1xuICBpZiAoc2VnbWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gW107XG5cbiAgbGV0IFtmaXJzdCwgLi4ucmVzdF0gPSBzZWdtZW50cztcblxuICAvLyBPcHRpb25hbCBwYXRoIHNlZ21lbnRzIGFyZSBkZW5vdGVkIGJ5IGEgdHJhaWxpbmcgYD9gXG4gIGxldCBpc09wdGlvbmFsID0gZmlyc3QuZW5kc1dpdGgoXCI/XCIpO1xuICAvLyBDb21wdXRlIHRoZSBjb3JyZXNwb25kaW5nIHJlcXVpcmVkIHNlZ21lbnQ6IGBmb28/YCAtPiBgZm9vYFxuICBsZXQgcmVxdWlyZWQgPSBmaXJzdC5yZXBsYWNlKC9cXD8kLywgXCJcIik7XG5cbiAgaWYgKHJlc3QubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSW50ZXByZXQgZW1wdHkgc3RyaW5nIGFzIG9taXR0aW5nIGFuIG9wdGlvbmFsIHNlZ21lbnRcbiAgICAvLyBgW1wib25lXCIsIFwiXCIsIFwidGhyZWVcIl1gIGNvcnJlc3BvbmRzIHRvIG9taXR0aW5nIGA6dHdvYCBmcm9tIGAvb25lLzp0d28/L3RocmVlYCAtPiBgL29uZS90aHJlZWBcbiAgICByZXR1cm4gaXNPcHRpb25hbCA/IFtyZXF1aXJlZCwgXCJcIl0gOiBbcmVxdWlyZWRdO1xuICB9XG5cbiAgbGV0IHJlc3RFeHBsb2RlZCA9IGV4cGxvZGVPcHRpb25hbFNlZ21lbnRzKHJlc3Quam9pbihcIi9cIikpO1xuXG4gIGxldCByZXN1bHQ6IHN0cmluZ1tdID0gW107XG5cbiAgLy8gQWxsIGNoaWxkIHBhdGhzIHdpdGggdGhlIHByZWZpeC4gIERvIHRoaXMgZm9yIGFsbCBjaGlsZHJlbiBiZWZvcmUgdGhlXG4gIC8vIG9wdGlvbmFsIHZlcnNpb24gZm9yIGFsbCBjaGlsZHJlbiwgc28gd2UgZ2V0IGNvbnNpc3RlbnQgb3JkZXJpbmcgd2hlcmUgdGhlXG4gIC8vIHBhcmVudCBvcHRpb25hbCBhc3BlY3QgaXMgcHJlZmVycmVkIGFzIHJlcXVpcmVkLiAgT3RoZXJ3aXNlLCB3ZSBjYW4gZ2V0XG4gIC8vIGNoaWxkIHNlY3Rpb25zIGludGVyc3BlcnNlZCB3aGVyZSBkZWVwZXIgb3B0aW9uYWwgc2VnbWVudHMgYXJlIGhpZ2hlciB0aGFuXG4gIC8vIHBhcmVudCBvcHRpb25hbCBzZWdtZW50cywgd2hlcmUgZm9yIGV4YW1wbGUsIC86dHdvIHdvdWxkIGV4cGxvZGUgX2VhcmxpZXJfXG4gIC8vIHRoZW4gLzpvbmUuICBCeSBhbHdheXMgaW5jbHVkaW5nIHRoZSBwYXJlbnQgYXMgcmVxdWlyZWQgX2ZvciBhbGwgY2hpbGRyZW5fXG4gIC8vIGZpcnN0LCB3ZSBhdm9pZCB0aGlzIGlzc3VlXG4gIHJlc3VsdC5wdXNoKFxuICAgIC4uLnJlc3RFeHBsb2RlZC5tYXAoKHN1YnBhdGgpID0+XG4gICAgICBzdWJwYXRoID09PSBcIlwiID8gcmVxdWlyZWQgOiBbcmVxdWlyZWQsIHN1YnBhdGhdLmpvaW4oXCIvXCIpXG4gICAgKVxuICApO1xuXG4gIC8vIFRoZW4sIGlmIHRoaXMgaXMgYW4gb3B0aW9uYWwgdmFsdWUsIGFkZCBhbGwgY2hpbGQgdmVyc2lvbnMgd2l0aG91dFxuICBpZiAoaXNPcHRpb25hbCkge1xuICAgIHJlc3VsdC5wdXNoKC4uLnJlc3RFeHBsb2RlZCk7XG4gIH1cblxuICAvLyBmb3IgYWJzb2x1dGUgcGF0aHMsIGVuc3VyZSBgL2AgaW5zdGVhZCBvZiBlbXB0eSBzZWdtZW50XG4gIHJldHVybiByZXN1bHQubWFwKChleHBsb2RlZCkgPT5cbiAgICBwYXRoLnN0YXJ0c1dpdGgoXCIvXCIpICYmIGV4cGxvZGVkID09PSBcIlwiID8gXCIvXCIgOiBleHBsb2RlZFxuICApO1xufVxuXG5mdW5jdGlvbiByYW5rUm91dGVCcmFuY2hlcyhicmFuY2hlczogUm91dGVCcmFuY2hbXSk6IHZvaWQge1xuICBicmFuY2hlcy5zb3J0KChhLCBiKSA9PlxuICAgIGEuc2NvcmUgIT09IGIuc2NvcmVcbiAgICAgID8gYi5zY29yZSAtIGEuc2NvcmUgLy8gSGlnaGVyIHNjb3JlIGZpcnN0XG4gICAgICA6IGNvbXBhcmVJbmRleGVzKFxuICAgICAgICAgIGEucm91dGVzTWV0YS5tYXAoKG1ldGEpID0+IG1ldGEuY2hpbGRyZW5JbmRleCksXG4gICAgICAgICAgYi5yb3V0ZXNNZXRhLm1hcCgobWV0YSkgPT4gbWV0YS5jaGlsZHJlbkluZGV4KVxuICAgICAgICApXG4gICk7XG59XG5cbmNvbnN0IHBhcmFtUmUgPSAvXjpcXHcrJC87XG5jb25zdCBkeW5hbWljU2VnbWVudFZhbHVlID0gMztcbmNvbnN0IGluZGV4Um91dGVWYWx1ZSA9IDI7XG5jb25zdCBlbXB0eVNlZ21lbnRWYWx1ZSA9IDE7XG5jb25zdCBzdGF0aWNTZWdtZW50VmFsdWUgPSAxMDtcbmNvbnN0IHNwbGF0UGVuYWx0eSA9IC0yO1xuY29uc3QgaXNTcGxhdCA9IChzOiBzdHJpbmcpID0+IHMgPT09IFwiKlwiO1xuXG5mdW5jdGlvbiBjb21wdXRlU2NvcmUocGF0aDogc3RyaW5nLCBpbmRleDogYm9vbGVhbiB8IHVuZGVmaW5lZCk6IG51bWJlciB7XG4gIGxldCBzZWdtZW50cyA9IHBhdGguc3BsaXQoXCIvXCIpO1xuICBsZXQgaW5pdGlhbFNjb3JlID0gc2VnbWVudHMubGVuZ3RoO1xuICBpZiAoc2VnbWVudHMuc29tZShpc1NwbGF0KSkge1xuICAgIGluaXRpYWxTY29yZSArPSBzcGxhdFBlbmFsdHk7XG4gIH1cblxuICBpZiAoaW5kZXgpIHtcbiAgICBpbml0aWFsU2NvcmUgKz0gaW5kZXhSb3V0ZVZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHNlZ21lbnRzXG4gICAgLmZpbHRlcigocykgPT4gIWlzU3BsYXQocykpXG4gICAgLnJlZHVjZShcbiAgICAgIChzY29yZSwgc2VnbWVudCkgPT5cbiAgICAgICAgc2NvcmUgK1xuICAgICAgICAocGFyYW1SZS50ZXN0KHNlZ21lbnQpXG4gICAgICAgICAgPyBkeW5hbWljU2VnbWVudFZhbHVlXG4gICAgICAgICAgOiBzZWdtZW50ID09PSBcIlwiXG4gICAgICAgICAgPyBlbXB0eVNlZ21lbnRWYWx1ZVxuICAgICAgICAgIDogc3RhdGljU2VnbWVudFZhbHVlKSxcbiAgICAgIGluaXRpYWxTY29yZVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVJbmRleGVzKGE6IG51bWJlcltdLCBiOiBudW1iZXJbXSk6IG51bWJlciB7XG4gIGxldCBzaWJsaW5ncyA9XG4gICAgYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuc2xpY2UoMCwgLTEpLmV2ZXJ5KChuLCBpKSA9PiBuID09PSBiW2ldKTtcblxuICByZXR1cm4gc2libGluZ3NcbiAgICA/IC8vIElmIHR3byByb3V0ZXMgYXJlIHNpYmxpbmdzLCB3ZSBzaG91bGQgdHJ5IHRvIG1hdGNoIHRoZSBlYXJsaWVyIHNpYmxpbmdcbiAgICAgIC8vIGZpcnN0LiBUaGlzIGFsbG93cyBwZW9wbGUgdG8gaGF2ZSBmaW5lLWdyYWluZWQgY29udHJvbCBvdmVyIHRoZSBtYXRjaGluZ1xuICAgICAgLy8gYmVoYXZpb3IgYnkgc2ltcGx5IHB1dHRpbmcgcm91dGVzIHdpdGggaWRlbnRpY2FsIHBhdGhzIGluIHRoZSBvcmRlciB0aGV5XG4gICAgICAvLyB3YW50IHRoZW0gdHJpZWQuXG4gICAgICBhW2EubGVuZ3RoIC0gMV0gLSBiW2IubGVuZ3RoIC0gMV1cbiAgICA6IC8vIE90aGVyd2lzZSwgaXQgZG9lc24ndCByZWFsbHkgbWFrZSBzZW5zZSB0byByYW5rIG5vbi1zaWJsaW5ncyBieSBpbmRleCxcbiAgICAgIC8vIHNvIHRoZXkgc29ydCBlcXVhbGx5LlxuICAgICAgMDtcbn1cblxuZnVuY3Rpb24gbWF0Y2hSb3V0ZUJyYW5jaDxcbiAgUGFyYW1LZXkgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmcsXG4gIFJvdXRlT2JqZWN0VHlwZSBleHRlbmRzIEFnbm9zdGljUm91dGVPYmplY3QgPSBBZ25vc3RpY1JvdXRlT2JqZWN0XG4+KFxuICBicmFuY2g6IFJvdXRlQnJhbmNoPFJvdXRlT2JqZWN0VHlwZT4sXG4gIHBhdGhuYW1lOiBzdHJpbmdcbik6IEFnbm9zdGljUm91dGVNYXRjaDxQYXJhbUtleSwgUm91dGVPYmplY3RUeXBlPltdIHwgbnVsbCB7XG4gIGxldCB7IHJvdXRlc01ldGEgfSA9IGJyYW5jaDtcblxuICBsZXQgbWF0Y2hlZFBhcmFtcyA9IHt9O1xuICBsZXQgbWF0Y2hlZFBhdGhuYW1lID0gXCIvXCI7XG4gIGxldCBtYXRjaGVzOiBBZ25vc3RpY1JvdXRlTWF0Y2g8UGFyYW1LZXksIFJvdXRlT2JqZWN0VHlwZT5bXSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdXRlc01ldGEubGVuZ3RoOyArK2kpIHtcbiAgICBsZXQgbWV0YSA9IHJvdXRlc01ldGFbaV07XG4gICAgbGV0IGVuZCA9IGkgPT09IHJvdXRlc01ldGEubGVuZ3RoIC0gMTtcbiAgICBsZXQgcmVtYWluaW5nUGF0aG5hbWUgPVxuICAgICAgbWF0Y2hlZFBhdGhuYW1lID09PSBcIi9cIlxuICAgICAgICA/IHBhdGhuYW1lXG4gICAgICAgIDogcGF0aG5hbWUuc2xpY2UobWF0Y2hlZFBhdGhuYW1lLmxlbmd0aCkgfHwgXCIvXCI7XG4gICAgbGV0IG1hdGNoID0gbWF0Y2hQYXRoKFxuICAgICAgeyBwYXRoOiBtZXRhLnJlbGF0aXZlUGF0aCwgY2FzZVNlbnNpdGl2ZTogbWV0YS5jYXNlU2Vuc2l0aXZlLCBlbmQgfSxcbiAgICAgIHJlbWFpbmluZ1BhdGhuYW1lXG4gICAgKTtcblxuICAgIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuXG4gICAgT2JqZWN0LmFzc2lnbihtYXRjaGVkUGFyYW1zLCBtYXRjaC5wYXJhbXMpO1xuXG4gICAgbGV0IHJvdXRlID0gbWV0YS5yb3V0ZTtcblxuICAgIG1hdGNoZXMucHVzaCh7XG4gICAgICAvLyBUT0RPOiBDYW4gdGhpcyBhcyBiZSBhdm9pZGVkP1xuICAgICAgcGFyYW1zOiBtYXRjaGVkUGFyYW1zIGFzIFBhcmFtczxQYXJhbUtleT4sXG4gICAgICBwYXRobmFtZTogam9pblBhdGhzKFttYXRjaGVkUGF0aG5hbWUsIG1hdGNoLnBhdGhuYW1lXSksXG4gICAgICBwYXRobmFtZUJhc2U6IG5vcm1hbGl6ZVBhdGhuYW1lKFxuICAgICAgICBqb2luUGF0aHMoW21hdGNoZWRQYXRobmFtZSwgbWF0Y2gucGF0aG5hbWVCYXNlXSlcbiAgICAgICksXG4gICAgICByb3V0ZSxcbiAgICB9KTtcblxuICAgIGlmIChtYXRjaC5wYXRobmFtZUJhc2UgIT09IFwiL1wiKSB7XG4gICAgICBtYXRjaGVkUGF0aG5hbWUgPSBqb2luUGF0aHMoW21hdGNoZWRQYXRobmFtZSwgbWF0Y2gucGF0aG5hbWVCYXNlXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXM7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHBhdGggd2l0aCBwYXJhbXMgaW50ZXJwb2xhdGVkLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vdXRpbHMvZ2VuZXJhdGUtcGF0aFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVQYXRoPFBhdGggZXh0ZW5kcyBzdHJpbmc+KFxuICBvcmlnaW5hbFBhdGg6IFBhdGgsXG4gIHBhcmFtczoge1xuICAgIFtrZXkgaW4gUGF0aFBhcmFtPFBhdGg+XTogc3RyaW5nIHwgbnVsbDtcbiAgfSA9IHt9IGFzIGFueVxuKTogc3RyaW5nIHtcbiAgbGV0IHBhdGg6IHN0cmluZyA9IG9yaWdpbmFsUGF0aDtcbiAgaWYgKHBhdGguZW5kc1dpdGgoXCIqXCIpICYmIHBhdGggIT09IFwiKlwiICYmICFwYXRoLmVuZHNXaXRoKFwiLypcIikpIHtcbiAgICB3YXJuaW5nKFxuICAgICAgZmFsc2UsXG4gICAgICBgUm91dGUgcGF0aCBcIiR7cGF0aH1cIiB3aWxsIGJlIHRyZWF0ZWQgYXMgaWYgaXQgd2VyZSBgICtcbiAgICAgICAgYFwiJHtwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpfVwiIGJlY2F1c2UgdGhlIFxcYCpcXGAgY2hhcmFjdGVyIG11c3QgYCArXG4gICAgICAgIGBhbHdheXMgZm9sbG93IGEgXFxgL1xcYCBpbiB0aGUgcGF0dGVybi4gVG8gZ2V0IHJpZCBvZiB0aGlzIHdhcm5pbmcsIGAgK1xuICAgICAgICBgcGxlYXNlIGNoYW5nZSB0aGUgcm91dGUgcGF0aCB0byBcIiR7cGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKX1cIi5gXG4gICAgKTtcbiAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKSBhcyBQYXRoO1xuICB9XG5cbiAgLy8gZW5zdXJlIGAvYCBpcyBhZGRlZCBhdCB0aGUgYmVnaW5uaW5nIGlmIHRoZSBwYXRoIGlzIGFic29sdXRlXG4gIGNvbnN0IHByZWZpeCA9IHBhdGguc3RhcnRzV2l0aChcIi9cIikgPyBcIi9cIiA6IFwiXCI7XG5cbiAgY29uc3Qgc3RyaW5naWZ5ID0gKHA6IGFueSkgPT5cbiAgICBwID09IG51bGwgPyBcIlwiIDogdHlwZW9mIHAgPT09IFwic3RyaW5nXCIgPyBwIDogU3RyaW5nKHApO1xuXG4gIGNvbnN0IHNlZ21lbnRzID0gcGF0aFxuICAgIC5zcGxpdCgvXFwvKy8pXG4gICAgLm1hcCgoc2VnbWVudCwgaW5kZXgsIGFycmF5KSA9PiB7XG4gICAgICBjb25zdCBpc0xhc3RTZWdtZW50ID0gaW5kZXggPT09IGFycmF5Lmxlbmd0aCAtIDE7XG5cbiAgICAgIC8vIG9ubHkgYXBwbHkgdGhlIHNwbGF0IGlmIGl0J3MgdGhlIGxhc3Qgc2VnbWVudFxuICAgICAgaWYgKGlzTGFzdFNlZ21lbnQgJiYgc2VnbWVudCA9PT0gXCIqXCIpIHtcbiAgICAgICAgY29uc3Qgc3RhciA9IFwiKlwiIGFzIFBhdGhQYXJhbTxQYXRoPjtcbiAgICAgICAgLy8gQXBwbHkgdGhlIHNwbGF0XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnkocGFyYW1zW3N0YXJdKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qga2V5TWF0Y2ggPSBzZWdtZW50Lm1hdGNoKC9eOihcXHcrKShcXD8/KSQvKTtcbiAgICAgIGlmIChrZXlNYXRjaCkge1xuICAgICAgICBjb25zdCBbLCBrZXksIG9wdGlvbmFsXSA9IGtleU1hdGNoO1xuICAgICAgICBsZXQgcGFyYW0gPSBwYXJhbXNba2V5IGFzIFBhdGhQYXJhbTxQYXRoPl07XG4gICAgICAgIGludmFyaWFudChvcHRpb25hbCA9PT0gXCI/XCIgfHwgcGFyYW0gIT0gbnVsbCwgYE1pc3NpbmcgXCI6JHtrZXl9XCIgcGFyYW1gKTtcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShwYXJhbSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBhbnkgb3B0aW9uYWwgbWFya2VycyBmcm9tIG9wdGlvbmFsIHN0YXRpYyBzZWdtZW50c1xuICAgICAgcmV0dXJuIHNlZ21lbnQucmVwbGFjZSgvXFw/JC9nLCBcIlwiKTtcbiAgICB9KVxuICAgIC8vIFJlbW92ZSBlbXB0eSBzZWdtZW50c1xuICAgIC5maWx0ZXIoKHNlZ21lbnQpID0+ICEhc2VnbWVudCk7XG5cbiAgcmV0dXJuIHByZWZpeCArIHNlZ21lbnRzLmpvaW4oXCIvXCIpO1xufVxuXG4vKipcbiAqIEEgUGF0aFBhdHRlcm4gaXMgdXNlZCB0byBtYXRjaCBvbiBzb21lIHBvcnRpb24gb2YgYSBVUkwgcGF0aG5hbWUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGF0aFBhdHRlcm48UGF0aCBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4ge1xuICAvKipcbiAgICogQSBzdHJpbmcgdG8gbWF0Y2ggYWdhaW5zdCBhIFVSTCBwYXRobmFtZS4gTWF5IGNvbnRhaW4gYDppZGAtc3R5bGUgc2VnbWVudHNcbiAgICogdG8gaW5kaWNhdGUgcGxhY2Vob2xkZXJzIGZvciBkeW5hbWljIHBhcmFtZXRlcnMuIE1heSBhbHNvIGVuZCB3aXRoIGAvKmAgdG9cbiAgICogaW5kaWNhdGUgbWF0Y2hpbmcgdGhlIHJlc3Qgb2YgdGhlIFVSTCBwYXRobmFtZS5cbiAgICovXG4gIHBhdGg6IFBhdGg7XG4gIC8qKlxuICAgKiBTaG91bGQgYmUgYHRydWVgIGlmIHRoZSBzdGF0aWMgcG9ydGlvbnMgb2YgdGhlIGBwYXRoYCBzaG91bGQgYmUgbWF0Y2hlZCBpblxuICAgKiB0aGUgc2FtZSBjYXNlLlxuICAgKi9cbiAgY2FzZVNlbnNpdGl2ZT86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBTaG91bGQgYmUgYHRydWVgIGlmIHRoaXMgcGF0dGVybiBzaG91bGQgbWF0Y2ggdGhlIGVudGlyZSBVUkwgcGF0aG5hbWUuXG4gICAqL1xuICBlbmQ/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIEEgUGF0aE1hdGNoIGNvbnRhaW5zIGluZm8gYWJvdXQgaG93IGEgUGF0aFBhdHRlcm4gbWF0Y2hlZCBvbiBhIFVSTCBwYXRobmFtZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQYXRoTWF0Y2g8UGFyYW1LZXkgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+IHtcbiAgLyoqXG4gICAqIFRoZSBuYW1lcyBhbmQgdmFsdWVzIG9mIGR5bmFtaWMgcGFyYW1ldGVycyBpbiB0aGUgVVJMLlxuICAgKi9cbiAgcGFyYW1zOiBQYXJhbXM8UGFyYW1LZXk+O1xuICAvKipcbiAgICogVGhlIHBvcnRpb24gb2YgdGhlIFVSTCBwYXRobmFtZSB0aGF0IHdhcyBtYXRjaGVkLlxuICAgKi9cbiAgcGF0aG5hbWU6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgcGF0aG5hbWUgdGhhdCB3YXMgbWF0Y2hlZCBiZWZvcmUgY2hpbGQgcm91dGVzLlxuICAgKi9cbiAgcGF0aG5hbWVCYXNlOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgcGF0dGVybiB0aGF0IHdhcyB1c2VkIHRvIG1hdGNoLlxuICAgKi9cbiAgcGF0dGVybjogUGF0aFBhdHRlcm47XG59XG5cbnR5cGUgTXV0YWJsZTxUPiA9IHtcbiAgLXJlYWRvbmx5IFtQIGluIGtleW9mIFRdOiBUW1BdO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBwYXR0ZXJuIG1hdGNoaW5nIG9uIGEgVVJMIHBhdGhuYW1lIGFuZCByZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0XG4gKiB0aGUgbWF0Y2guXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS91dGlscy9tYXRjaC1wYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaFBhdGg8XG4gIFBhcmFtS2V5IGV4dGVuZHMgUGFyYW1QYXJzZUtleTxQYXRoPixcbiAgUGF0aCBleHRlbmRzIHN0cmluZ1xuPihcbiAgcGF0dGVybjogUGF0aFBhdHRlcm48UGF0aD4gfCBQYXRoLFxuICBwYXRobmFtZTogc3RyaW5nXG4pOiBQYXRoTWF0Y2g8UGFyYW1LZXk+IHwgbnVsbCB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gXCJzdHJpbmdcIikge1xuICAgIHBhdHRlcm4gPSB7IHBhdGg6IHBhdHRlcm4sIGNhc2VTZW5zaXRpdmU6IGZhbHNlLCBlbmQ6IHRydWUgfTtcbiAgfVxuXG4gIGxldCBbbWF0Y2hlciwgY29tcGlsZWRQYXJhbXNdID0gY29tcGlsZVBhdGgoXG4gICAgcGF0dGVybi5wYXRoLFxuICAgIHBhdHRlcm4uY2FzZVNlbnNpdGl2ZSxcbiAgICBwYXR0ZXJuLmVuZFxuICApO1xuXG4gIGxldCBtYXRjaCA9IHBhdGhuYW1lLm1hdGNoKG1hdGNoZXIpO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcblxuICBsZXQgbWF0Y2hlZFBhdGhuYW1lID0gbWF0Y2hbMF07XG4gIGxldCBwYXRobmFtZUJhc2UgPSBtYXRjaGVkUGF0aG5hbWUucmVwbGFjZSgvKC4pXFwvKyQvLCBcIiQxXCIpO1xuICBsZXQgY2FwdHVyZUdyb3VwcyA9IG1hdGNoLnNsaWNlKDEpO1xuICBsZXQgcGFyYW1zOiBQYXJhbXMgPSBjb21waWxlZFBhcmFtcy5yZWR1Y2U8TXV0YWJsZTxQYXJhbXM+PihcbiAgICAobWVtbywgeyBwYXJhbU5hbWUsIGlzT3B0aW9uYWwgfSwgaW5kZXgpID0+IHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gY29tcHV0ZSB0aGUgcGF0aG5hbWVCYXNlIGhlcmUgdXNpbmcgdGhlIHJhdyBzcGxhdCB2YWx1ZVxuICAgICAgLy8gaW5zdGVhZCBvZiB1c2luZyBwYXJhbXNbXCIqXCJdIGxhdGVyIGJlY2F1c2UgaXQgd2lsbCBiZSBkZWNvZGVkIHRoZW5cbiAgICAgIGlmIChwYXJhbU5hbWUgPT09IFwiKlwiKSB7XG4gICAgICAgIGxldCBzcGxhdFZhbHVlID0gY2FwdHVyZUdyb3Vwc1tpbmRleF0gfHwgXCJcIjtcbiAgICAgICAgcGF0aG5hbWVCYXNlID0gbWF0Y2hlZFBhdGhuYW1lXG4gICAgICAgICAgLnNsaWNlKDAsIG1hdGNoZWRQYXRobmFtZS5sZW5ndGggLSBzcGxhdFZhbHVlLmxlbmd0aClcbiAgICAgICAgICAucmVwbGFjZSgvKC4pXFwvKyQvLCBcIiQxXCIpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB2YWx1ZSA9IGNhcHR1cmVHcm91cHNbaW5kZXhdO1xuICAgICAgaWYgKGlzT3B0aW9uYWwgJiYgIXZhbHVlKSB7XG4gICAgICAgIG1lbW9bcGFyYW1OYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lbW9bcGFyYW1OYW1lXSA9IHNhZmVseURlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSB8fCBcIlwiLCBwYXJhbU5hbWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfSxcbiAgICB7fVxuICApO1xuXG4gIHJldHVybiB7XG4gICAgcGFyYW1zLFxuICAgIHBhdGhuYW1lOiBtYXRjaGVkUGF0aG5hbWUsXG4gICAgcGF0aG5hbWVCYXNlLFxuICAgIHBhdHRlcm4sXG4gIH07XG59XG5cbnR5cGUgQ29tcGlsZWRQYXRoUGFyYW0gPSB7IHBhcmFtTmFtZTogc3RyaW5nOyBpc09wdGlvbmFsPzogYm9vbGVhbiB9O1xuXG5mdW5jdGlvbiBjb21waWxlUGF0aChcbiAgcGF0aDogc3RyaW5nLFxuICBjYXNlU2Vuc2l0aXZlID0gZmFsc2UsXG4gIGVuZCA9IHRydWVcbik6IFtSZWdFeHAsIENvbXBpbGVkUGF0aFBhcmFtW11dIHtcbiAgd2FybmluZyhcbiAgICBwYXRoID09PSBcIipcIiB8fCAhcGF0aC5lbmRzV2l0aChcIipcIikgfHwgcGF0aC5lbmRzV2l0aChcIi8qXCIpLFxuICAgIGBSb3V0ZSBwYXRoIFwiJHtwYXRofVwiIHdpbGwgYmUgdHJlYXRlZCBhcyBpZiBpdCB3ZXJlIGAgK1xuICAgICAgYFwiJHtwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpfVwiIGJlY2F1c2UgdGhlIFxcYCpcXGAgY2hhcmFjdGVyIG11c3QgYCArXG4gICAgICBgYWx3YXlzIGZvbGxvdyBhIFxcYC9cXGAgaW4gdGhlIHBhdHRlcm4uIFRvIGdldCByaWQgb2YgdGhpcyB3YXJuaW5nLCBgICtcbiAgICAgIGBwbGVhc2UgY2hhbmdlIHRoZSByb3V0ZSBwYXRoIHRvIFwiJHtwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpfVwiLmBcbiAgKTtcblxuICBsZXQgcGFyYW1zOiBDb21waWxlZFBhdGhQYXJhbVtdID0gW107XG4gIGxldCByZWdleHBTb3VyY2UgPVxuICAgIFwiXlwiICtcbiAgICBwYXRoXG4gICAgICAucmVwbGFjZSgvXFwvKlxcKj8kLywgXCJcIikgLy8gSWdub3JlIHRyYWlsaW5nIC8gYW5kIC8qLCB3ZSdsbCBoYW5kbGUgaXQgYmVsb3dcbiAgICAgIC5yZXBsYWNlKC9eXFwvKi8sIFwiL1wiKSAvLyBNYWtlIHN1cmUgaXQgaGFzIGEgbGVhZGluZyAvXG4gICAgICAucmVwbGFjZSgvW1xcXFwuKiteJHt9fCgpW1xcXV0vZywgXCJcXFxcJCZcIikgLy8gRXNjYXBlIHNwZWNpYWwgcmVnZXggY2hhcnNcbiAgICAgIC5yZXBsYWNlKC9cXC86KFxcdyspKFxcPyk/L2csIChfOiBzdHJpbmcsIHBhcmFtTmFtZTogc3RyaW5nLCBpc09wdGlvbmFsKSA9PiB7XG4gICAgICAgIHBhcmFtcy5wdXNoKHsgcGFyYW1OYW1lLCBpc09wdGlvbmFsOiBpc09wdGlvbmFsICE9IG51bGwgfSk7XG4gICAgICAgIHJldHVybiBpc09wdGlvbmFsID8gXCIvPyhbXlxcXFwvXSspP1wiIDogXCIvKFteXFxcXC9dKylcIjtcbiAgICAgIH0pO1xuXG4gIGlmIChwYXRoLmVuZHNXaXRoKFwiKlwiKSkge1xuICAgIHBhcmFtcy5wdXNoKHsgcGFyYW1OYW1lOiBcIipcIiB9KTtcbiAgICByZWdleHBTb3VyY2UgKz1cbiAgICAgIHBhdGggPT09IFwiKlwiIHx8IHBhdGggPT09IFwiLypcIlxuICAgICAgICA/IFwiKC4qKSRcIiAvLyBBbHJlYWR5IG1hdGNoZWQgdGhlIGluaXRpYWwgLywganVzdCBtYXRjaCB0aGUgcmVzdFxuICAgICAgICA6IFwiKD86XFxcXC8oLispfFxcXFwvKikkXCI7IC8vIERvbid0IGluY2x1ZGUgdGhlIC8gaW4gcGFyYW1zW1wiKlwiXVxuICB9IGVsc2UgaWYgKGVuZCkge1xuICAgIC8vIFdoZW4gbWF0Y2hpbmcgdG8gdGhlIGVuZCwgaWdub3JlIHRyYWlsaW5nIHNsYXNoZXNcbiAgICByZWdleHBTb3VyY2UgKz0gXCJcXFxcLyokXCI7XG4gIH0gZWxzZSBpZiAocGF0aCAhPT0gXCJcIiAmJiBwYXRoICE9PSBcIi9cIikge1xuICAgIC8vIElmIG91ciBwYXRoIGlzIG5vbi1lbXB0eSBhbmQgY29udGFpbnMgYW55dGhpbmcgYmV5b25kIGFuIGluaXRpYWwgc2xhc2gsXG4gICAgLy8gdGhlbiB3ZSBoYXZlIF9zb21lXyBmb3JtIG9mIHBhdGggaW4gb3VyIHJlZ2V4LCBzbyB3ZSBzaG91bGQgZXhwZWN0IHRvXG4gICAgLy8gbWF0Y2ggb25seSBpZiB3ZSBmaW5kIHRoZSBlbmQgb2YgdGhpcyBwYXRoIHNlZ21lbnQuICBMb29rIGZvciBhbiBvcHRpb25hbFxuICAgIC8vIG5vbi1jYXB0dXJlZCB0cmFpbGluZyBzbGFzaCAodG8gbWF0Y2ggYSBwb3J0aW9uIG9mIHRoZSBVUkwpIG9yIHRoZSBlbmRcbiAgICAvLyBvZiB0aGUgcGF0aCAoaWYgd2UndmUgbWF0Y2hlZCB0byB0aGUgZW5kKS4gIFdlIHVzZWQgdG8gZG8gdGhpcyB3aXRoIGFcbiAgICAvLyB3b3JkIGJvdW5kYXJ5IGJ1dCB0aGF0IGdpdmVzIGZhbHNlIHBvc2l0aXZlcyBvbiByb3V0ZXMgbGlrZVxuICAgIC8vIC91c2VyLXByZWZlcmVuY2VzIHNpbmNlIGAtYCBjb3VudHMgYXMgYSB3b3JkIGJvdW5kYXJ5LlxuICAgIHJlZ2V4cFNvdXJjZSArPSBcIig/Oig/PVxcXFwvfCQpKVwiO1xuICB9IGVsc2Uge1xuICAgIC8vIE5vdGhpbmcgdG8gbWF0Y2ggZm9yIFwiXCIgb3IgXCIvXCJcbiAgfVxuXG4gIGxldCBtYXRjaGVyID0gbmV3IFJlZ0V4cChyZWdleHBTb3VyY2UsIGNhc2VTZW5zaXRpdmUgPyB1bmRlZmluZWQgOiBcImlcIik7XG5cbiAgcmV0dXJuIFttYXRjaGVyLCBwYXJhbXNdO1xufVxuXG5mdW5jdGlvbiBzYWZlbHlEZWNvZGVVUkkodmFsdWU6IHN0cmluZykge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUkkodmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHdhcm5pbmcoXG4gICAgICBmYWxzZSxcbiAgICAgIGBUaGUgVVJMIHBhdGggXCIke3ZhbHVlfVwiIGNvdWxkIG5vdCBiZSBkZWNvZGVkIGJlY2F1c2UgaXQgaXMgaXMgYSBgICtcbiAgICAgICAgYG1hbGZvcm1lZCBVUkwgc2VnbWVudC4gVGhpcyBpcyBwcm9iYWJseSBkdWUgdG8gYSBiYWQgcGVyY2VudCBgICtcbiAgICAgICAgYGVuY29kaW5nICgke2Vycm9yfSkuYFxuICAgICk7XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2FmZWx5RGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlOiBzdHJpbmcsIHBhcmFtTmFtZTogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgd2FybmluZyhcbiAgICAgIGZhbHNlLFxuICAgICAgYFRoZSB2YWx1ZSBmb3IgdGhlIFVSTCBwYXJhbSBcIiR7cGFyYW1OYW1lfVwiIHdpbGwgbm90IGJlIGRlY29kZWQgYmVjYXVzZWAgK1xuICAgICAgICBgIHRoZSBzdHJpbmcgXCIke3ZhbHVlfVwiIGlzIGEgbWFsZm9ybWVkIFVSTCBzZWdtZW50LiBUaGlzIGlzIHByb2JhYmx5YCArXG4gICAgICAgIGAgZHVlIHRvIGEgYmFkIHBlcmNlbnQgZW5jb2RpbmcgKCR7ZXJyb3J9KS5gXG4gICAgKTtcblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpcEJhc2VuYW1lKFxuICBwYXRobmFtZTogc3RyaW5nLFxuICBiYXNlbmFtZTogc3RyaW5nXG4pOiBzdHJpbmcgfCBudWxsIHtcbiAgaWYgKGJhc2VuYW1lID09PSBcIi9cIikgcmV0dXJuIHBhdGhuYW1lO1xuXG4gIGlmICghcGF0aG5hbWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKGJhc2VuYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBXZSB3YW50IHRvIGxlYXZlIHRyYWlsaW5nIHNsYXNoIGJlaGF2aW9yIGluIHRoZSB1c2VyJ3MgY29udHJvbCwgc28gaWYgdGhleVxuICAvLyBzcGVjaWZ5IGEgYmFzZW5hbWUgd2l0aCBhIHRyYWlsaW5nIHNsYXNoLCB3ZSBzaG91bGQgc3VwcG9ydCBpdFxuICBsZXQgc3RhcnRJbmRleCA9IGJhc2VuYW1lLmVuZHNXaXRoKFwiL1wiKVxuICAgID8gYmFzZW5hbWUubGVuZ3RoIC0gMVxuICAgIDogYmFzZW5hbWUubGVuZ3RoO1xuICBsZXQgbmV4dENoYXIgPSBwYXRobmFtZS5jaGFyQXQoc3RhcnRJbmRleCk7XG4gIGlmIChuZXh0Q2hhciAmJiBuZXh0Q2hhciAhPT0gXCIvXCIpIHtcbiAgICAvLyBwYXRobmFtZSBkb2VzIG5vdCBzdGFydCB3aXRoIGJhc2VuYW1lL1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHBhdGhuYW1lLnNsaWNlKHN0YXJ0SW5kZXgpIHx8IFwiL1wiO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSByZXNvbHZlZCBwYXRoIG9iamVjdCByZWxhdGl2ZSB0byB0aGUgZ2l2ZW4gcGF0aG5hbWUuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS91dGlscy9yZXNvbHZlLXBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVQYXRoKHRvOiBUbywgZnJvbVBhdGhuYW1lID0gXCIvXCIpOiBQYXRoIHtcbiAgbGV0IHtcbiAgICBwYXRobmFtZTogdG9QYXRobmFtZSxcbiAgICBzZWFyY2ggPSBcIlwiLFxuICAgIGhhc2ggPSBcIlwiLFxuICB9ID0gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHRvKSA6IHRvO1xuXG4gIGxldCBwYXRobmFtZSA9IHRvUGF0aG5hbWVcbiAgICA/IHRvUGF0aG5hbWUuc3RhcnRzV2l0aChcIi9cIilcbiAgICAgID8gdG9QYXRobmFtZVxuICAgICAgOiByZXNvbHZlUGF0aG5hbWUodG9QYXRobmFtZSwgZnJvbVBhdGhuYW1lKVxuICAgIDogZnJvbVBhdGhuYW1lO1xuXG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBub3JtYWxpemVTZWFyY2goc2VhcmNoKSxcbiAgICBoYXNoOiBub3JtYWxpemVIYXNoKGhhc2gpLFxuICB9O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlUGF0aG5hbWUocmVsYXRpdmVQYXRoOiBzdHJpbmcsIGZyb21QYXRobmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgbGV0IHNlZ21lbnRzID0gZnJvbVBhdGhuYW1lLnJlcGxhY2UoL1xcLyskLywgXCJcIikuc3BsaXQoXCIvXCIpO1xuICBsZXQgcmVsYXRpdmVTZWdtZW50cyA9IHJlbGF0aXZlUGF0aC5zcGxpdChcIi9cIik7XG5cbiAgcmVsYXRpdmVTZWdtZW50cy5mb3JFYWNoKChzZWdtZW50KSA9PiB7XG4gICAgaWYgKHNlZ21lbnQgPT09IFwiLi5cIikge1xuICAgICAgLy8gS2VlcCB0aGUgcm9vdCBcIlwiIHNlZ21lbnQgc28gdGhlIHBhdGhuYW1lIHN0YXJ0cyBhdCAvXG4gICAgICBpZiAoc2VnbWVudHMubGVuZ3RoID4gMSkgc2VnbWVudHMucG9wKCk7XG4gICAgfSBlbHNlIGlmIChzZWdtZW50ICE9PSBcIi5cIikge1xuICAgICAgc2VnbWVudHMucHVzaChzZWdtZW50KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBzZWdtZW50cy5sZW5ndGggPiAxID8gc2VnbWVudHMuam9pbihcIi9cIikgOiBcIi9cIjtcbn1cblxuZnVuY3Rpb24gZ2V0SW52YWxpZFBhdGhFcnJvcihcbiAgY2hhcjogc3RyaW5nLFxuICBmaWVsZDogc3RyaW5nLFxuICBkZXN0OiBzdHJpbmcsXG4gIHBhdGg6IFBhcnRpYWw8UGF0aD5cbikge1xuICByZXR1cm4gKFxuICAgIGBDYW5ub3QgaW5jbHVkZSBhICcke2NoYXJ9JyBjaGFyYWN0ZXIgaW4gYSBtYW51YWxseSBzcGVjaWZpZWQgYCArXG4gICAgYFxcYHRvLiR7ZmllbGR9XFxgIGZpZWxkIFske0pTT04uc3RyaW5naWZ5KFxuICAgICAgcGF0aFxuICAgICl9XS4gIFBsZWFzZSBzZXBhcmF0ZSBpdCBvdXQgdG8gdGhlIGAgK1xuICAgIGBcXGB0by4ke2Rlc3R9XFxgIGZpZWxkLiBBbHRlcm5hdGl2ZWx5IHlvdSBtYXkgcHJvdmlkZSB0aGUgZnVsbCBwYXRoIGFzIGAgK1xuICAgIGBhIHN0cmluZyBpbiA8TGluayB0bz1cIi4uLlwiPiBhbmQgdGhlIHJvdXRlciB3aWxsIHBhcnNlIGl0IGZvciB5b3UuYFxuICApO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKlxuICogV2hlbiBwcm9jZXNzaW5nIHJlbGF0aXZlIG5hdmlnYXRpb24gd2Ugd2FudCB0byBpZ25vcmUgYW5jZXN0b3Igcm91dGVzIHRoYXRcbiAqIGRvIG5vdCBjb250cmlidXRlIHRvIHRoZSBwYXRoLCBzdWNoIHRoYXQgaW5kZXgvcGF0aGxlc3MgbGF5b3V0IHJvdXRlcyBkb24ndFxuICogaW50ZXJmZXJlLlxuICpcbiAqIEZvciBleGFtcGxlLCB3aGVuIG1vdmluZyBhIHJvdXRlIGVsZW1lbnQgaW50byBhbiBpbmRleCByb3V0ZSBhbmQvb3IgYVxuICogcGF0aGxlc3MgbGF5b3V0IHJvdXRlLCByZWxhdGl2ZSBsaW5rIGJlaGF2aW9yIGNvbnRhaW5lZCB3aXRoaW4gc2hvdWxkIHN0YXlcbiAqIHRoZSBzYW1lLiAgQm90aCBvZiB0aGUgZm9sbG93aW5nIGV4YW1wbGVzIHNob3VsZCBsaW5rIGJhY2sgdG8gdGhlIHJvb3Q6XG4gKlxuICogICA8Um91dGUgcGF0aD1cIi9cIj5cbiAqICAgICA8Um91dGUgcGF0aD1cImFjY291bnRzXCIgZWxlbWVudD17PExpbmsgdG89XCIuLlwifT5cbiAqICAgPC9Sb3V0ZT5cbiAqXG4gKiAgIDxSb3V0ZSBwYXRoPVwiL1wiPlxuICogICAgIDxSb3V0ZSBwYXRoPVwiYWNjb3VudHNcIj5cbiAqICAgICAgIDxSb3V0ZSBlbGVtZW50PXs8QWNjb3VudHNMYXlvdXQgLz59PiAgICAgICAvLyA8LS0gRG9lcyBub3QgY29udHJpYnV0ZVxuICogICAgICAgICA8Um91dGUgaW5kZXggZWxlbWVudD17PExpbmsgdG89XCIuLlwifSAvPiAgLy8gPC0tIERvZXMgbm90IGNvbnRyaWJ1dGVcbiAqICAgICAgIDwvUm91dGVcbiAqICAgICA8L1JvdXRlPlxuICogICA8L1JvdXRlPlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXM8XG4gIFQgZXh0ZW5kcyBBZ25vc3RpY1JvdXRlTWF0Y2ggPSBBZ25vc3RpY1JvdXRlTWF0Y2hcbj4obWF0Y2hlczogVFtdKSB7XG4gIHJldHVybiBtYXRjaGVzLmZpbHRlcihcbiAgICAobWF0Y2gsIGluZGV4KSA9PlxuICAgICAgaW5kZXggPT09IDAgfHwgKG1hdGNoLnJvdXRlLnBhdGggJiYgbWF0Y2gucm91dGUucGF0aC5sZW5ndGggPiAwKVxuICApO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlVG8oXG4gIHRvQXJnOiBUbyxcbiAgcm91dGVQYXRobmFtZXM6IHN0cmluZ1tdLFxuICBsb2NhdGlvblBhdGhuYW1lOiBzdHJpbmcsXG4gIGlzUGF0aFJlbGF0aXZlID0gZmFsc2Vcbik6IFBhdGgge1xuICBsZXQgdG86IFBhcnRpYWw8UGF0aD47XG4gIGlmICh0eXBlb2YgdG9BcmcgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0byA9IHBhcnNlUGF0aCh0b0FyZyk7XG4gIH0gZWxzZSB7XG4gICAgdG8gPSB7IC4uLnRvQXJnIH07XG5cbiAgICBpbnZhcmlhbnQoXG4gICAgICAhdG8ucGF0aG5hbWUgfHwgIXRvLnBhdGhuYW1lLmluY2x1ZGVzKFwiP1wiKSxcbiAgICAgIGdldEludmFsaWRQYXRoRXJyb3IoXCI/XCIsIFwicGF0aG5hbWVcIiwgXCJzZWFyY2hcIiwgdG8pXG4gICAgKTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICAhdG8ucGF0aG5hbWUgfHwgIXRvLnBhdGhuYW1lLmluY2x1ZGVzKFwiI1wiKSxcbiAgICAgIGdldEludmFsaWRQYXRoRXJyb3IoXCIjXCIsIFwicGF0aG5hbWVcIiwgXCJoYXNoXCIsIHRvKVxuICAgICk7XG4gICAgaW52YXJpYW50KFxuICAgICAgIXRvLnNlYXJjaCB8fCAhdG8uc2VhcmNoLmluY2x1ZGVzKFwiI1wiKSxcbiAgICAgIGdldEludmFsaWRQYXRoRXJyb3IoXCIjXCIsIFwic2VhcmNoXCIsIFwiaGFzaFwiLCB0bylcbiAgICApO1xuICB9XG5cbiAgbGV0IGlzRW1wdHlQYXRoID0gdG9BcmcgPT09IFwiXCIgfHwgdG8ucGF0aG5hbWUgPT09IFwiXCI7XG4gIGxldCB0b1BhdGhuYW1lID0gaXNFbXB0eVBhdGggPyBcIi9cIiA6IHRvLnBhdGhuYW1lO1xuXG4gIGxldCBmcm9tOiBzdHJpbmc7XG5cbiAgLy8gUm91dGluZyBpcyByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBwYXRobmFtZSBpZiBleHBsaWNpdGx5IHJlcXVlc3RlZC5cbiAgLy9cbiAgLy8gSWYgYSBwYXRobmFtZSBpcyBleHBsaWNpdGx5IHByb3ZpZGVkIGluIGB0b2AsIGl0IHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGVcbiAgLy8gcm91dGUgY29udGV4dC4gVGhpcyBpcyBleHBsYWluZWQgaW4gYE5vdGUgb24gYDxMaW5rIHRvPmAgdmFsdWVzYCBpbiBvdXJcbiAgLy8gbWlncmF0aW9uIGd1aWRlIGZyb20gdjUgYXMgYSBtZWFucyBvZiBkaXNhbWJpZ3VhdGlvbiBiZXR3ZWVuIGB0b2AgdmFsdWVzXG4gIC8vIHRoYXQgYmVnaW4gd2l0aCBgL2AgYW5kIHRob3NlIHRoYXQgZG8gbm90LiBIb3dldmVyLCB0aGlzIGlzIHByb2JsZW1hdGljIGZvclxuICAvLyBgdG9gIHZhbHVlcyB0aGF0IGRvIG5vdCBwcm92aWRlIGEgcGF0aG5hbWUuIGB0b2AgY2FuIHNpbXBseSBiZSBhIHNlYXJjaCBvclxuICAvLyBoYXNoIHN0cmluZywgaW4gd2hpY2ggY2FzZSB3ZSBzaG91bGQgYXNzdW1lIHRoYXQgdGhlIG5hdmlnYXRpb24gaXMgcmVsYXRpdmVcbiAgLy8gdG8gdGhlIGN1cnJlbnQgbG9jYXRpb24ncyBwYXRobmFtZSBhbmQgKm5vdCogdGhlIHJvdXRlIHBhdGhuYW1lLlxuICBpZiAodG9QYXRobmFtZSA9PSBudWxsKSB7XG4gICAgZnJvbSA9IGxvY2F0aW9uUGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoaXNQYXRoUmVsYXRpdmUpIHtcbiAgICBsZXQgZnJvbVNlZ21lbnRzID0gcm91dGVQYXRobmFtZXNbcm91dGVQYXRobmFtZXMubGVuZ3RoIC0gMV1cbiAgICAgIC5yZXBsYWNlKC9eXFwvLywgXCJcIilcbiAgICAgIC5zcGxpdChcIi9cIik7XG5cbiAgICBpZiAodG9QYXRobmFtZS5zdGFydHNXaXRoKFwiLi5cIikpIHtcbiAgICAgIGxldCB0b1NlZ21lbnRzID0gdG9QYXRobmFtZS5zcGxpdChcIi9cIik7XG5cbiAgICAgIC8vIFdpdGggcmVsYXRpdmU9XCJwYXRoXCIsIGVhY2ggbGVhZGluZyAuLiBzZWdtZW50IG1lYW5zIFwiZ28gdXAgb25lIFVSTCBzZWdtZW50XCJcbiAgICAgIHdoaWxlICh0b1NlZ21lbnRzWzBdID09PSBcIi4uXCIpIHtcbiAgICAgICAgdG9TZWdtZW50cy5zaGlmdCgpO1xuICAgICAgICBmcm9tU2VnbWVudHMucG9wKCk7XG4gICAgICB9XG5cbiAgICAgIHRvLnBhdGhuYW1lID0gdG9TZWdtZW50cy5qb2luKFwiL1wiKTtcbiAgICB9XG5cbiAgICBmcm9tID0gXCIvXCIgKyBmcm9tU2VnbWVudHMuam9pbihcIi9cIik7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHJvdXRlUGF0aG5hbWVJbmRleCA9IHJvdXRlUGF0aG5hbWVzLmxlbmd0aCAtIDE7XG5cbiAgICBpZiAodG9QYXRobmFtZS5zdGFydHNXaXRoKFwiLi5cIikpIHtcbiAgICAgIGxldCB0b1NlZ21lbnRzID0gdG9QYXRobmFtZS5zcGxpdChcIi9cIik7XG5cbiAgICAgIC8vIFdpdGggcmVsYXRpdmU9XCJyb3V0ZVwiICh0aGUgZGVmYXVsdCksIGVhY2ggbGVhZGluZyAuLiBzZWdtZW50IG1lYW5zXG4gICAgICAvLyBcImdvIHVwIG9uZSByb3V0ZVwiIGluc3RlYWQgb2YgXCJnbyB1cCBvbmUgVVJMIHNlZ21lbnRcIi4gIFRoaXMgaXMgYSBrZXlcbiAgICAgIC8vIGRpZmZlcmVuY2UgZnJvbSBob3cgPGEgaHJlZj4gd29ya3MgYW5kIGEgbWFqb3IgcmVhc29uIHdlIGNhbGwgdGhpcyBhXG4gICAgICAvLyBcInRvXCIgdmFsdWUgaW5zdGVhZCBvZiBhIFwiaHJlZlwiLlxuICAgICAgd2hpbGUgKHRvU2VnbWVudHNbMF0gPT09IFwiLi5cIikge1xuICAgICAgICB0b1NlZ21lbnRzLnNoaWZ0KCk7XG4gICAgICAgIHJvdXRlUGF0aG5hbWVJbmRleCAtPSAxO1xuICAgICAgfVxuXG4gICAgICB0by5wYXRobmFtZSA9IHRvU2VnbWVudHMuam9pbihcIi9cIik7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgYXJlIG1vcmUgXCIuLlwiIHNlZ21lbnRzIHRoYW4gcGFyZW50IHJvdXRlcywgcmVzb2x2ZSByZWxhdGl2ZSB0b1xuICAgIC8vIHRoZSByb290IC8gVVJMLlxuICAgIGZyb20gPSByb3V0ZVBhdGhuYW1lSW5kZXggPj0gMCA/IHJvdXRlUGF0aG5hbWVzW3JvdXRlUGF0aG5hbWVJbmRleF0gOiBcIi9cIjtcbiAgfVxuXG4gIGxldCBwYXRoID0gcmVzb2x2ZVBhdGgodG8sIGZyb20pO1xuXG4gIC8vIEVuc3VyZSB0aGUgcGF0aG5hbWUgaGFzIGEgdHJhaWxpbmcgc2xhc2ggaWYgdGhlIG9yaWdpbmFsIFwidG9cIiBoYWQgb25lXG4gIGxldCBoYXNFeHBsaWNpdFRyYWlsaW5nU2xhc2ggPVxuICAgIHRvUGF0aG5hbWUgJiYgdG9QYXRobmFtZSAhPT0gXCIvXCIgJiYgdG9QYXRobmFtZS5lbmRzV2l0aChcIi9cIik7XG4gIC8vIE9yIGlmIHRoaXMgd2FzIGEgbGluayB0byB0aGUgY3VycmVudCBwYXRoIHdoaWNoIGhhcyBhIHRyYWlsaW5nIHNsYXNoXG4gIGxldCBoYXNDdXJyZW50VHJhaWxpbmdTbGFzaCA9XG4gICAgKGlzRW1wdHlQYXRoIHx8IHRvUGF0aG5hbWUgPT09IFwiLlwiKSAmJiBsb2NhdGlvblBhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKTtcbiAgaWYgKFxuICAgICFwYXRoLnBhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKSAmJlxuICAgIChoYXNFeHBsaWNpdFRyYWlsaW5nU2xhc2ggfHwgaGFzQ3VycmVudFRyYWlsaW5nU2xhc2gpXG4gICkge1xuICAgIHBhdGgucGF0aG5hbWUgKz0gXCIvXCI7XG4gIH1cblxuICByZXR1cm4gcGF0aDtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG9QYXRobmFtZSh0bzogVG8pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAvLyBFbXB0eSBzdHJpbmdzIHNob3VsZCBiZSB0cmVhdGVkIHRoZSBzYW1lIGFzIC8gcGF0aHNcbiAgcmV0dXJuIHRvID09PSBcIlwiIHx8ICh0byBhcyBQYXRoKS5wYXRobmFtZSA9PT0gXCJcIlxuICAgID8gXCIvXCJcbiAgICA6IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIlxuICAgID8gcGFyc2VQYXRoKHRvKS5wYXRobmFtZVxuICAgIDogdG8ucGF0aG5hbWU7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IGpvaW5QYXRocyA9IChwYXRoczogc3RyaW5nW10pOiBzdHJpbmcgPT5cbiAgcGF0aHMuam9pbihcIi9cIikucmVwbGFjZSgvXFwvXFwvKy9nLCBcIi9cIik7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZVBhdGhuYW1lID0gKHBhdGhuYW1lOiBzdHJpbmcpOiBzdHJpbmcgPT5cbiAgcGF0aG5hbWUucmVwbGFjZSgvXFwvKyQvLCBcIlwiKS5yZXBsYWNlKC9eXFwvKi8sIFwiL1wiKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3Qgbm9ybWFsaXplU2VhcmNoID0gKHNlYXJjaDogc3RyaW5nKTogc3RyaW5nID0+XG4gICFzZWFyY2ggfHwgc2VhcmNoID09PSBcIj9cIlxuICAgID8gXCJcIlxuICAgIDogc2VhcmNoLnN0YXJ0c1dpdGgoXCI/XCIpXG4gICAgPyBzZWFyY2hcbiAgICA6IFwiP1wiICsgc2VhcmNoO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBub3JtYWxpemVIYXNoID0gKGhhc2g6IHN0cmluZyk6IHN0cmluZyA9PlxuICAhaGFzaCB8fCBoYXNoID09PSBcIiNcIiA/IFwiXCIgOiBoYXNoLnN0YXJ0c1dpdGgoXCIjXCIpID8gaGFzaCA6IFwiI1wiICsgaGFzaDtcblxuZXhwb3J0IHR5cGUgSnNvbkZ1bmN0aW9uID0gPERhdGE+KFxuICBkYXRhOiBEYXRhLFxuICBpbml0PzogbnVtYmVyIHwgUmVzcG9uc2VJbml0XG4pID0+IFJlc3BvbnNlO1xuXG4vKipcbiAqIFRoaXMgaXMgYSBzaG9ydGN1dCBmb3IgY3JlYXRpbmcgYGFwcGxpY2F0aW9uL2pzb25gIHJlc3BvbnNlcy4gQ29udmVydHMgYGRhdGFgXG4gKiB0byBKU09OIGFuZCBzZXRzIHRoZSBgQ29udGVudC1UeXBlYCBoZWFkZXIuXG4gKi9cbmV4cG9ydCBjb25zdCBqc29uOiBKc29uRnVuY3Rpb24gPSAoZGF0YSwgaW5pdCA9IHt9KSA9PiB7XG4gIGxldCByZXNwb25zZUluaXQgPSB0eXBlb2YgaW5pdCA9PT0gXCJudW1iZXJcIiA/IHsgc3RhdHVzOiBpbml0IH0gOiBpbml0O1xuXG4gIGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnMocmVzcG9uc2VJbml0LmhlYWRlcnMpO1xuICBpZiAoIWhlYWRlcnMuaGFzKFwiQ29udGVudC1UeXBlXCIpKSB7XG4gICAgaGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeShkYXRhKSwge1xuICAgIC4uLnJlc3BvbnNlSW5pdCxcbiAgICBoZWFkZXJzLFxuICB9KTtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhY2tlZFByb21pc2UgZXh0ZW5kcyBQcm9taXNlPGFueT4ge1xuICBfdHJhY2tlZD86IGJvb2xlYW47XG4gIF9kYXRhPzogYW55O1xuICBfZXJyb3I/OiBhbnk7XG59XG5cbmV4cG9ydCBjbGFzcyBBYm9ydGVkRGVmZXJyZWRFcnJvciBleHRlbmRzIEVycm9yIHt9XG5cbmV4cG9ydCBjbGFzcyBEZWZlcnJlZERhdGEge1xuICBwcml2YXRlIHBlbmRpbmdLZXlzU2V0OiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBwcml2YXRlIGNvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlcjtcbiAgcHJpdmF0ZSBhYm9ydFByb21pc2U6IFByb21pc2U8dm9pZD47XG4gIHByaXZhdGUgdW5saXN0ZW5BYm9ydFNpZ25hbDogKCkgPT4gdm9pZDtcbiAgcHJpdmF0ZSBzdWJzY3JpYmVyczogU2V0PChhYm9ydGVkOiBib29sZWFuLCBzZXR0bGVkS2V5Pzogc3RyaW5nKSA9PiB2b2lkPiA9XG4gICAgbmV3IFNldCgpO1xuICBkYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgaW5pdD86IFJlc3BvbnNlSW5pdDtcbiAgZGVmZXJyZWRLZXlzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LCByZXNwb25zZUluaXQ/OiBSZXNwb25zZUluaXQpIHtcbiAgICBpbnZhcmlhbnQoXG4gICAgICBkYXRhICYmIHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KGRhdGEpLFxuICAgICAgXCJkZWZlcigpIG9ubHkgYWNjZXB0cyBwbGFpbiBvYmplY3RzXCJcbiAgICApO1xuXG4gICAgLy8gU2V0IHVwIGFuIEFib3J0Q29udHJvbGxlciArIFByb21pc2Ugd2UgY2FuIHJhY2UgYWdhaW5zdCB0byBleGl0IGVhcmx5XG4gICAgLy8gY2FuY2VsbGF0aW9uXG4gICAgbGV0IHJlamVjdDogKGU6IEFib3J0ZWREZWZlcnJlZEVycm9yKSA9PiB2b2lkO1xuICAgIHRoaXMuYWJvcnRQcm9taXNlID0gbmV3IFByb21pc2UoKF8sIHIpID0+IChyZWplY3QgPSByKSk7XG4gICAgdGhpcy5jb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGxldCBvbkFib3J0ID0gKCkgPT5cbiAgICAgIHJlamVjdChuZXcgQWJvcnRlZERlZmVycmVkRXJyb3IoXCJEZWZlcnJlZCBkYXRhIGFib3J0ZWRcIikpO1xuICAgIHRoaXMudW5saXN0ZW5BYm9ydFNpZ25hbCA9ICgpID0+XG4gICAgICB0aGlzLmNvbnRyb2xsZXIuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgICB0aGlzLmNvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcblxuICAgIHRoaXMuZGF0YSA9IE9iamVjdC5lbnRyaWVzKGRhdGEpLnJlZHVjZShcbiAgICAgIChhY2MsIFtrZXksIHZhbHVlXSkgPT5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihhY2MsIHtcbiAgICAgICAgICBba2V5XTogdGhpcy50cmFja1Byb21pc2Uoa2V5LCB2YWx1ZSksXG4gICAgICAgIH0pLFxuICAgICAge31cbiAgICApO1xuXG4gICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgLy8gQWxsIGluY29taW5nIHZhbHVlcyB3ZXJlIHJlc29sdmVkXG4gICAgICB0aGlzLnVubGlzdGVuQWJvcnRTaWduYWwoKTtcbiAgICB9XG5cbiAgICB0aGlzLmluaXQgPSByZXNwb25zZUluaXQ7XG4gIH1cblxuICBwcml2YXRlIHRyYWNrUHJvbWlzZShcbiAgICBrZXk6IHN0cmluZyxcbiAgICB2YWx1ZTogUHJvbWlzZTx1bmtub3duPiB8IHVua25vd25cbiAgKTogVHJhY2tlZFByb21pc2UgfCB1bmtub3duIHtcbiAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgdGhpcy5kZWZlcnJlZEtleXMucHVzaChrZXkpO1xuICAgIHRoaXMucGVuZGluZ0tleXNTZXQuYWRkKGtleSk7XG5cbiAgICAvLyBXZSBzdG9yZSBhIGxpdHRsZSB3cmFwcGVyIHByb21pc2UgdGhhdCB3aWxsIGJlIGV4dGVuZGVkIHdpdGhcbiAgICAvLyBfZGF0YS9fZXJyb3IgcHJvcHMgdXBvbiByZXNvbHZlL3JlamVjdFxuICAgIGxldCBwcm9taXNlOiBUcmFja2VkUHJvbWlzZSA9IFByb21pc2UucmFjZShbdmFsdWUsIHRoaXMuYWJvcnRQcm9taXNlXSkudGhlbihcbiAgICAgIChkYXRhKSA9PiB0aGlzLm9uU2V0dGxlKHByb21pc2UsIGtleSwgdW5kZWZpbmVkLCBkYXRhIGFzIHVua25vd24pLFxuICAgICAgKGVycm9yKSA9PiB0aGlzLm9uU2V0dGxlKHByb21pc2UsIGtleSwgZXJyb3IgYXMgdW5rbm93bilcbiAgICApO1xuXG4gICAgLy8gUmVnaXN0ZXIgcmVqZWN0aW9uIGxpc3RlbmVycyB0byBhdm9pZCB1bmNhdWdodCBwcm9taXNlIHJlamVjdGlvbnMgb25cbiAgICAvLyBlcnJvcnMgb3IgYWJvcnRlZCBkZWZlcnJlZCB2YWx1ZXNcbiAgICBwcm9taXNlLmNhdGNoKCgpID0+IHt9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl90cmFja2VkXCIsIHsgZ2V0OiAoKSA9PiB0cnVlIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgcHJpdmF0ZSBvblNldHRsZShcbiAgICBwcm9taXNlOiBUcmFja2VkUHJvbWlzZSxcbiAgICBrZXk6IHN0cmluZyxcbiAgICBlcnJvcjogdW5rbm93bixcbiAgICBkYXRhPzogdW5rbm93blxuICApOiB1bmtub3duIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLmNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQgJiZcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgQWJvcnRlZERlZmVycmVkRXJyb3JcbiAgICApIHtcbiAgICAgIHRoaXMudW5saXN0ZW5BYm9ydFNpZ25hbCgpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX2Vycm9yXCIsIHsgZ2V0OiAoKSA9PiBlcnJvciB9KTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuXG4gICAgdGhpcy5wZW5kaW5nS2V5c1NldC5kZWxldGUoa2V5KTtcblxuICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgIC8vIE5vdGhpbmcgbGVmdCB0byBhYm9ydCFcbiAgICAgIHRoaXMudW5saXN0ZW5BYm9ydFNpZ25hbCgpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBwcm9taXNlIHdhcyByZXNvbHZlZC9yZWplY3RlZCB3aXRoIHVuZGVmaW5lZCwgd2UnbGwgdGhyb3cgYW4gZXJyb3IgYXMgeW91XG4gICAgLy8gc2hvdWxkIGFsd2F5cyByZXNvbHZlIHdpdGggYSB2YWx1ZSBvciBudWxsXG4gICAgaWYgKGVycm9yID09PSB1bmRlZmluZWQgJiYgZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgdW5kZWZpbmVkRXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgIGBEZWZlcnJlZCBkYXRhIGZvciBrZXkgXCIke2tleX1cIiByZXNvbHZlZC9yZWplY3RlZCB3aXRoIFxcYHVuZGVmaW5lZFxcYCwgYCArXG4gICAgICAgICAgYHlvdSBtdXN0IHJlc29sdmUvcmVqZWN0IHdpdGggYSB2YWx1ZSBvciBcXGBudWxsXFxgLmBcbiAgICAgICk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfZXJyb3JcIiwgeyBnZXQ6ICgpID0+IHVuZGVmaW5lZEVycm9yIH0pO1xuICAgICAgdGhpcy5lbWl0KGZhbHNlLCBrZXkpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHVuZGVmaW5lZEVycm9yKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfZXJyb3JcIiwgeyBnZXQ6ICgpID0+IGVycm9yIH0pO1xuICAgICAgdGhpcy5lbWl0KGZhbHNlLCBrZXkpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfZGF0YVwiLCB7IGdldDogKCkgPT4gZGF0YSB9KTtcbiAgICB0aGlzLmVtaXQoZmFsc2UsIGtleSk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBwcml2YXRlIGVtaXQoYWJvcnRlZDogYm9vbGVhbiwgc2V0dGxlZEtleT86IHN0cmluZykge1xuICAgIHRoaXMuc3Vic2NyaWJlcnMuZm9yRWFjaCgoc3Vic2NyaWJlcikgPT4gc3Vic2NyaWJlcihhYm9ydGVkLCBzZXR0bGVkS2V5KSk7XG4gIH1cblxuICBzdWJzY3JpYmUoZm46IChhYm9ydGVkOiBib29sZWFuLCBzZXR0bGVkS2V5Pzogc3RyaW5nKSA9PiB2b2lkKSB7XG4gICAgdGhpcy5zdWJzY3JpYmVycy5hZGQoZm4pO1xuICAgIHJldHVybiAoKSA9PiB0aGlzLnN1YnNjcmliZXJzLmRlbGV0ZShmbik7XG4gIH1cblxuICBjYW5jZWwoKSB7XG4gICAgdGhpcy5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgdGhpcy5wZW5kaW5nS2V5c1NldC5mb3JFYWNoKCh2LCBrKSA9PiB0aGlzLnBlbmRpbmdLZXlzU2V0LmRlbGV0ZShrKSk7XG4gICAgdGhpcy5lbWl0KHRydWUpO1xuICB9XG5cbiAgYXN5bmMgcmVzb2x2ZURhdGEoc2lnbmFsOiBBYm9ydFNpZ25hbCkge1xuICAgIGxldCBhYm9ydGVkID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLmRvbmUpIHtcbiAgICAgIGxldCBvbkFib3J0ID0gKCkgPT4gdGhpcy5jYW5jZWwoKTtcbiAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25BYm9ydCk7XG4gICAgICBhYm9ydGVkID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmUoKGFib3J0ZWQpID0+IHtcbiAgICAgICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQWJvcnQpO1xuICAgICAgICAgIGlmIChhYm9ydGVkIHx8IHRoaXMuZG9uZSkge1xuICAgICAgICAgICAgcmVzb2x2ZShhYm9ydGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhYm9ydGVkO1xuICB9XG5cbiAgZ2V0IGRvbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucGVuZGluZ0tleXNTZXQuc2l6ZSA9PT0gMDtcbiAgfVxuXG4gIGdldCB1bndyYXBwZWREYXRhKCkge1xuICAgIGludmFyaWFudChcbiAgICAgIHRoaXMuZGF0YSAhPT0gbnVsbCAmJiB0aGlzLmRvbmUsXG4gICAgICBcIkNhbiBvbmx5IHVud3JhcCBkYXRhIG9uIGluaXRpYWxpemVkIGFuZCBzZXR0bGVkIGRlZmVycmVkc1wiXG4gICAgKTtcblxuICAgIHJldHVybiBPYmplY3QuZW50cmllcyh0aGlzLmRhdGEpLnJlZHVjZShcbiAgICAgIChhY2MsIFtrZXksIHZhbHVlXSkgPT5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihhY2MsIHtcbiAgICAgICAgICBba2V5XTogdW53cmFwVHJhY2tlZFByb21pc2UodmFsdWUpLFxuICAgICAgICB9KSxcbiAgICAgIHt9XG4gICAgKTtcbiAgfVxuXG4gIGdldCBwZW5kaW5nS2V5cygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnBlbmRpbmdLZXlzU2V0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1RyYWNrZWRQcm9taXNlKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBUcmFja2VkUHJvbWlzZSB7XG4gIHJldHVybiAoXG4gICAgdmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlICYmICh2YWx1ZSBhcyBUcmFja2VkUHJvbWlzZSkuX3RyYWNrZWQgPT09IHRydWVcbiAgKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwVHJhY2tlZFByb21pc2UodmFsdWU6IGFueSkge1xuICBpZiAoIWlzVHJhY2tlZFByb21pc2UodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKHZhbHVlLl9lcnJvcikge1xuICAgIHRocm93IHZhbHVlLl9lcnJvcjtcbiAgfVxuICByZXR1cm4gdmFsdWUuX2RhdGE7XG59XG5cbmV4cG9ydCB0eXBlIERlZmVyRnVuY3Rpb24gPSAoXG4gIGRhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICBpbml0PzogbnVtYmVyIHwgUmVzcG9uc2VJbml0XG4pID0+IERlZmVycmVkRGF0YTtcblxuZXhwb3J0IGNvbnN0IGRlZmVyOiBEZWZlckZ1bmN0aW9uID0gKGRhdGEsIGluaXQgPSB7fSkgPT4ge1xuICBsZXQgcmVzcG9uc2VJbml0ID0gdHlwZW9mIGluaXQgPT09IFwibnVtYmVyXCIgPyB7IHN0YXR1czogaW5pdCB9IDogaW5pdDtcblxuICByZXR1cm4gbmV3IERlZmVycmVkRGF0YShkYXRhLCByZXNwb25zZUluaXQpO1xufTtcblxuZXhwb3J0IHR5cGUgUmVkaXJlY3RGdW5jdGlvbiA9IChcbiAgdXJsOiBzdHJpbmcsXG4gIGluaXQ/OiBudW1iZXIgfCBSZXNwb25zZUluaXRcbikgPT4gUmVzcG9uc2U7XG5cbi8qKlxuICogQSByZWRpcmVjdCByZXNwb25zZS4gU2V0cyB0aGUgc3RhdHVzIGNvZGUgYW5kIHRoZSBgTG9jYXRpb25gIGhlYWRlci5cbiAqIERlZmF1bHRzIHRvIFwiMzAyIEZvdW5kXCIuXG4gKi9cbmV4cG9ydCBjb25zdCByZWRpcmVjdDogUmVkaXJlY3RGdW5jdGlvbiA9ICh1cmwsIGluaXQgPSAzMDIpID0+IHtcbiAgbGV0IHJlc3BvbnNlSW5pdCA9IGluaXQ7XG4gIGlmICh0eXBlb2YgcmVzcG9uc2VJbml0ID09PSBcIm51bWJlclwiKSB7XG4gICAgcmVzcG9uc2VJbml0ID0geyBzdGF0dXM6IHJlc3BvbnNlSW5pdCB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiByZXNwb25zZUluaXQuc3RhdHVzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmVzcG9uc2VJbml0LnN0YXR1cyA9IDMwMjtcbiAgfVxuXG4gIGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnMocmVzcG9uc2VJbml0LmhlYWRlcnMpO1xuICBoZWFkZXJzLnNldChcIkxvY2F0aW9uXCIsIHVybCk7XG5cbiAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7XG4gICAgLi4ucmVzcG9uc2VJbml0LFxuICAgIGhlYWRlcnMsXG4gIH0pO1xufTtcblxuLyoqXG4gKiBBIHJlZGlyZWN0IHJlc3BvbnNlIHRoYXQgd2lsbCBmb3JjZSBhIGRvY3VtZW50IHJlbG9hZCB0byB0aGUgbmV3IGxvY2F0aW9uLlxuICogU2V0cyB0aGUgc3RhdHVzIGNvZGUgYW5kIHRoZSBgTG9jYXRpb25gIGhlYWRlci5cbiAqIERlZmF1bHRzIHRvIFwiMzAyIEZvdW5kXCIuXG4gKi9cbmV4cG9ydCBjb25zdCByZWRpcmVjdERvY3VtZW50OiBSZWRpcmVjdEZ1bmN0aW9uID0gKHVybCwgaW5pdCkgPT4ge1xuICBsZXQgcmVzcG9uc2UgPSByZWRpcmVjdCh1cmwsIGluaXQpO1xuICByZXNwb25zZS5oZWFkZXJzLnNldChcIlgtUmVtaXgtUmVsb2FkLURvY3VtZW50XCIsIFwidHJ1ZVwiKTtcbiAgcmV0dXJuIHJlc3BvbnNlO1xufTtcblxuZXhwb3J0IHR5cGUgRXJyb3JSZXNwb25zZSA9IHtcbiAgc3RhdHVzOiBudW1iZXI7XG4gIHN0YXR1c1RleHQ6IHN0cmluZztcbiAgZGF0YTogYW55O1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogVXRpbGl0eSBjbGFzcyB3ZSB1c2UgdG8gaG9sZCBhdXRvLXVud3JhcHBlZCA0eHgvNXh4IFJlc3BvbnNlIGJvZGllc1xuICpcbiAqIFdlIGRvbid0IGV4cG9ydCB0aGUgY2xhc3MgZm9yIHB1YmxpYyB1c2Ugc2luY2UgaXQncyBhbiBpbXBsZW1lbnRhdGlvblxuICogZGV0YWlsLCBidXQgd2UgZXhwb3J0IHRoZSBpbnRlcmZhY2UgYWJvdmUgc28gZm9sa3MgY2FuIGJ1aWxkIHRoZWlyIG93blxuICogYWJzdHJhY3Rpb25zIGFyb3VuZCBpbnN0YW5jZXMgdmlhIGlzUm91dGVFcnJvclJlc3BvbnNlKClcbiAqL1xuZXhwb3J0IGNsYXNzIEVycm9yUmVzcG9uc2VJbXBsIGltcGxlbWVudHMgRXJyb3JSZXNwb25zZSB7XG4gIHN0YXR1czogbnVtYmVyO1xuICBzdGF0dXNUZXh0OiBzdHJpbmc7XG4gIGRhdGE6IGFueTtcbiAgcHJpdmF0ZSBlcnJvcj86IEVycm9yO1xuICBwcml2YXRlIGludGVybmFsOiBib29sZWFuO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHN0YXR1czogbnVtYmVyLFxuICAgIHN0YXR1c1RleHQ6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICBkYXRhOiBhbnksXG4gICAgaW50ZXJuYWwgPSBmYWxzZVxuICApIHtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLnN0YXR1c1RleHQgPSBzdGF0dXNUZXh0IHx8IFwiXCI7XG4gICAgdGhpcy5pbnRlcm5hbCA9IGludGVybmFsO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcbiAgICAgIHRoaXMuZXJyb3IgPSBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBlcnJvciBpcyBhbiBFcnJvclJlc3BvbnNlIGdlbmVyYXRlZCBmcm9tIGEgNHh4LzV4eFxuICogUmVzcG9uc2UgdGhyb3duIGZyb20gYW4gYWN0aW9uL2xvYWRlclxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNSb3V0ZUVycm9yUmVzcG9uc2UoZXJyb3I6IGFueSk6IGVycm9yIGlzIEVycm9yUmVzcG9uc2Uge1xuICByZXR1cm4gKFxuICAgIGVycm9yICE9IG51bGwgJiZcbiAgICB0eXBlb2YgZXJyb3Iuc3RhdHVzID09PSBcIm51bWJlclwiICYmXG4gICAgdHlwZW9mIGVycm9yLnN0YXR1c1RleHQgPT09IFwic3RyaW5nXCIgJiZcbiAgICB0eXBlb2YgZXJyb3IuaW50ZXJuYWwgPT09IFwiYm9vbGVhblwiICYmXG4gICAgXCJkYXRhXCIgaW4gZXJyb3JcbiAgKTtcbn1cbiIsImltcG9ydCB0eXBlIHsgSGlzdG9yeSwgTG9jYXRpb24sIFBhdGgsIFRvIH0gZnJvbSBcIi4vaGlzdG9yeVwiO1xuaW1wb3J0IHtcbiAgQWN0aW9uIGFzIEhpc3RvcnlBY3Rpb24sXG4gIGNyZWF0ZUxvY2F0aW9uLFxuICBjcmVhdGVQYXRoLFxuICBpbnZhcmlhbnQsXG4gIHBhcnNlUGF0aCxcbiAgd2FybmluZyxcbn0gZnJvbSBcIi4vaGlzdG9yeVwiO1xuaW1wb3J0IHR5cGUge1xuICBBY3Rpb25GdW5jdGlvbixcbiAgQWdub3N0aWNEYXRhUm91dGVNYXRjaCxcbiAgQWdub3N0aWNEYXRhUm91dGVPYmplY3QsXG4gIEFnbm9zdGljUm91dGVPYmplY3QsXG4gIERhdGFSZXN1bHQsXG4gIERlZmVycmVkRGF0YSxcbiAgRGVmZXJyZWRSZXN1bHQsXG4gIERldGVjdEVycm9yQm91bmRhcnlGdW5jdGlvbixcbiAgRXJyb3JSZXN1bHQsXG4gIEZvcm1FbmNUeXBlLFxuICBGb3JtTWV0aG9kLFxuICBIVE1MRm9ybU1ldGhvZCxcbiAgSW1tdXRhYmxlUm91dGVLZXksXG4gIExvYWRlckZ1bmN0aW9uLFxuICBNYXBSb3V0ZVByb3BlcnRpZXNGdW5jdGlvbixcbiAgTXV0YXRpb25Gb3JtTWV0aG9kLFxuICBSZWRpcmVjdFJlc3VsdCxcbiAgUm91dGVEYXRhLFxuICBSb3V0ZU1hbmlmZXN0LFxuICBTaG91bGRSZXZhbGlkYXRlRnVuY3Rpb25BcmdzLFxuICBTdWJtaXNzaW9uLFxuICBTdWNjZXNzUmVzdWx0LFxuICBVSU1hdGNoLFxuICBWN19Gb3JtTWV0aG9kLFxuICBWN19NdXRhdGlvbkZvcm1NZXRob2QsXG59IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQge1xuICBFcnJvclJlc3BvbnNlSW1wbCxcbiAgUmVzdWx0VHlwZSxcbiAgY29udmVydFJvdXRlTWF0Y2hUb1VpTWF0Y2gsXG4gIGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMsXG4gIGdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzLFxuICBpbW11dGFibGVSb3V0ZUtleXMsXG4gIGlzUm91dGVFcnJvclJlc3BvbnNlLFxuICBqb2luUGF0aHMsXG4gIG1hdGNoUm91dGVzLFxuICByZXNvbHZlVG8sXG4gIHN0cmlwQmFzZW5hbWUsXG59IGZyb20gXCIuL3V0aWxzXCI7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gVHlwZXMgYW5kIENvbnN0YW50c1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBBIFJvdXRlciBpbnN0YW5jZSBtYW5hZ2VzIGFsbCBuYXZpZ2F0aW9uIGFuZCBkYXRhIGxvYWRpbmcvbXV0YXRpb25zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVyIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBSZXR1cm4gdGhlIGJhc2VuYW1lIGZvciB0aGUgcm91dGVyXG4gICAqL1xuICBnZXQgYmFzZW5hbWUoKTogUm91dGVySW5pdFtcImJhc2VuYW1lXCJdO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogUmV0dXJuIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSByb3V0ZXJcbiAgICovXG4gIGdldCBzdGF0ZSgpOiBSb3V0ZXJTdGF0ZTtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIFJldHVybiB0aGUgcm91dGVzIGZvciB0aGlzIHJvdXRlciBpbnN0YW5jZVxuICAgKi9cbiAgZ2V0IHJvdXRlcygpOiBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdFtdO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogUmV0dXJuIHRoZSB3aW5kb3cgYXNzb2NpYXRlZCB3aXRoIHRoZSByb3V0ZXJcbiAgICovXG4gIGdldCB3aW5kb3coKTogUm91dGVySW5pdFtcIndpbmRvd1wiXTtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIEluaXRpYWxpemUgdGhlIHJvdXRlciwgaW5jbHVkaW5nIGFkZGluZyBoaXN0b3J5IGxpc3RlbmVycyBhbmQga2lja2luZyBvZmZcbiAgICogaW5pdGlhbCBkYXRhIGZldGNoZXMuICBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gY2xlYW51cCBsaXN0ZW5lcnMgYW5kIGFib3J0XG4gICAqIGFueSBpbi1wcm9ncmVzcyBsb2Fkc1xuICAgKi9cbiAgaW5pdGlhbGl6ZSgpOiBSb3V0ZXI7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBTdWJzY3JpYmUgdG8gcm91dGVyLnN0YXRlIHVwZGF0ZXNcbiAgICpcbiAgICogQHBhcmFtIGZuIGZ1bmN0aW9uIHRvIGNhbGwgd2l0aCB0aGUgbmV3IHN0YXRlXG4gICAqL1xuICBzdWJzY3JpYmUoZm46IFJvdXRlclN1YnNjcmliZXIpOiAoKSA9PiB2b2lkO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogRW5hYmxlIHNjcm9sbCByZXN0b3JhdGlvbiBiZWhhdmlvciBpbiB0aGUgcm91dGVyXG4gICAqXG4gICAqIEBwYXJhbSBzYXZlZFNjcm9sbFBvc2l0aW9ucyBPYmplY3QgdGhhdCB3aWxsIG1hbmFnZSBwb3NpdGlvbnMsIGluIGNhc2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0J3MgYmVpbmcgcmVzdG9yZWQgZnJvbSBzZXNzaW9uU3RvcmFnZVxuICAgKiBAcGFyYW0gZ2V0U2Nyb2xsUG9zaXRpb24gICAgRnVuY3Rpb24gdG8gZ2V0IHRoZSBhY3RpdmUgWSBzY3JvbGwgcG9zaXRpb25cbiAgICogQHBhcmFtIGdldEtleSAgICAgICAgICAgICAgIEZ1bmN0aW9uIHRvIGdldCB0aGUga2V5IHRvIHVzZSBmb3IgcmVzdG9yYXRpb25cbiAgICovXG4gIGVuYWJsZVNjcm9sbFJlc3RvcmF0aW9uKFxuICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+LFxuICAgIGdldFNjcm9sbFBvc2l0aW9uOiBHZXRTY3JvbGxQb3NpdGlvbkZ1bmN0aW9uLFxuICAgIGdldEtleT86IEdldFNjcm9sbFJlc3RvcmF0aW9uS2V5RnVuY3Rpb25cbiAgKTogKCkgPT4gdm9pZDtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIE5hdmlnYXRlIGZvcndhcmQvYmFja3dhcmQgaW4gdGhlIGhpc3Rvcnkgc3RhY2tcbiAgICogQHBhcmFtIHRvIERlbHRhIHRvIG1vdmUgaW4gdGhlIGhpc3Rvcnkgc3RhY2tcbiAgICovXG4gIG5hdmlnYXRlKHRvOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBOYXZpZ2F0ZSB0byB0aGUgZ2l2ZW4gcGF0aFxuICAgKiBAcGFyYW0gdG8gUGF0aCB0byBuYXZpZ2F0ZSB0b1xuICAgKiBAcGFyYW0gb3B0cyBOYXZpZ2F0aW9uIG9wdGlvbnMgKG1ldGhvZCwgc3VibWlzc2lvbiwgZXRjLilcbiAgICovXG4gIG5hdmlnYXRlKHRvOiBUbyB8IG51bGwsIG9wdHM/OiBSb3V0ZXJOYXZpZ2F0ZU9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogVHJpZ2dlciBhIGZldGNoZXIgbG9hZC9zdWJtaXNzaW9uXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgICAgIEZldGNoZXIga2V5XG4gICAqIEBwYXJhbSByb3V0ZUlkIFJvdXRlIHRoYXQgb3ducyB0aGUgZmV0Y2hlclxuICAgKiBAcGFyYW0gaHJlZiAgICBocmVmIHRvIGZldGNoXG4gICAqIEBwYXJhbSBvcHRzICAgIEZldGNoZXIgb3B0aW9ucywgKG1ldGhvZCwgc3VibWlzc2lvbiwgZXRjLilcbiAgICovXG4gIGZldGNoKFxuICAgIGtleTogc3RyaW5nLFxuICAgIHJvdXRlSWQ6IHN0cmluZyxcbiAgICBocmVmOiBzdHJpbmcgfCBudWxsLFxuICAgIG9wdHM/OiBSb3V0ZXJGZXRjaE9wdGlvbnNcbiAgKTogdm9pZDtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIFRyaWdnZXIgYSByZXZhbGlkYXRpb24gb2YgYWxsIGN1cnJlbnQgcm91dGUgbG9hZGVycyBhbmQgZmV0Y2hlciBsb2Fkc1xuICAgKi9cbiAgcmV2YWxpZGF0ZSgpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogVXRpbGl0eSBmdW5jdGlvbiB0byBjcmVhdGUgYW4gaHJlZiBmb3IgdGhlIGdpdmVuIGxvY2F0aW9uXG4gICAqIEBwYXJhbSBsb2NhdGlvblxuICAgKi9cbiAgY3JlYXRlSHJlZihsb2NhdGlvbjogTG9jYXRpb24gfCBVUkwpOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIFVSTCBlbmNvZGUgYSBkZXN0aW5hdGlvbiBwYXRoIGFjY29yZGluZyB0byB0aGUgaW50ZXJuYWxcbiAgICogaGlzdG9yeSBpbXBsZW1lbnRhdGlvblxuICAgKiBAcGFyYW0gdG9cbiAgICovXG4gIGVuY29kZUxvY2F0aW9uKHRvOiBUbyk6IFBhdGg7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBHZXQvY3JlYXRlIGEgZmV0Y2hlciBmb3IgdGhlIGdpdmVuIGtleVxuICAgKiBAcGFyYW0ga2V5XG4gICAqL1xuICBnZXRGZXRjaGVyPFREYXRhID0gYW55PihrZXk6IHN0cmluZyk6IEZldGNoZXI8VERhdGE+O1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogRGVsZXRlIHRoZSBmZXRjaGVyIGZvciBhIGdpdmVuIGtleVxuICAgKiBAcGFyYW0ga2V5XG4gICAqL1xuICBkZWxldGVGZXRjaGVyKGtleTogc3RyaW5nKTogdm9pZDtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIENsZWFudXAgbGlzdGVuZXJzIGFuZCBhYm9ydCBhbnkgaW4tcHJvZ3Jlc3MgbG9hZHNcbiAgICovXG4gIGRpc3Bvc2UoKTogdm9pZDtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIEdldCBhIG5hdmlnYXRpb24gYmxvY2tlclxuICAgKiBAcGFyYW0ga2V5IFRoZSBpZGVudGlmaWVyIGZvciB0aGUgYmxvY2tlclxuICAgKiBAcGFyYW0gZm4gVGhlIGJsb2NrZXIgZnVuY3Rpb24gaW1wbGVtZW50YXRpb25cbiAgICovXG4gIGdldEJsb2NrZXIoa2V5OiBzdHJpbmcsIGZuOiBCbG9ja2VyRnVuY3Rpb24pOiBCbG9ja2VyO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogRGVsZXRlIGEgbmF2aWdhdGlvbiBibG9ja2VyXG4gICAqIEBwYXJhbSBrZXkgVGhlIGlkZW50aWZpZXIgZm9yIHRoZSBibG9ja2VyXG4gICAqL1xuICBkZWxldGVCbG9ja2VyKGtleTogc3RyaW5nKTogdm9pZDtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIEhNUiBuZWVkcyB0byBwYXNzIGluLWZsaWdodCByb3V0ZSB1cGRhdGVzIHRvIFJlYWN0IFJvdXRlclxuICAgKiBUT0RPOiBSZXBsYWNlIHRoaXMgd2l0aCBncmFudWxhciByb3V0ZSB1cGRhdGUgQVBJcyAoYWRkUm91dGUsIHVwZGF0ZVJvdXRlLCBkZWxldGVSb3V0ZSlcbiAgICovXG4gIF9pbnRlcm5hbFNldFJvdXRlcyhyb3V0ZXM6IEFnbm9zdGljUm91dGVPYmplY3RbXSk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBJbnRlcm5hbCBmZXRjaCBBYm9ydENvbnRyb2xsZXJzIGFjY2Vzc2VkIGJ5IHVuaXQgdGVzdHNcbiAgICovXG4gIF9pbnRlcm5hbEZldGNoQ29udHJvbGxlcnM6IE1hcDxzdHJpbmcsIEFib3J0Q29udHJvbGxlcj47XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBJbnRlcm5hbCBwZW5kaW5nIERlZmVycmVkRGF0YSBpbnN0YW5jZXMgYWNjZXNzZWQgYnkgdW5pdCB0ZXN0c1xuICAgKi9cbiAgX2ludGVybmFsQWN0aXZlRGVmZXJyZWRzOiBNYXA8c3RyaW5nLCBEZWZlcnJlZERhdGE+O1xufVxuXG4vKipcbiAqIFN0YXRlIG1haW50YWluZWQgaW50ZXJuYWxseSBieSB0aGUgcm91dGVyLiAgRHVyaW5nIGEgbmF2aWdhdGlvbiwgYWxsIHN0YXRlc1xuICogcmVmbGVjdCB0aGUgdGhlIFwib2xkXCIgbG9jYXRpb24gdW5sZXNzIG90aGVyd2lzZSBub3RlZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXJTdGF0ZSB7XG4gIC8qKlxuICAgKiBUaGUgYWN0aW9uIG9mIHRoZSBtb3N0IHJlY2VudCBuYXZpZ2F0aW9uXG4gICAqL1xuICBoaXN0b3J5QWN0aW9uOiBIaXN0b3J5QWN0aW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBsb2NhdGlvbiByZWZsZWN0ZWQgYnkgdGhlIHJvdXRlclxuICAgKi9cbiAgbG9jYXRpb246IExvY2F0aW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBzZXQgb2Ygcm91dGUgbWF0Y2hlc1xuICAgKi9cbiAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdO1xuXG4gIC8qKlxuICAgKiBUcmFja3Mgd2hldGhlciB3ZSd2ZSBjb21wbGV0ZWQgb3VyIGluaXRpYWwgZGF0YSBsb2FkXG4gICAqL1xuICBpbml0aWFsaXplZDogYm9vbGVhbjtcblxuICAvKipcbiAgICogQ3VycmVudCBzY3JvbGwgcG9zaXRpb24gd2Ugc2hvdWxkIHN0YXJ0IGF0IGZvciBhIG5ldyB2aWV3XG4gICAqICAtIG51bWJlciAtPiBzY3JvbGwgcG9zaXRpb24gdG8gcmVzdG9yZSB0b1xuICAgKiAgLSBmYWxzZSAtPiBkbyBub3QgcmVzdG9yZSBzY3JvbGwgYXQgYWxsICh1c2VkIGR1cmluZyBzdWJtaXNzaW9ucylcbiAgICogIC0gbnVsbCAtPiBkb24ndCBoYXZlIGEgc2F2ZWQgcG9zaXRpb24sIHNjcm9sbCB0byBoYXNoIG9yIHRvcCBvZiBwYWdlXG4gICAqL1xuICByZXN0b3JlU2Nyb2xsUG9zaXRpb246IG51bWJlciB8IGZhbHNlIHwgbnVsbDtcblxuICAvKipcbiAgICogSW5kaWNhdGUgd2hldGhlciB0aGlzIG5hdmlnYXRpb24gc2hvdWxkIHNraXAgcmVzZXR0aW5nIHRoZSBzY3JvbGwgcG9zaXRpb25cbiAgICogaWYgd2UgYXJlIHVuYWJsZSB0byByZXN0b3JlIHRoZSBzY3JvbGwgcG9zaXRpb25cbiAgICovXG4gIHByZXZlbnRTY3JvbGxSZXNldDogYm9vbGVhbjtcblxuICAvKipcbiAgICogVHJhY2tzIHRoZSBzdGF0ZSBvZiB0aGUgY3VycmVudCBuYXZpZ2F0aW9uXG4gICAqL1xuICBuYXZpZ2F0aW9uOiBOYXZpZ2F0aW9uO1xuXG4gIC8qKlxuICAgKiBUcmFja3MgYW55IGluLXByb2dyZXNzIHJldmFsaWRhdGlvbnNcbiAgICovXG4gIHJldmFsaWRhdGlvbjogUmV2YWxpZGF0aW9uU3RhdGU7XG5cbiAgLyoqXG4gICAqIERhdGEgZnJvbSB0aGUgbG9hZGVycyBmb3IgdGhlIGN1cnJlbnQgbWF0Y2hlc1xuICAgKi9cbiAgbG9hZGVyRGF0YTogUm91dGVEYXRhO1xuXG4gIC8qKlxuICAgKiBEYXRhIGZyb20gdGhlIGFjdGlvbiBmb3IgdGhlIGN1cnJlbnQgbWF0Y2hlc1xuICAgKi9cbiAgYWN0aW9uRGF0YTogUm91dGVEYXRhIHwgbnVsbDtcblxuICAvKipcbiAgICogRXJyb3JzIGNhdWdodCBmcm9tIGxvYWRlcnMgZm9yIHRoZSBjdXJyZW50IG1hdGNoZXNcbiAgICovXG4gIGVycm9yczogUm91dGVEYXRhIHwgbnVsbDtcblxuICAvKipcbiAgICogTWFwIG9mIGN1cnJlbnQgZmV0Y2hlcnNcbiAgICovXG4gIGZldGNoZXJzOiBNYXA8c3RyaW5nLCBGZXRjaGVyPjtcblxuICAvKipcbiAgICogTWFwIG9mIGN1cnJlbnQgYmxvY2tlcnNcbiAgICovXG4gIGJsb2NrZXJzOiBNYXA8c3RyaW5nLCBCbG9ja2VyPjtcbn1cblxuLyoqXG4gKiBEYXRhIHRoYXQgY2FuIGJlIHBhc3NlZCBpbnRvIGh5ZHJhdGUgYSBSb3V0ZXIgZnJvbSBTU1JcbiAqL1xuZXhwb3J0IHR5cGUgSHlkcmF0aW9uU3RhdGUgPSBQYXJ0aWFsPFxuICBQaWNrPFJvdXRlclN0YXRlLCBcImxvYWRlckRhdGFcIiB8IFwiYWN0aW9uRGF0YVwiIHwgXCJlcnJvcnNcIj5cbj47XG5cbi8qKlxuICogRnV0dXJlIGZsYWdzIHRvIHRvZ2dsZSBuZXcgZmVhdHVyZSBiZWhhdmlvclxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZ1dHVyZUNvbmZpZyB7XG4gIHY3X2ZldGNoZXJQZXJzaXN0OiBib29sZWFuO1xuICB2N19ub3JtYWxpemVGb3JtTWV0aG9kOiBib29sZWFuO1xuICB2N19wcmVwZW5kQmFzZW5hbWU6IGJvb2xlYW47XG59XG5cbi8qKlxuICogSW5pdGlhbGl6YXRpb24gb3B0aW9ucyBmb3IgY3JlYXRlUm91dGVyXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVySW5pdCB7XG4gIHJvdXRlczogQWdub3N0aWNSb3V0ZU9iamVjdFtdO1xuICBoaXN0b3J5OiBIaXN0b3J5O1xuICBiYXNlbmFtZT86IHN0cmluZztcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgbWFwUm91dGVQcm9wZXJ0aWVzYCBpbnN0ZWFkXG4gICAqL1xuICBkZXRlY3RFcnJvckJvdW5kYXJ5PzogRGV0ZWN0RXJyb3JCb3VuZGFyeUZ1bmN0aW9uO1xuICBtYXBSb3V0ZVByb3BlcnRpZXM/OiBNYXBSb3V0ZVByb3BlcnRpZXNGdW5jdGlvbjtcbiAgZnV0dXJlPzogUGFydGlhbDxGdXR1cmVDb25maWc+O1xuICBoeWRyYXRpb25EYXRhPzogSHlkcmF0aW9uU3RhdGU7XG4gIHdpbmRvdz86IFdpbmRvdztcbn1cblxuLyoqXG4gKiBTdGF0ZSByZXR1cm5lZCBmcm9tIGEgc2VydmVyLXNpZGUgcXVlcnkoKSBjYWxsXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGljSGFuZGxlckNvbnRleHQge1xuICBiYXNlbmFtZTogUm91dGVyW1wiYmFzZW5hbWVcIl07XG4gIGxvY2F0aW9uOiBSb3V0ZXJTdGF0ZVtcImxvY2F0aW9uXCJdO1xuICBtYXRjaGVzOiBSb3V0ZXJTdGF0ZVtcIm1hdGNoZXNcIl07XG4gIGxvYWRlckRhdGE6IFJvdXRlclN0YXRlW1wibG9hZGVyRGF0YVwiXTtcbiAgYWN0aW9uRGF0YTogUm91dGVyU3RhdGVbXCJhY3Rpb25EYXRhXCJdO1xuICBlcnJvcnM6IFJvdXRlclN0YXRlW1wiZXJyb3JzXCJdO1xuICBzdGF0dXNDb2RlOiBudW1iZXI7XG4gIGxvYWRlckhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIEhlYWRlcnM+O1xuICBhY3Rpb25IZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBIZWFkZXJzPjtcbiAgYWN0aXZlRGVmZXJyZWRzOiBSZWNvcmQ8c3RyaW5nLCBEZWZlcnJlZERhdGE+IHwgbnVsbDtcbiAgX2RlZXBlc3RSZW5kZXJlZEJvdW5kYXJ5SWQ/OiBzdHJpbmcgfCBudWxsO1xufVxuXG4vKipcbiAqIEEgU3RhdGljSGFuZGxlciBpbnN0YW5jZSBtYW5hZ2VzIGEgc2luZ3VsYXIgU1NSIG5hdmlnYXRpb24vZmV0Y2ggZXZlbnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdGF0aWNIYW5kbGVyIHtcbiAgZGF0YVJvdXRlczogQWdub3N0aWNEYXRhUm91dGVPYmplY3RbXTtcbiAgcXVlcnkoXG4gICAgcmVxdWVzdDogUmVxdWVzdCxcbiAgICBvcHRzPzogeyByZXF1ZXN0Q29udGV4dD86IHVua25vd24gfVxuICApOiBQcm9taXNlPFN0YXRpY0hhbmRsZXJDb250ZXh0IHwgUmVzcG9uc2U+O1xuICBxdWVyeVJvdXRlKFxuICAgIHJlcXVlc3Q6IFJlcXVlc3QsXG4gICAgb3B0cz86IHsgcm91dGVJZD86IHN0cmluZzsgcmVxdWVzdENvbnRleHQ/OiB1bmtub3duIH1cbiAgKTogUHJvbWlzZTxhbnk+O1xufVxuXG50eXBlIFZpZXdUcmFuc2l0aW9uT3B0cyA9IHtcbiAgY3VycmVudExvY2F0aW9uOiBMb2NhdGlvbjtcbiAgbmV4dExvY2F0aW9uOiBMb2NhdGlvbjtcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlciBmdW5jdGlvbiBzaWduYXR1cmUgZm9yIGNoYW5nZXMgdG8gcm91dGVyIHN0YXRlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVyU3Vic2NyaWJlciB7XG4gIChcbiAgICBzdGF0ZTogUm91dGVyU3RhdGUsXG4gICAgb3B0czoge1xuICAgICAgZGVsZXRlZEZldGNoZXJzOiBzdHJpbmdbXTtcbiAgICAgIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uT3B0cz86IFZpZXdUcmFuc2l0aW9uT3B0cztcbiAgICAgIHVuc3RhYmxlX2ZsdXNoU3luYzogYm9vbGVhbjtcbiAgICB9XG4gICk6IHZvaWQ7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gc2lnbmF0dXJlIGZvciBkZXRlcm1pbmluZyB0aGUga2V5IHRvIGJlIHVzZWQgaW4gc2Nyb2xsIHJlc3RvcmF0aW9uXG4gKiBmb3IgYSBnaXZlbiBsb2NhdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIEdldFNjcm9sbFJlc3RvcmF0aW9uS2V5RnVuY3Rpb24ge1xuICAobG9jYXRpb246IExvY2F0aW9uLCBtYXRjaGVzOiBVSU1hdGNoW10pOiBzdHJpbmcgfCBudWxsO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHNpZ25hdHVyZSBmb3IgZGV0ZXJtaW5pbmcgdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgR2V0U2Nyb2xsUG9zaXRpb25GdW5jdGlvbiB7XG4gICgpOiBudW1iZXI7XG59XG5cbmV4cG9ydCB0eXBlIFJlbGF0aXZlUm91dGluZ1R5cGUgPSBcInJvdXRlXCIgfCBcInBhdGhcIjtcblxuLy8gQWxsb3dlZCBmb3IgYW55IG5hdmlnYXRpb24gb3IgZmV0Y2hcbnR5cGUgQmFzZU5hdmlnYXRlT3JGZXRjaE9wdGlvbnMgPSB7XG4gIHByZXZlbnRTY3JvbGxSZXNldD86IGJvb2xlYW47XG4gIHJlbGF0aXZlPzogUmVsYXRpdmVSb3V0aW5nVHlwZTtcbiAgdW5zdGFibGVfZmx1c2hTeW5jPzogYm9vbGVhbjtcbn07XG5cbi8vIE9ubHkgYWxsb3dlZCBmb3IgbmF2aWdhdGlvbnNcbnR5cGUgQmFzZU5hdmlnYXRlT3B0aW9ucyA9IEJhc2VOYXZpZ2F0ZU9yRmV0Y2hPcHRpb25zICYge1xuICByZXBsYWNlPzogYm9vbGVhbjtcbiAgc3RhdGU/OiBhbnk7XG4gIGZyb21Sb3V0ZUlkPzogc3RyaW5nO1xuICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbj86IGJvb2xlYW47XG59O1xuXG4vLyBPbmx5IGFsbG93ZWQgZm9yIHN1Ym1pc3Npb24gbmF2aWdhdGlvbnNcbnR5cGUgQmFzZVN1Ym1pc3Npb25PcHRpb25zID0ge1xuICBmb3JtTWV0aG9kPzogSFRNTEZvcm1NZXRob2Q7XG4gIGZvcm1FbmNUeXBlPzogRm9ybUVuY1R5cGU7XG59ICYgKFxuICB8IHsgZm9ybURhdGE6IEZvcm1EYXRhOyBib2R5PzogdW5kZWZpbmVkIH1cbiAgfCB7IGZvcm1EYXRhPzogdW5kZWZpbmVkOyBib2R5OiBhbnkgfVxuKTtcblxuLyoqXG4gKiBPcHRpb25zIGZvciBhIG5hdmlnYXRlKCkgY2FsbCBmb3IgYSBub3JtYWwgKG5vbi1zdWJtaXNzaW9uKSBuYXZpZ2F0aW9uXG4gKi9cbnR5cGUgTGlua05hdmlnYXRlT3B0aW9ucyA9IEJhc2VOYXZpZ2F0ZU9wdGlvbnM7XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgYSBuYXZpZ2F0ZSgpIGNhbGwgZm9yIGEgc3VibWlzc2lvbiBuYXZpZ2F0aW9uXG4gKi9cbnR5cGUgU3VibWlzc2lvbk5hdmlnYXRlT3B0aW9ucyA9IEJhc2VOYXZpZ2F0ZU9wdGlvbnMgJiBCYXNlU3VibWlzc2lvbk9wdGlvbnM7XG5cbi8qKlxuICogT3B0aW9ucyB0byBwYXNzIHRvIG5hdmlnYXRlKCkgZm9yIGEgbmF2aWdhdGlvblxuICovXG5leHBvcnQgdHlwZSBSb3V0ZXJOYXZpZ2F0ZU9wdGlvbnMgPVxuICB8IExpbmtOYXZpZ2F0ZU9wdGlvbnNcbiAgfCBTdWJtaXNzaW9uTmF2aWdhdGVPcHRpb25zO1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGEgZmV0Y2goKSBsb2FkXG4gKi9cbnR5cGUgTG9hZEZldGNoT3B0aW9ucyA9IEJhc2VOYXZpZ2F0ZU9yRmV0Y2hPcHRpb25zO1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGEgZmV0Y2goKSBzdWJtaXNzaW9uXG4gKi9cbnR5cGUgU3VibWl0RmV0Y2hPcHRpb25zID0gQmFzZU5hdmlnYXRlT3JGZXRjaE9wdGlvbnMgJiBCYXNlU3VibWlzc2lvbk9wdGlvbnM7XG5cbi8qKlxuICogT3B0aW9ucyB0byBwYXNzIHRvIGZldGNoKClcbiAqL1xuZXhwb3J0IHR5cGUgUm91dGVyRmV0Y2hPcHRpb25zID0gTG9hZEZldGNoT3B0aW9ucyB8IFN1Ym1pdEZldGNoT3B0aW9ucztcblxuLyoqXG4gKiBQb3RlbnRpYWwgc3RhdGVzIGZvciBzdGF0ZS5uYXZpZ2F0aW9uXG4gKi9cbmV4cG9ydCB0eXBlIE5hdmlnYXRpb25TdGF0ZXMgPSB7XG4gIElkbGU6IHtcbiAgICBzdGF0ZTogXCJpZGxlXCI7XG4gICAgbG9jYXRpb246IHVuZGVmaW5lZDtcbiAgICBmb3JtTWV0aG9kOiB1bmRlZmluZWQ7XG4gICAgZm9ybUFjdGlvbjogdW5kZWZpbmVkO1xuICAgIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQ7XG4gICAgZm9ybURhdGE6IHVuZGVmaW5lZDtcbiAgICBqc29uOiB1bmRlZmluZWQ7XG4gICAgdGV4dDogdW5kZWZpbmVkO1xuICB9O1xuICBMb2FkaW5nOiB7XG4gICAgc3RhdGU6IFwibG9hZGluZ1wiO1xuICAgIGxvY2F0aW9uOiBMb2NhdGlvbjtcbiAgICBmb3JtTWV0aG9kOiBTdWJtaXNzaW9uW1wiZm9ybU1ldGhvZFwiXSB8IHVuZGVmaW5lZDtcbiAgICBmb3JtQWN0aW9uOiBTdWJtaXNzaW9uW1wiZm9ybUFjdGlvblwiXSB8IHVuZGVmaW5lZDtcbiAgICBmb3JtRW5jVHlwZTogU3VibWlzc2lvbltcImZvcm1FbmNUeXBlXCJdIHwgdW5kZWZpbmVkO1xuICAgIGZvcm1EYXRhOiBTdWJtaXNzaW9uW1wiZm9ybURhdGFcIl0gfCB1bmRlZmluZWQ7XG4gICAganNvbjogU3VibWlzc2lvbltcImpzb25cIl0gfCB1bmRlZmluZWQ7XG4gICAgdGV4dDogU3VibWlzc2lvbltcInRleHRcIl0gfCB1bmRlZmluZWQ7XG4gIH07XG4gIFN1Ym1pdHRpbmc6IHtcbiAgICBzdGF0ZTogXCJzdWJtaXR0aW5nXCI7XG4gICAgbG9jYXRpb246IExvY2F0aW9uO1xuICAgIGZvcm1NZXRob2Q6IFN1Ym1pc3Npb25bXCJmb3JtTWV0aG9kXCJdO1xuICAgIGZvcm1BY3Rpb246IFN1Ym1pc3Npb25bXCJmb3JtQWN0aW9uXCJdO1xuICAgIGZvcm1FbmNUeXBlOiBTdWJtaXNzaW9uW1wiZm9ybUVuY1R5cGVcIl07XG4gICAgZm9ybURhdGE6IFN1Ym1pc3Npb25bXCJmb3JtRGF0YVwiXTtcbiAgICBqc29uOiBTdWJtaXNzaW9uW1wianNvblwiXTtcbiAgICB0ZXh0OiBTdWJtaXNzaW9uW1widGV4dFwiXTtcbiAgfTtcbn07XG5cbmV4cG9ydCB0eXBlIE5hdmlnYXRpb24gPSBOYXZpZ2F0aW9uU3RhdGVzW2tleW9mIE5hdmlnYXRpb25TdGF0ZXNdO1xuXG5leHBvcnQgdHlwZSBSZXZhbGlkYXRpb25TdGF0ZSA9IFwiaWRsZVwiIHwgXCJsb2FkaW5nXCI7XG5cbi8qKlxuICogUG90ZW50aWFsIHN0YXRlcyBmb3IgZmV0Y2hlcnNcbiAqL1xudHlwZSBGZXRjaGVyU3RhdGVzPFREYXRhID0gYW55PiA9IHtcbiAgSWRsZToge1xuICAgIHN0YXRlOiBcImlkbGVcIjtcbiAgICBmb3JtTWV0aG9kOiB1bmRlZmluZWQ7XG4gICAgZm9ybUFjdGlvbjogdW5kZWZpbmVkO1xuICAgIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQ7XG4gICAgdGV4dDogdW5kZWZpbmVkO1xuICAgIGZvcm1EYXRhOiB1bmRlZmluZWQ7XG4gICAganNvbjogdW5kZWZpbmVkO1xuICAgIGRhdGE6IFREYXRhIHwgdW5kZWZpbmVkO1xuICB9O1xuICBMb2FkaW5nOiB7XG4gICAgc3RhdGU6IFwibG9hZGluZ1wiO1xuICAgIGZvcm1NZXRob2Q6IFN1Ym1pc3Npb25bXCJmb3JtTWV0aG9kXCJdIHwgdW5kZWZpbmVkO1xuICAgIGZvcm1BY3Rpb246IFN1Ym1pc3Npb25bXCJmb3JtQWN0aW9uXCJdIHwgdW5kZWZpbmVkO1xuICAgIGZvcm1FbmNUeXBlOiBTdWJtaXNzaW9uW1wiZm9ybUVuY1R5cGVcIl0gfCB1bmRlZmluZWQ7XG4gICAgdGV4dDogU3VibWlzc2lvbltcInRleHRcIl0gfCB1bmRlZmluZWQ7XG4gICAgZm9ybURhdGE6IFN1Ym1pc3Npb25bXCJmb3JtRGF0YVwiXSB8IHVuZGVmaW5lZDtcbiAgICBqc29uOiBTdWJtaXNzaW9uW1wianNvblwiXSB8IHVuZGVmaW5lZDtcbiAgICBkYXRhOiBURGF0YSB8IHVuZGVmaW5lZDtcbiAgfTtcbiAgU3VibWl0dGluZzoge1xuICAgIHN0YXRlOiBcInN1Ym1pdHRpbmdcIjtcbiAgICBmb3JtTWV0aG9kOiBTdWJtaXNzaW9uW1wiZm9ybU1ldGhvZFwiXTtcbiAgICBmb3JtQWN0aW9uOiBTdWJtaXNzaW9uW1wiZm9ybUFjdGlvblwiXTtcbiAgICBmb3JtRW5jVHlwZTogU3VibWlzc2lvbltcImZvcm1FbmNUeXBlXCJdO1xuICAgIHRleHQ6IFN1Ym1pc3Npb25bXCJ0ZXh0XCJdO1xuICAgIGZvcm1EYXRhOiBTdWJtaXNzaW9uW1wiZm9ybURhdGFcIl07XG4gICAganNvbjogU3VibWlzc2lvbltcImpzb25cIl07XG4gICAgZGF0YTogVERhdGEgfCB1bmRlZmluZWQ7XG4gIH07XG59O1xuXG5leHBvcnQgdHlwZSBGZXRjaGVyPFREYXRhID0gYW55PiA9XG4gIEZldGNoZXJTdGF0ZXM8VERhdGE+W2tleW9mIEZldGNoZXJTdGF0ZXM8VERhdGE+XTtcblxuaW50ZXJmYWNlIEJsb2NrZXJCbG9ja2VkIHtcbiAgc3RhdGU6IFwiYmxvY2tlZFwiO1xuICByZXNldCgpOiB2b2lkO1xuICBwcm9jZWVkKCk6IHZvaWQ7XG4gIGxvY2F0aW9uOiBMb2NhdGlvbjtcbn1cblxuaW50ZXJmYWNlIEJsb2NrZXJVbmJsb2NrZWQge1xuICBzdGF0ZTogXCJ1bmJsb2NrZWRcIjtcbiAgcmVzZXQ6IHVuZGVmaW5lZDtcbiAgcHJvY2VlZDogdW5kZWZpbmVkO1xuICBsb2NhdGlvbjogdW5kZWZpbmVkO1xufVxuXG5pbnRlcmZhY2UgQmxvY2tlclByb2NlZWRpbmcge1xuICBzdGF0ZTogXCJwcm9jZWVkaW5nXCI7XG4gIHJlc2V0OiB1bmRlZmluZWQ7XG4gIHByb2NlZWQ6IHVuZGVmaW5lZDtcbiAgbG9jYXRpb246IExvY2F0aW9uO1xufVxuXG5leHBvcnQgdHlwZSBCbG9ja2VyID0gQmxvY2tlclVuYmxvY2tlZCB8IEJsb2NrZXJCbG9ja2VkIHwgQmxvY2tlclByb2NlZWRpbmc7XG5cbmV4cG9ydCB0eXBlIEJsb2NrZXJGdW5jdGlvbiA9IChhcmdzOiB7XG4gIGN1cnJlbnRMb2NhdGlvbjogTG9jYXRpb247XG4gIG5leHRMb2NhdGlvbjogTG9jYXRpb247XG4gIGhpc3RvcnlBY3Rpb246IEhpc3RvcnlBY3Rpb247XG59KSA9PiBib29sZWFuO1xuXG5pbnRlcmZhY2UgU2hvcnRDaXJjdWl0YWJsZSB7XG4gIC8qKlxuICAgKiBzdGFydE5hdmlnYXRpb24gZG9lcyBub3QgbmVlZCB0byBjb21wbGV0ZSB0aGUgbmF2aWdhdGlvbiBiZWNhdXNlIHdlXG4gICAqIHJlZGlyZWN0ZWQgb3IgZ290IGludGVycnVwdGVkXG4gICAqL1xuICBzaG9ydENpcmN1aXRlZD86IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBIYW5kbGVBY3Rpb25SZXN1bHQgZXh0ZW5kcyBTaG9ydENpcmN1aXRhYmxlIHtcbiAgLyoqXG4gICAqIEVycm9yIHRocm93biBmcm9tIHRoZSBjdXJyZW50IGFjdGlvbiwga2V5ZWQgYnkgdGhlIHJvdXRlIGNvbnRhaW5pbmcgdGhlXG4gICAqIGVycm9yIGJvdW5kYXJ5IHRvIHJlbmRlciB0aGUgZXJyb3IuICBUbyBiZSBjb21taXR0ZWQgdG8gdGhlIHN0YXRlIGFmdGVyXG4gICAqIGxvYWRlcnMgaGF2ZSBjb21wbGV0ZWRcbiAgICovXG4gIHBlbmRpbmdBY3Rpb25FcnJvcj86IFJvdXRlRGF0YTtcbiAgLyoqXG4gICAqIERhdGEgcmV0dXJuZWQgZnJvbSB0aGUgY3VycmVudCBhY3Rpb24sIGtleWVkIGJ5IHRoZSByb3V0ZSBvd25pbmcgdGhlIGFjdGlvbi5cbiAgICogVG8gYmUgY29tbWl0dGVkIHRvIHRoZSBzdGF0ZSBhZnRlciBsb2FkZXJzIGhhdmUgY29tcGxldGVkXG4gICAqL1xuICBwZW5kaW5nQWN0aW9uRGF0YT86IFJvdXRlRGF0YTtcbn1cblxuaW50ZXJmYWNlIEhhbmRsZUxvYWRlcnNSZXN1bHQgZXh0ZW5kcyBTaG9ydENpcmN1aXRhYmxlIHtcbiAgLyoqXG4gICAqIGxvYWRlckRhdGEgcmV0dXJuZWQgZnJvbSB0aGUgY3VycmVudCBzZXQgb2YgbG9hZGVyc1xuICAgKi9cbiAgbG9hZGVyRGF0YT86IFJvdXRlclN0YXRlW1wibG9hZGVyRGF0YVwiXTtcbiAgLyoqXG4gICAqIGVycm9ycyB0aHJvd24gZnJvbSB0aGUgY3VycmVudCBzZXQgb2YgbG9hZGVyc1xuICAgKi9cbiAgZXJyb3JzPzogUm91dGVyU3RhdGVbXCJlcnJvcnNcIl07XG59XG5cbi8qKlxuICogQ2FjaGVkIGluZm8gZm9yIGFjdGl2ZSBmZXRjaGVyLmxvYWQoKSBpbnN0YW5jZXMgc28gdGhleSBjYW4gcGFydGljaXBhdGVcbiAqIGluIHJldmFsaWRhdGlvblxuICovXG5pbnRlcmZhY2UgRmV0Y2hMb2FkTWF0Y2gge1xuICByb3V0ZUlkOiBzdHJpbmc7XG4gIHBhdGg6IHN0cmluZztcbn1cblxuLyoqXG4gKiBJZGVudGlmaWVkIGZldGNoZXIubG9hZCgpIGNhbGxzIHRoYXQgbmVlZCB0byBiZSByZXZhbGlkYXRlZFxuICovXG5pbnRlcmZhY2UgUmV2YWxpZGF0aW5nRmV0Y2hlciBleHRlbmRzIEZldGNoTG9hZE1hdGNoIHtcbiAga2V5OiBzdHJpbmc7XG4gIG1hdGNoOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoIHwgbnVsbDtcbiAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdIHwgbnVsbDtcbiAgY29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyIHwgbnVsbDtcbn1cblxuLyoqXG4gKiBXcmFwcGVyIG9iamVjdCB0byBhbGxvdyB1cyB0byB0aHJvdyBhbnkgcmVzcG9uc2Ugb3V0IGZyb20gY2FsbExvYWRlck9yQWN0aW9uXG4gKiBmb3IgcXVlcnlSb3V0ZXIgd2hpbGUgcHJlc2VydmluZyB3aGV0aGVyIG9yIG5vdCBpdCB3YXMgdGhyb3duIG9yIHJldHVybmVkXG4gKiBmcm9tIHRoZSBsb2FkZXIvYWN0aW9uXG4gKi9cbmludGVyZmFjZSBRdWVyeVJvdXRlUmVzcG9uc2Uge1xuICB0eXBlOiBSZXN1bHRUeXBlLmRhdGEgfCBSZXN1bHRUeXBlLmVycm9yO1xuICByZXNwb25zZTogUmVzcG9uc2U7XG59XG5cbmNvbnN0IHZhbGlkTXV0YXRpb25NZXRob2RzQXJyOiBNdXRhdGlvbkZvcm1NZXRob2RbXSA9IFtcbiAgXCJwb3N0XCIsXG4gIFwicHV0XCIsXG4gIFwicGF0Y2hcIixcbiAgXCJkZWxldGVcIixcbl07XG5jb25zdCB2YWxpZE11dGF0aW9uTWV0aG9kcyA9IG5ldyBTZXQ8TXV0YXRpb25Gb3JtTWV0aG9kPihcbiAgdmFsaWRNdXRhdGlvbk1ldGhvZHNBcnJcbik7XG5cbmNvbnN0IHZhbGlkUmVxdWVzdE1ldGhvZHNBcnI6IEZvcm1NZXRob2RbXSA9IFtcbiAgXCJnZXRcIixcbiAgLi4udmFsaWRNdXRhdGlvbk1ldGhvZHNBcnIsXG5dO1xuY29uc3QgdmFsaWRSZXF1ZXN0TWV0aG9kcyA9IG5ldyBTZXQ8Rm9ybU1ldGhvZD4odmFsaWRSZXF1ZXN0TWV0aG9kc0Fycik7XG5cbmNvbnN0IHJlZGlyZWN0U3RhdHVzQ29kZXMgPSBuZXcgU2V0KFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF0pO1xuY29uc3QgcmVkaXJlY3RQcmVzZXJ2ZU1ldGhvZFN0YXR1c0NvZGVzID0gbmV3IFNldChbMzA3LCAzMDhdKTtcblxuZXhwb3J0IGNvbnN0IElETEVfTkFWSUdBVElPTjogTmF2aWdhdGlvblN0YXRlc1tcIklkbGVcIl0gPSB7XG4gIHN0YXRlOiBcImlkbGVcIixcbiAgbG9jYXRpb246IHVuZGVmaW5lZCxcbiAgZm9ybU1ldGhvZDogdW5kZWZpbmVkLFxuICBmb3JtQWN0aW9uOiB1bmRlZmluZWQsXG4gIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXG4gIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gIGpzb246IHVuZGVmaW5lZCxcbiAgdGV4dDogdW5kZWZpbmVkLFxufTtcblxuZXhwb3J0IGNvbnN0IElETEVfRkVUQ0hFUjogRmV0Y2hlclN0YXRlc1tcIklkbGVcIl0gPSB7XG4gIHN0YXRlOiBcImlkbGVcIixcbiAgZGF0YTogdW5kZWZpbmVkLFxuICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgZm9ybUVuY1R5cGU6IHVuZGVmaW5lZCxcbiAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAganNvbjogdW5kZWZpbmVkLFxuICB0ZXh0OiB1bmRlZmluZWQsXG59O1xuXG5leHBvcnQgY29uc3QgSURMRV9CTE9DS0VSOiBCbG9ja2VyVW5ibG9ja2VkID0ge1xuICBzdGF0ZTogXCJ1bmJsb2NrZWRcIixcbiAgcHJvY2VlZDogdW5kZWZpbmVkLFxuICByZXNldDogdW5kZWZpbmVkLFxuICBsb2NhdGlvbjogdW5kZWZpbmVkLFxufTtcblxuY29uc3QgQUJTT0xVVEVfVVJMX1JFR0VYID0gL14oPzpbYS16XVthLXowLTkrLi1dKjp8XFwvXFwvKS9pO1xuXG5jb25zdCBkZWZhdWx0TWFwUm91dGVQcm9wZXJ0aWVzOiBNYXBSb3V0ZVByb3BlcnRpZXNGdW5jdGlvbiA9IChyb3V0ZSkgPT4gKHtcbiAgaGFzRXJyb3JCb3VuZGFyeTogQm9vbGVhbihyb3V0ZS5oYXNFcnJvckJvdW5kYXJ5KSxcbn0pO1xuXG5jb25zdCBUUkFOU0lUSU9OU19TVE9SQUdFX0tFWSA9IFwicmVtaXgtcm91dGVyLXRyYW5zaXRpb25zXCI7XG5cbi8vI2VuZHJlZ2lvblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIGNyZWF0ZVJvdXRlclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBDcmVhdGUgYSByb3V0ZXIgYW5kIGxpc3RlbiB0byBoaXN0b3J5IFBPUCBuYXZpZ2F0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUm91dGVyKGluaXQ6IFJvdXRlckluaXQpOiBSb3V0ZXIge1xuICBjb25zdCByb3V0ZXJXaW5kb3cgPSBpbml0LndpbmRvd1xuICAgID8gaW5pdC53aW5kb3dcbiAgICA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCJcbiAgICA/IHdpbmRvd1xuICAgIDogdW5kZWZpbmVkO1xuICBjb25zdCBpc0Jyb3dzZXIgPVxuICAgIHR5cGVvZiByb3V0ZXJXaW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICB0eXBlb2Ygcm91dGVyV2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgdHlwZW9mIHJvdXRlcldpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xuICBjb25zdCBpc1NlcnZlciA9ICFpc0Jyb3dzZXI7XG5cbiAgaW52YXJpYW50KFxuICAgIGluaXQucm91dGVzLmxlbmd0aCA+IDAsXG4gICAgXCJZb3UgbXVzdCBwcm92aWRlIGEgbm9uLWVtcHR5IHJvdXRlcyBhcnJheSB0byBjcmVhdGVSb3V0ZXJcIlxuICApO1xuXG4gIGxldCBtYXBSb3V0ZVByb3BlcnRpZXM6IE1hcFJvdXRlUHJvcGVydGllc0Z1bmN0aW9uO1xuICBpZiAoaW5pdC5tYXBSb3V0ZVByb3BlcnRpZXMpIHtcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMgPSBpbml0Lm1hcFJvdXRlUHJvcGVydGllcztcbiAgfSBlbHNlIGlmIChpbml0LmRldGVjdEVycm9yQm91bmRhcnkpIHtcbiAgICAvLyBJZiB0aGV5IGFyZSBzdGlsbCB1c2luZyB0aGUgZGVwcmVjYXRlZCB2ZXJzaW9uLCB3cmFwIGl0IHdpdGggdGhlIG5ldyBBUElcbiAgICBsZXQgZGV0ZWN0RXJyb3JCb3VuZGFyeSA9IGluaXQuZGV0ZWN0RXJyb3JCb3VuZGFyeTtcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMgPSAocm91dGUpID0+ICh7XG4gICAgICBoYXNFcnJvckJvdW5kYXJ5OiBkZXRlY3RFcnJvckJvdW5kYXJ5KHJvdXRlKSxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMgPSBkZWZhdWx0TWFwUm91dGVQcm9wZXJ0aWVzO1xuICB9XG5cbiAgLy8gUm91dGVzIGtleWVkIGJ5IElEXG4gIGxldCBtYW5pZmVzdDogUm91dGVNYW5pZmVzdCA9IHt9O1xuICAvLyBSb3V0ZXMgaW4gdHJlZSBmb3JtYXQgZm9yIG1hdGNoaW5nXG4gIGxldCBkYXRhUm91dGVzID0gY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyhcbiAgICBpbml0LnJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMsXG4gICAgdW5kZWZpbmVkLFxuICAgIG1hbmlmZXN0XG4gICk7XG4gIGxldCBpbkZsaWdodERhdGFSb3V0ZXM6IEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0W10gfCB1bmRlZmluZWQ7XG4gIGxldCBiYXNlbmFtZSA9IGluaXQuYmFzZW5hbWUgfHwgXCIvXCI7XG4gIC8vIENvbmZpZyBkcml2ZW4gYmVoYXZpb3IgZmxhZ3NcbiAgbGV0IGZ1dHVyZTogRnV0dXJlQ29uZmlnID0ge1xuICAgIHY3X2ZldGNoZXJQZXJzaXN0OiBmYWxzZSxcbiAgICB2N19ub3JtYWxpemVGb3JtTWV0aG9kOiBmYWxzZSxcbiAgICB2N19wcmVwZW5kQmFzZW5hbWU6IGZhbHNlLFxuICAgIC4uLmluaXQuZnV0dXJlLFxuICB9O1xuICAvLyBDbGVhbnVwIGZ1bmN0aW9uIGZvciBoaXN0b3J5XG4gIGxldCB1bmxpc3Rlbkhpc3Rvcnk6ICgoKSA9PiB2b2lkKSB8IG51bGwgPSBudWxsO1xuICAvLyBFeHRlcm5hbGx5LXByb3ZpZGVkIGZ1bmN0aW9ucyB0byBjYWxsIG9uIGFsbCBzdGF0ZSBjaGFuZ2VzXG4gIGxldCBzdWJzY3JpYmVycyA9IG5ldyBTZXQ8Um91dGVyU3Vic2NyaWJlcj4oKTtcbiAgLy8gRXh0ZXJuYWxseS1wcm92aWRlZCBvYmplY3QgdG8gaG9sZCBzY3JvbGwgcmVzdG9yYXRpb24gbG9jYXRpb25zIGR1cmluZyByb3V0aW5nXG4gIGxldCBzYXZlZFNjcm9sbFBvc2l0aW9uczogUmVjb3JkPHN0cmluZywgbnVtYmVyPiB8IG51bGwgPSBudWxsO1xuICAvLyBFeHRlcm5hbGx5LXByb3ZpZGVkIGZ1bmN0aW9uIHRvIGdldCBzY3JvbGwgcmVzdG9yYXRpb24ga2V5c1xuICBsZXQgZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXk6IEdldFNjcm9sbFJlc3RvcmF0aW9uS2V5RnVuY3Rpb24gfCBudWxsID0gbnVsbDtcbiAgLy8gRXh0ZXJuYWxseS1wcm92aWRlZCBmdW5jdGlvbiB0byBnZXQgY3VycmVudCBzY3JvbGwgcG9zaXRpb25cbiAgbGV0IGdldFNjcm9sbFBvc2l0aW9uOiBHZXRTY3JvbGxQb3NpdGlvbkZ1bmN0aW9uIHwgbnVsbCA9IG51bGw7XG4gIC8vIE9uZS10aW1lIGZsYWcgdG8gY29udHJvbCB0aGUgaW5pdGlhbCBoeWRyYXRpb24gc2Nyb2xsIHJlc3RvcmF0aW9uLiAgQmVjYXVzZVxuICAvLyB3ZSBkb24ndCBnZXQgdGhlIHNhdmVkIHBvc2l0aW9ucyBmcm9tIDxTY3JvbGxSZXN0b3JhdGlvbiAvPiB1bnRpbCBfYWZ0ZXJfXG4gIC8vIHRoZSBpbml0aWFsIHJlbmRlciwgd2UgbmVlZCB0byBtYW51YWxseSB0cmlnZ2VyIGEgc2VwYXJhdGUgdXBkYXRlU3RhdGUgdG9cbiAgLy8gc2VuZCBhbG9uZyB0aGUgcmVzdG9yZVNjcm9sbFBvc2l0aW9uXG4gIC8vIFNldCB0byB0cnVlIGlmIHdlIGhhdmUgYGh5ZHJhdGlvbkRhdGFgIHNpbmNlIHdlIGFzc3VtZSB3ZSB3ZXJlIFNTUidkIGFuZCB0aGF0XG4gIC8vIFNTUiBkaWQgdGhlIGluaXRpYWwgc2Nyb2xsIHJlc3RvcmF0aW9uLlxuICBsZXQgaW5pdGlhbFNjcm9sbFJlc3RvcmVkID0gaW5pdC5oeWRyYXRpb25EYXRhICE9IG51bGw7XG5cbiAgbGV0IGluaXRpYWxNYXRjaGVzID0gbWF0Y2hSb3V0ZXMoZGF0YVJvdXRlcywgaW5pdC5oaXN0b3J5LmxvY2F0aW9uLCBiYXNlbmFtZSk7XG4gIGxldCBpbml0aWFsRXJyb3JzOiBSb3V0ZURhdGEgfCBudWxsID0gbnVsbDtcblxuICBpZiAoaW5pdGlhbE1hdGNoZXMgPT0gbnVsbCkge1xuICAgIC8vIElmIHdlIGRvIG5vdCBtYXRjaCBhIHVzZXItcHJvdmlkZWQtcm91dGUsIGZhbGwgYmFjayB0byB0aGUgcm9vdFxuICAgIC8vIHRvIGFsbG93IHRoZSBlcnJvciBib3VuZGFyeSB0byB0YWtlIG92ZXJcbiAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwge1xuICAgICAgcGF0aG5hbWU6IGluaXQuaGlzdG9yeS5sb2NhdGlvbi5wYXRobmFtZSxcbiAgICB9KTtcbiAgICBsZXQgeyBtYXRjaGVzLCByb3V0ZSB9ID0gZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyhkYXRhUm91dGVzKTtcbiAgICBpbml0aWFsTWF0Y2hlcyA9IG1hdGNoZXM7XG4gICAgaW5pdGlhbEVycm9ycyA9IHsgW3JvdXRlLmlkXTogZXJyb3IgfTtcbiAgfVxuXG4gIGxldCBpbml0aWFsaXplZCA9XG4gICAgLy8gQWxsIGluaXRpYWxNYXRjaGVzIG5lZWQgdG8gYmUgbG9hZGVkIGJlZm9yZSB3ZSdyZSByZWFkeS4gIElmIHdlIGhhdmUgbGF6eVxuICAgIC8vIGZ1bmN0aW9ucyBhcm91bmQgc3RpbGwgdGhlbiB3ZSdsbCBuZWVkIHRvIHJ1biB0aGVtIGluIGluaXRpYWxpemUoKVxuICAgICFpbml0aWFsTWF0Y2hlcy5zb21lKChtKSA9PiBtLnJvdXRlLmxhenkpICYmXG4gICAgLy8gQW5kIHdlIGhhdmUgdG8gZWl0aGVyIGhhdmUgbm8gbG9hZGVycyBvciBoYXZlIGJlZW4gcHJvdmlkZWQgaHlkcmF0aW9uRGF0YVxuICAgICghaW5pdGlhbE1hdGNoZXMuc29tZSgobSkgPT4gbS5yb3V0ZS5sb2FkZXIpIHx8IGluaXQuaHlkcmF0aW9uRGF0YSAhPSBudWxsKTtcblxuICBsZXQgcm91dGVyOiBSb3V0ZXI7XG4gIGxldCBzdGF0ZTogUm91dGVyU3RhdGUgPSB7XG4gICAgaGlzdG9yeUFjdGlvbjogaW5pdC5oaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaW5pdC5oaXN0b3J5LmxvY2F0aW9uLFxuICAgIG1hdGNoZXM6IGluaXRpYWxNYXRjaGVzLFxuICAgIGluaXRpYWxpemVkLFxuICAgIG5hdmlnYXRpb246IElETEVfTkFWSUdBVElPTixcbiAgICAvLyBEb24ndCByZXN0b3JlIG9uIGluaXRpYWwgdXBkYXRlU3RhdGUoKSBpZiB3ZSB3ZXJlIFNTUidkXG4gICAgcmVzdG9yZVNjcm9sbFBvc2l0aW9uOiBpbml0Lmh5ZHJhdGlvbkRhdGEgIT0gbnVsbCA/IGZhbHNlIDogbnVsbCxcbiAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IGZhbHNlLFxuICAgIHJldmFsaWRhdGlvbjogXCJpZGxlXCIsXG4gICAgbG9hZGVyRGF0YTogKGluaXQuaHlkcmF0aW9uRGF0YSAmJiBpbml0Lmh5ZHJhdGlvbkRhdGEubG9hZGVyRGF0YSkgfHwge30sXG4gICAgYWN0aW9uRGF0YTogKGluaXQuaHlkcmF0aW9uRGF0YSAmJiBpbml0Lmh5ZHJhdGlvbkRhdGEuYWN0aW9uRGF0YSkgfHwgbnVsbCxcbiAgICBlcnJvcnM6IChpbml0Lmh5ZHJhdGlvbkRhdGEgJiYgaW5pdC5oeWRyYXRpb25EYXRhLmVycm9ycykgfHwgaW5pdGlhbEVycm9ycyxcbiAgICBmZXRjaGVyczogbmV3IE1hcCgpLFxuICAgIGJsb2NrZXJzOiBuZXcgTWFwKCksXG4gIH07XG5cbiAgLy8gLS0gU3RhdGVmdWwgaW50ZXJuYWwgdmFyaWFibGVzIHRvIG1hbmFnZSBuYXZpZ2F0aW9ucyAtLVxuICAvLyBDdXJyZW50IG5hdmlnYXRpb24gaW4gcHJvZ3Jlc3MgKHRvIGJlIGNvbW1pdHRlZCBpbiBjb21wbGV0ZU5hdmlnYXRpb24pXG4gIGxldCBwZW5kaW5nQWN0aW9uOiBIaXN0b3J5QWN0aW9uID0gSGlzdG9yeUFjdGlvbi5Qb3A7XG5cbiAgLy8gU2hvdWxkIHRoZSBjdXJyZW50IG5hdmlnYXRpb24gcHJldmVudCB0aGUgc2Nyb2xsIHJlc2V0IGlmIHNjcm9sbCBjYW5ub3RcbiAgLy8gYmUgcmVzdG9yZWQ/XG4gIGxldCBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID0gZmFsc2U7XG5cbiAgLy8gQWJvcnRDb250cm9sbGVyIGZvciB0aGUgYWN0aXZlIG5hdmlnYXRpb25cbiAgbGV0IHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyIHwgbnVsbDtcblxuICAvLyBTaG91bGQgdGhlIGN1cnJlbnQgbmF2aWdhdGlvbiBlbmFibGUgZG9jdW1lbnQuc3RhcnRWaWV3VHJhbnNpdGlvbj9cbiAgbGV0IHBlbmRpbmdWaWV3VHJhbnNpdGlvbkVuYWJsZWQgPSBmYWxzZTtcblxuICAvLyBTdG9yZSBhcHBsaWVkIHZpZXcgdHJhbnNpdGlvbnMgc28gd2UgY2FuIGFwcGx5IHRoZW0gb24gUE9QXG4gIGxldCBhcHBsaWVkVmlld1RyYW5zaXRpb25zOiBNYXA8c3RyaW5nLCBTZXQ8c3RyaW5nPj4gPSBuZXcgTWFwPFxuICAgIHN0cmluZyxcbiAgICBTZXQ8c3RyaW5nPlxuICA+KCk7XG5cbiAgLy8gQ2xlYW51cCBmdW5jdGlvbiBmb3IgcGVyc2lzdGluZyBhcHBsaWVkIHRyYW5zaXRpb25zIHRvIHNlc3Npb25TdG9yYWdlXG4gIGxldCByZW1vdmVQYWdlSGlkZUV2ZW50TGlzdGVuZXI6ICgoKSA9PiB2b2lkKSB8IG51bGwgPSBudWxsO1xuXG4gIC8vIFdlIHVzZSB0aGlzIHRvIGF2b2lkIHRvdWNoaW5nIGhpc3RvcnkgaW4gY29tcGxldGVOYXZpZ2F0aW9uIGlmIGFcbiAgLy8gcmV2YWxpZGF0aW9uIGlzIGVudGlyZWx5IHVuaW50ZXJydXB0ZWRcbiAgbGV0IGlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiA9IGZhbHNlO1xuXG4gIC8vIFVzZSB0aGlzIGludGVybmFsIGZsYWcgdG8gZm9yY2UgcmV2YWxpZGF0aW9uIG9mIGFsbCBsb2FkZXJzOlxuICAvLyAgLSBzdWJtaXNzaW9ucyAoY29tcGxldGVkIG9yIGludGVycnVwdGVkKVxuICAvLyAgLSB1c2VSZXZhbGlkYXRvcigpXG4gIC8vICAtIFgtUmVtaXgtUmV2YWxpZGF0ZSAoZnJvbSByZWRpcmVjdClcbiAgbGV0IGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgPSBmYWxzZTtcblxuICAvLyBVc2UgdGhpcyBpbnRlcm5hbCBhcnJheSB0byBjYXB0dXJlIHJvdXRlcyB0aGF0IHJlcXVpcmUgcmV2YWxpZGF0aW9uIGR1ZVxuICAvLyB0byBhIGNhbmNlbGxlZCBkZWZlcnJlZCBvbiBhY3Rpb24gc3VibWlzc2lvblxuICBsZXQgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXM6IHN0cmluZ1tdID0gW107XG5cbiAgLy8gVXNlIHRoaXMgaW50ZXJuYWwgYXJyYXkgdG8gY2FwdHVyZSBmZXRjaGVyIGxvYWRzIHRoYXQgd2VyZSBjYW5jZWxsZWQgYnkgYW5cbiAgLy8gYWN0aW9uIG5hdmlnYXRpb24gYW5kIHJlcXVpcmUgcmV2YWxpZGF0aW9uXG4gIGxldCBjYW5jZWxsZWRGZXRjaGVyTG9hZHM6IHN0cmluZ1tdID0gW107XG5cbiAgLy8gQWJvcnRDb250cm9sbGVycyBmb3IgYW55IGluLWZsaWdodCBmZXRjaGVyc1xuICBsZXQgZmV0Y2hDb250cm9sbGVycyA9IG5ldyBNYXA8c3RyaW5nLCBBYm9ydENvbnRyb2xsZXI+KCk7XG5cbiAgLy8gVHJhY2sgbG9hZHMgYmFzZWQgb24gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgc3RhcnRlZFxuICBsZXQgaW5jcmVtZW50aW5nTG9hZElkID0gMDtcblxuICAvLyBUcmFjayB0aGUgb3V0c3RhbmRpbmcgcGVuZGluZyBuYXZpZ2F0aW9uIGRhdGEgbG9hZCB0byBiZSBjb21wYXJlZCBhZ2FpbnN0XG4gIC8vIHRoZSBnbG9iYWxseSBpbmNyZW1lbnRpbmcgbG9hZCB3aGVuIGEgZmV0Y2hlciBsb2FkIGxhbmRzIGFmdGVyIGEgY29tcGxldGVkXG4gIC8vIG5hdmlnYXRpb25cbiAgbGV0IHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkID0gLTE7XG5cbiAgLy8gRmV0Y2hlcnMgdGhhdCB0cmlnZ2VyZWQgZGF0YSByZWxvYWRzIGFzIGEgcmVzdWx0IG9mIHRoZWlyIGFjdGlvbnNcbiAgbGV0IGZldGNoUmVsb2FkSWRzID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcblxuICAvLyBGZXRjaGVycyB0aGF0IHRyaWdnZXJlZCByZWRpcmVjdCBuYXZpZ2F0aW9uc1xuICBsZXQgZmV0Y2hSZWRpcmVjdElkcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gIC8vIE1vc3QgcmVjZW50IGhyZWYvbWF0Y2ggZm9yIGZldGNoZXIubG9hZCBjYWxscyBmb3IgZmV0Y2hlcnNcbiAgbGV0IGZldGNoTG9hZE1hdGNoZXMgPSBuZXcgTWFwPHN0cmluZywgRmV0Y2hMb2FkTWF0Y2g+KCk7XG5cbiAgLy8gUmVmLWNvdW50IG1vdW50ZWQgZmV0Y2hlcnMgc28gd2Uga25vdyB3aGVuIGl0J3Mgb2sgdG8gY2xlYW4gdGhlbSB1cFxuICBsZXQgYWN0aXZlRmV0Y2hlcnMgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xuXG4gIC8vIEZldGNoZXJzIHRoYXQgaGF2ZSByZXF1ZXN0ZWQgYSBkZWxldGUgd2hlbiB1c2luZyB2N19mZXRjaGVyUGVyc2lzdCxcbiAgLy8gdGhleSdsbCBiZSBvZmZpY2lhbGx5IHJlbW92ZWQgYWZ0ZXIgdGhleSByZXR1cm4gdG8gaWRsZVxuICBsZXQgZGVsZXRlZEZldGNoZXJzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbiAgLy8gU3RvcmUgRGVmZXJyZWREYXRhIGluc3RhbmNlcyBmb3IgYWN0aXZlIHJvdXRlIG1hdGNoZXMuICBXaGVuIGFcbiAgLy8gcm91dGUgbG9hZGVyIHJldHVybnMgZGVmZXIoKSB3ZSBzdGljayBvbmUgaW4gaGVyZS4gIFRoZW4sIHdoZW4gYSBuZXN0ZWRcbiAgLy8gcHJvbWlzZSByZXNvbHZlcyB3ZSB1cGRhdGUgbG9hZGVyRGF0YS4gIElmIGEgbmV3IG5hdmlnYXRpb24gc3RhcnRzIHdlXG4gIC8vIGNhbmNlbCBhY3RpdmUgZGVmZXJyZWRzIGZvciBlbGltaW5hdGVkIHJvdXRlcy5cbiAgbGV0IGFjdGl2ZURlZmVycmVkcyA9IG5ldyBNYXA8c3RyaW5nLCBEZWZlcnJlZERhdGE+KCk7XG5cbiAgLy8gU3RvcmUgYmxvY2tlciBmdW5jdGlvbnMgaW4gYSBzZXBhcmF0ZSBNYXAgb3V0c2lkZSBvZiByb3V0ZXIgc3RhdGUgc2luY2VcbiAgLy8gd2UgZG9uJ3QgbmVlZCB0byB1cGRhdGUgVUkgc3RhdGUgaWYgdGhleSBjaGFuZ2VcbiAgbGV0IGJsb2NrZXJGdW5jdGlvbnMgPSBuZXcgTWFwPHN0cmluZywgQmxvY2tlckZ1bmN0aW9uPigpO1xuXG4gIC8vIEZsYWcgdG8gaWdub3JlIHRoZSBuZXh0IGhpc3RvcnkgdXBkYXRlLCBzbyB3ZSBjYW4gcmV2ZXJ0IHRoZSBVUkwgY2hhbmdlIG9uXG4gIC8vIGEgUE9QIG5hdmlnYXRpb24gdGhhdCB3YXMgYmxvY2tlZCBieSB0aGUgdXNlciB3aXRob3V0IHRvdWNoaW5nIHJvdXRlciBzdGF0ZVxuICBsZXQgaWdub3JlTmV4dEhpc3RvcnlVcGRhdGUgPSBmYWxzZTtcblxuICAvLyBJbml0aWFsaXplIHRoZSByb3V0ZXIsIGFsbCBzaWRlIGVmZmVjdHMgc2hvdWxkIGJlIGtpY2tlZCBvZmYgZnJvbSBoZXJlLlxuICAvLyBJbXBsZW1lbnRlZCBhcyBhIEZsdWVudCBBUEkgZm9yIGVhc2Ugb2Y6XG4gIC8vICAgbGV0IHJvdXRlciA9IGNyZWF0ZVJvdXRlcihpbml0KS5pbml0aWFsaXplKCk7XG4gIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgLy8gSWYgaGlzdG9yeSBpbmZvcm1zIHVzIG9mIGEgUE9QIG5hdmlnYXRpb24sIHN0YXJ0IHRoZSBuYXZpZ2F0aW9uIGJ1dCBkbyBub3QgdXBkYXRlXG4gICAgLy8gc3RhdGUuICBXZSdsbCB1cGRhdGUgb3VyIG93biBzdGF0ZSBvbmNlIHRoZSBuYXZpZ2F0aW9uIGNvbXBsZXRlc1xuICAgIHVubGlzdGVuSGlzdG9yeSA9IGluaXQuaGlzdG9yeS5saXN0ZW4oXG4gICAgICAoeyBhY3Rpb246IGhpc3RvcnlBY3Rpb24sIGxvY2F0aW9uLCBkZWx0YSB9KSA9PiB7XG4gICAgICAgIC8vIElnbm9yZSB0aGlzIGV2ZW50IGlmIGl0IHdhcyBqdXN0IHVzIHJlc2V0dGluZyB0aGUgVVJMIGZyb20gYVxuICAgICAgICAvLyBibG9ja2VkIFBPUCBuYXZpZ2F0aW9uXG4gICAgICAgIGlmIChpZ25vcmVOZXh0SGlzdG9yeVVwZGF0ZSkge1xuICAgICAgICAgIGlnbm9yZU5leHRIaXN0b3J5VXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICBibG9ja2VyRnVuY3Rpb25zLnNpemUgPT09IDAgfHwgZGVsdGEgIT0gbnVsbCxcbiAgICAgICAgICBcIllvdSBhcmUgdHJ5aW5nIHRvIHVzZSBhIGJsb2NrZXIgb24gYSBQT1AgbmF2aWdhdGlvbiB0byBhIGxvY2F0aW9uIFwiICtcbiAgICAgICAgICAgIFwidGhhdCB3YXMgbm90IGNyZWF0ZWQgYnkgQHJlbWl4LXJ1bi9yb3V0ZXIuIFRoaXMgd2lsbCBmYWlsIHNpbGVudGx5IGluIFwiICtcbiAgICAgICAgICAgIFwicHJvZHVjdGlvbi4gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBhcmUgbmF2aWdhdGluZyBvdXRzaWRlIHRoZSByb3V0ZXIgXCIgK1xuICAgICAgICAgICAgXCJ2aWEgYHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZWAvYHdpbmRvdy5sb2NhdGlvbi5oYXNoYCBpbnN0ZWFkIG9mIHVzaW5nIFwiICtcbiAgICAgICAgICAgIFwicm91dGVyIG5hdmlnYXRpb24gQVBJcy4gIFRoaXMgY2FuIGFsc28gaGFwcGVuIGlmIHlvdSBhcmUgdXNpbmcgXCIgK1xuICAgICAgICAgICAgXCJjcmVhdGVIYXNoUm91dGVyIGFuZCB0aGUgdXNlciBtYW51YWxseSBjaGFuZ2VzIHRoZSBVUkwuXCJcbiAgICAgICAgKTtcblxuICAgICAgICBsZXQgYmxvY2tlcktleSA9IHNob3VsZEJsb2NrTmF2aWdhdGlvbih7XG4gICAgICAgICAgY3VycmVudExvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgICAgICBuZXh0TG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICAgIGhpc3RvcnlBY3Rpb24sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChibG9ja2VyS2V5ICYmIGRlbHRhICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBVUkwgdG8gbWF0Y2ggdGhlIGN1cnJlbnQgVUksIGJ1dCBkb24ndCB1cGRhdGUgcm91dGVyIHN0YXRlXG4gICAgICAgICAgaWdub3JlTmV4dEhpc3RvcnlVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgIGluaXQuaGlzdG9yeS5nbyhkZWx0YSAqIC0xKTtcblxuICAgICAgICAgIC8vIFB1dCB0aGUgYmxvY2tlciBpbnRvIGEgYmxvY2tlZCBzdGF0ZVxuICAgICAgICAgIHVwZGF0ZUJsb2NrZXIoYmxvY2tlcktleSwge1xuICAgICAgICAgICAgc3RhdGU6IFwiYmxvY2tlZFwiLFxuICAgICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgICBwcm9jZWVkKCkge1xuICAgICAgICAgICAgICB1cGRhdGVCbG9ja2VyKGJsb2NrZXJLZXkhLCB7XG4gICAgICAgICAgICAgICAgc3RhdGU6IFwicHJvY2VlZGluZ1wiLFxuICAgICAgICAgICAgICAgIHByb2NlZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICByZXNldDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgLy8gUmUtZG8gdGhlIHNhbWUgUE9QIG5hdmlnYXRpb24gd2UganVzdCBibG9ja2VkXG4gICAgICAgICAgICAgIGluaXQuaGlzdG9yeS5nbyhkZWx0YSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgICAgIGxldCBibG9ja2VycyA9IG5ldyBNYXAoc3RhdGUuYmxvY2tlcnMpO1xuICAgICAgICAgICAgICBibG9ja2Vycy5zZXQoYmxvY2tlcktleSEsIElETEVfQkxPQ0tFUik7XG4gICAgICAgICAgICAgIHVwZGF0ZVN0YXRlKHsgYmxvY2tlcnMgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdGFydE5hdmlnYXRpb24oaGlzdG9yeUFjdGlvbiwgbG9jYXRpb24pO1xuICAgICAgfVxuICAgICk7XG5cbiAgICBpZiAoaXNCcm93c2VyKSB7XG4gICAgICAvLyBGSVhNRTogVGhpcyBmZWVscyBncm9zcy4gIEhvdyBjYW4gd2UgY2xlYW51cCB0aGUgbGluZXMgYmV0d2VlblxuICAgICAgLy8gc2Nyb2xsUmVzdG9yYXRpb24vYXBwbGllZFRyYW5zaXRpb25zIHBlcnNpc3RhbmNlP1xuICAgICAgcmVzdG9yZUFwcGxpZWRUcmFuc2l0aW9ucyhyb3V0ZXJXaW5kb3csIGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMpO1xuICAgICAgbGV0IF9zYXZlQXBwbGllZFRyYW5zaXRpb25zID0gKCkgPT5cbiAgICAgICAgcGVyc2lzdEFwcGxpZWRUcmFuc2l0aW9ucyhyb3V0ZXJXaW5kb3csIGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMpO1xuICAgICAgcm91dGVyV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBfc2F2ZUFwcGxpZWRUcmFuc2l0aW9ucyk7XG4gICAgICByZW1vdmVQYWdlSGlkZUV2ZW50TGlzdGVuZXIgPSAoKSA9PlxuICAgICAgICByb3V0ZXJXaW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIF9zYXZlQXBwbGllZFRyYW5zaXRpb25zKTtcbiAgICB9XG5cbiAgICAvLyBLaWNrIG9mZiBpbml0aWFsIGRhdGEgbG9hZCBpZiBuZWVkZWQuICBVc2UgUG9wIHRvIGF2b2lkIG1vZGlmeWluZyBoaXN0b3J5XG4gICAgLy8gTm90ZSB3ZSBkb24ndCBkbyBhbnkgaGFuZGxpbmcgb2YgbGF6eSBoZXJlLiAgRm9yIFNQQSdzIGl0J2xsIGdldCBoYW5kbGVkXG4gICAgLy8gaW4gdGhlIG5vcm1hbCBuYXZpZ2F0aW9uIGZsb3cuICBGb3IgU1NSIGl0J3MgZXhwZWN0ZWQgdGhhdCBsYXp5IG1vZHVsZXMgYXJlXG4gICAgLy8gcmVzb2x2ZWQgcHJpb3IgdG8gcm91dGVyIGNyZWF0aW9uIHNpbmNlIHdlIGNhbid0IGdvIGludG8gYSBmYWxsYmFja0VsZW1lbnRcbiAgICAvLyBVSSBmb3IgU1NSJ2QgYXBwc1xuICAgIGlmICghc3RhdGUuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHN0YXJ0TmF2aWdhdGlvbihIaXN0b3J5QWN0aW9uLlBvcCwgc3RhdGUubG9jYXRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiByb3V0ZXI7XG4gIH1cblxuICAvLyBDbGVhbiB1cCBhIHJvdXRlciBhbmQgaXQncyBzaWRlIGVmZmVjdHNcbiAgZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICBpZiAodW5saXN0ZW5IaXN0b3J5KSB7XG4gICAgICB1bmxpc3Rlbkhpc3RvcnkoKTtcbiAgICB9XG4gICAgaWYgKHJlbW92ZVBhZ2VIaWRlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgcmVtb3ZlUGFnZUhpZGVFdmVudExpc3RlbmVyKCk7XG4gICAgfVxuICAgIHN1YnNjcmliZXJzLmNsZWFyKCk7XG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyICYmIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5hYm9ydCgpO1xuICAgIHN0YXRlLmZldGNoZXJzLmZvckVhY2goKF8sIGtleSkgPT4gZGVsZXRlRmV0Y2hlcihrZXkpKTtcbiAgICBzdGF0ZS5ibG9ja2Vycy5mb3JFYWNoKChfLCBrZXkpID0+IGRlbGV0ZUJsb2NrZXIoa2V5KSk7XG4gIH1cblxuICAvLyBTdWJzY3JpYmUgdG8gc3RhdGUgdXBkYXRlcyBmb3IgdGhlIHJvdXRlclxuICBmdW5jdGlvbiBzdWJzY3JpYmUoZm46IFJvdXRlclN1YnNjcmliZXIpIHtcbiAgICBzdWJzY3JpYmVycy5hZGQoZm4pO1xuICAgIHJldHVybiAoKSA9PiBzdWJzY3JpYmVycy5kZWxldGUoZm4pO1xuICB9XG5cbiAgLy8gVXBkYXRlIG91ciBzdGF0ZSBhbmQgbm90aWZ5IHRoZSBjYWxsaW5nIGNvbnRleHQgb2YgdGhlIGNoYW5nZVxuICBmdW5jdGlvbiB1cGRhdGVTdGF0ZShcbiAgICBuZXdTdGF0ZTogUGFydGlhbDxSb3V0ZXJTdGF0ZT4sXG4gICAgb3B0czoge1xuICAgICAgZmx1c2hTeW5jPzogYm9vbGVhbjtcbiAgICAgIHZpZXdUcmFuc2l0aW9uT3B0cz86IFZpZXdUcmFuc2l0aW9uT3B0cztcbiAgICB9ID0ge31cbiAgKTogdm9pZCB7XG4gICAgc3RhdGUgPSB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIC4uLm5ld1N0YXRlLFxuICAgIH07XG5cbiAgICAvLyBQcmVwIGZldGNoZXIgY2xlYW51cCBzbyB3ZSBjYW4gdGVsbCB0aGUgVUkgd2hpY2ggZmV0Y2hlciBkYXRhIGVudHJpZXNcbiAgICAvLyBjYW4gYmUgcmVtb3ZlZFxuICAgIGxldCBjb21wbGV0ZWRGZXRjaGVyczogc3RyaW5nW10gPSBbXTtcbiAgICBsZXQgZGVsZXRlZEZldGNoZXJzS2V5czogc3RyaW5nW10gPSBbXTtcblxuICAgIGlmIChmdXR1cmUudjdfZmV0Y2hlclBlcnNpc3QpIHtcbiAgICAgIHN0YXRlLmZldGNoZXJzLmZvckVhY2goKGZldGNoZXIsIGtleSkgPT4ge1xuICAgICAgICBpZiAoZmV0Y2hlci5zdGF0ZSA9PT0gXCJpZGxlXCIpIHtcbiAgICAgICAgICBpZiAoZGVsZXRlZEZldGNoZXJzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAvLyBVbm1vdW50ZWQgZnJvbSB0aGUgVUkgYW5kIGNhbiBiZSB0b3RhbGx5IHJlbW92ZWRcbiAgICAgICAgICAgIGRlbGV0ZWRGZXRjaGVyc0tleXMucHVzaChrZXkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBSZXR1cm5lZCB0byBpZGxlIGJ1dCBzdGlsbCBtb3VudGVkIGluIHRoZSBVSSwgc28gc2VtaS1yZW1haW5zIGZvclxuICAgICAgICAgICAgLy8gcmV2YWxpZGF0aW9ucyBhbmQgc3VjaFxuICAgICAgICAgICAgY29tcGxldGVkRmV0Y2hlcnMucHVzaChrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIGEgbG9jYWwgY29weSBzbyB0aGF0IGlmIGZsdXNoU3luYyBpcyB1c2VkIGFuZCB3ZSBlbmQgdXBcbiAgICAvLyByZW1vdmluZyBhbmQgYWRkaW5nIGEgbmV3IHN1YnNjcmliZXIgZHVlIHRvIHRoZSB1c2VDYWxsYmFjayBkZXBlbmRlbmNpZXMsXG4gICAgLy8gd2UgZG9uJ3QgZ2V0IG91cnNlbHZlcyBpbnRvIGEgbG9vcCBjYWxsaW5nIHRoZSBuZXcgc3Vic2NyaWJlciBpbW1lZGlhdGVseVxuICAgIFsuLi5zdWJzY3JpYmVyc10uZm9yRWFjaCgoc3Vic2NyaWJlcikgPT5cbiAgICAgIHN1YnNjcmliZXIoc3RhdGUsIHtcbiAgICAgICAgZGVsZXRlZEZldGNoZXJzOiBkZWxldGVkRmV0Y2hlcnNLZXlzLFxuICAgICAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbk9wdHM6IG9wdHMudmlld1RyYW5zaXRpb25PcHRzLFxuICAgICAgICB1bnN0YWJsZV9mbHVzaFN5bmM6IG9wdHMuZmx1c2hTeW5jID09PSB0cnVlLFxuICAgICAgfSlcbiAgICApO1xuXG4gICAgLy8gUmVtb3ZlIGlkbGUgZmV0Y2hlcnMgZnJvbSBzdGF0ZSBzaW5jZSB3ZSBvbmx5IGNhcmUgYWJvdXQgaW4tZmxpZ2h0IGZldGNoZXJzLlxuICAgIGlmIChmdXR1cmUudjdfZmV0Y2hlclBlcnNpc3QpIHtcbiAgICAgIGNvbXBsZXRlZEZldGNoZXJzLmZvckVhY2goKGtleSkgPT4gc3RhdGUuZmV0Y2hlcnMuZGVsZXRlKGtleSkpO1xuICAgICAgZGVsZXRlZEZldGNoZXJzS2V5cy5mb3JFYWNoKChrZXkpID0+IGRlbGV0ZUZldGNoZXIoa2V5KSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ29tcGxldGUgYSBuYXZpZ2F0aW9uIHJldHVybmluZyB0aGUgc3RhdGUubmF2aWdhdGlvbiBiYWNrIHRvIHRoZSBJRExFX05BVklHQVRJT05cbiAgLy8gYW5kIHNldHRpbmcgc3RhdGUuW2hpc3RvcnlBY3Rpb24vbG9jYXRpb24vbWF0Y2hlc10gdG8gdGhlIG5ldyByb3V0ZS5cbiAgLy8gLSBMb2NhdGlvbiBpcyBhIHJlcXVpcmVkIHBhcmFtXG4gIC8vIC0gTmF2aWdhdGlvbiB3aWxsIGFsd2F5cyBiZSBzZXQgdG8gSURMRV9OQVZJR0FUSU9OXG4gIC8vIC0gQ2FuIHBhc3MgYW55IG90aGVyIHN0YXRlIGluIG5ld1N0YXRlXG4gIGZ1bmN0aW9uIGNvbXBsZXRlTmF2aWdhdGlvbihcbiAgICBsb2NhdGlvbjogTG9jYXRpb24sXG4gICAgbmV3U3RhdGU6IFBhcnRpYWw8T21pdDxSb3V0ZXJTdGF0ZSwgXCJhY3Rpb25cIiB8IFwibG9jYXRpb25cIiB8IFwibmF2aWdhdGlvblwiPj4sXG4gICAgeyBmbHVzaFN5bmMgfTogeyBmbHVzaFN5bmM/OiBib29sZWFuIH0gPSB7fVxuICApOiB2b2lkIHtcbiAgICAvLyBEZWR1Y2UgaWYgd2UncmUgaW4gYSBsb2FkaW5nL2FjdGlvblJlbG9hZCBzdGF0ZTpcbiAgICAvLyAtIFdlIGhhdmUgY29tbWl0dGVkIGFjdGlvbkRhdGEgaW4gdGhlIHN0b3JlXG4gICAgLy8gLSBUaGUgY3VycmVudCBuYXZpZ2F0aW9uIHdhcyBhIG11dGF0aW9uIHN1Ym1pc3Npb25cbiAgICAvLyAtIFdlJ3JlIHBhc3QgdGhlIHN1Ym1pdHRpbmcgc3RhdGUgYW5kIGludG8gdGhlIGxvYWRpbmcgc3RhdGVcbiAgICAvLyAtIFRoZSBsb2NhdGlvbiBiZWluZyBsb2FkZWQgaXMgbm90IHRoZSByZXN1bHQgb2YgYSByZWRpcmVjdFxuICAgIGxldCBpc0FjdGlvblJlbG9hZCA9XG4gICAgICBzdGF0ZS5hY3Rpb25EYXRhICE9IG51bGwgJiZcbiAgICAgIHN0YXRlLm5hdmlnYXRpb24uZm9ybU1ldGhvZCAhPSBudWxsICYmXG4gICAgICBpc011dGF0aW9uTWV0aG9kKHN0YXRlLm5hdmlnYXRpb24uZm9ybU1ldGhvZCkgJiZcbiAgICAgIHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgPT09IFwibG9hZGluZ1wiICYmXG4gICAgICBsb2NhdGlvbi5zdGF0ZT8uX2lzUmVkaXJlY3QgIT09IHRydWU7XG5cbiAgICBsZXQgYWN0aW9uRGF0YTogUm91dGVEYXRhIHwgbnVsbDtcbiAgICBpZiAobmV3U3RhdGUuYWN0aW9uRGF0YSkge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKG5ld1N0YXRlLmFjdGlvbkRhdGEpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYWN0aW9uRGF0YSA9IG5ld1N0YXRlLmFjdGlvbkRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFbXB0eSBhY3Rpb25EYXRhIC0+IGNsZWFyIHByaW9yIGFjdGlvbkRhdGEgZHVlIHRvIGFuIGFjdGlvbiBlcnJvclxuICAgICAgICBhY3Rpb25EYXRhID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzQWN0aW9uUmVsb2FkKSB7XG4gICAgICAvLyBLZWVwIHRoZSBjdXJyZW50IGRhdGEgaWYgd2UncmUgd3JhcHBpbmcgdXAgdGhlIGFjdGlvbiByZWxvYWRcbiAgICAgIGFjdGlvbkRhdGEgPSBzdGF0ZS5hY3Rpb25EYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDbGVhciBhY3Rpb25EYXRhIG9uIGFueSBvdGhlciBjb21wbGV0ZWQgbmF2aWdhdGlvbnNcbiAgICAgIGFjdGlvbkRhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIEFsd2F5cyBwcmVzZXJ2ZSBhbnkgZXhpc3RpbmcgbG9hZGVyRGF0YSBmcm9tIHJlLXVzZWQgcm91dGVzXG4gICAgbGV0IGxvYWRlckRhdGEgPSBuZXdTdGF0ZS5sb2FkZXJEYXRhXG4gICAgICA/IG1lcmdlTG9hZGVyRGF0YShcbiAgICAgICAgICBzdGF0ZS5sb2FkZXJEYXRhLFxuICAgICAgICAgIG5ld1N0YXRlLmxvYWRlckRhdGEsXG4gICAgICAgICAgbmV3U3RhdGUubWF0Y2hlcyB8fCBbXSxcbiAgICAgICAgICBuZXdTdGF0ZS5lcnJvcnNcbiAgICAgICAgKVxuICAgICAgOiBzdGF0ZS5sb2FkZXJEYXRhO1xuXG4gICAgLy8gT24gYSBzdWNjZXNzZnVsIG5hdmlnYXRpb24gd2UgY2FuIGFzc3VtZSB3ZSBnb3QgdGhyb3VnaCBhbGwgYmxvY2tlcnNcbiAgICAvLyBzbyB3ZSBjYW4gc3RhcnQgZnJlc2hcbiAgICBsZXQgYmxvY2tlcnMgPSBzdGF0ZS5ibG9ja2VycztcbiAgICBpZiAoYmxvY2tlcnMuc2l6ZSA+IDApIHtcbiAgICAgIGJsb2NrZXJzID0gbmV3IE1hcChibG9ja2Vycyk7XG4gICAgICBibG9ja2Vycy5mb3JFYWNoKChfLCBrKSA9PiBibG9ja2Vycy5zZXQoaywgSURMRV9CTE9DS0VSKSk7XG4gICAgfVxuXG4gICAgLy8gQWx3YXlzIHJlc3BlY3QgdGhlIHVzZXIgZmxhZy4gIE90aGVyd2lzZSBkb24ndCByZXNldCBvbiBtdXRhdGlvblxuICAgIC8vIHN1Ym1pc3Npb24gbmF2aWdhdGlvbnMgdW5sZXNzIHRoZXkgcmVkaXJlY3RcbiAgICBsZXQgcHJldmVudFNjcm9sbFJlc2V0ID1cbiAgICAgIHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQgPT09IHRydWUgfHxcbiAgICAgIChzdGF0ZS5uYXZpZ2F0aW9uLmZvcm1NZXRob2QgIT0gbnVsbCAmJlxuICAgICAgICBpc011dGF0aW9uTWV0aG9kKHN0YXRlLm5hdmlnYXRpb24uZm9ybU1ldGhvZCkgJiZcbiAgICAgICAgbG9jYXRpb24uc3RhdGU/Ll9pc1JlZGlyZWN0ICE9PSB0cnVlKTtcblxuICAgIGlmIChpbkZsaWdodERhdGFSb3V0ZXMpIHtcbiAgICAgIGRhdGFSb3V0ZXMgPSBpbkZsaWdodERhdGFSb3V0ZXM7XG4gICAgICBpbkZsaWdodERhdGFSb3V0ZXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKGlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbikge1xuICAgICAgLy8gSWYgdGhpcyB3YXMgYW4gdW5pbnRlcnJ1cHRlZCByZXZhbGlkYXRpb24gdGhlbiBkbyBub3QgdG91Y2ggaGlzdG9yeVxuICAgIH0gZWxzZSBpZiAocGVuZGluZ0FjdGlvbiA9PT0gSGlzdG9yeUFjdGlvbi5Qb3ApIHtcbiAgICAgIC8vIERvIG5vdGhpbmcgZm9yIFBPUCAtIFVSTCBoYXMgYWxyZWFkeSBiZWVuIHVwZGF0ZWRcbiAgICB9IGVsc2UgaWYgKHBlbmRpbmdBY3Rpb24gPT09IEhpc3RvcnlBY3Rpb24uUHVzaCkge1xuICAgICAgaW5pdC5oaXN0b3J5LnB1c2gobG9jYXRpb24sIGxvY2F0aW9uLnN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKHBlbmRpbmdBY3Rpb24gPT09IEhpc3RvcnlBY3Rpb24uUmVwbGFjZSkge1xuICAgICAgaW5pdC5oaXN0b3J5LnJlcGxhY2UobG9jYXRpb24sIGxvY2F0aW9uLnN0YXRlKTtcbiAgICB9XG5cbiAgICBsZXQgdmlld1RyYW5zaXRpb25PcHRzOiBWaWV3VHJhbnNpdGlvbk9wdHMgfCB1bmRlZmluZWQ7XG5cbiAgICAvLyBPbiBQT1AsIGVuYWJsZSB0cmFuc2l0aW9ucyBpZiB0aGV5IHdlcmUgZW5hYmxlZCBvbiB0aGUgb3JpZ2luYWwgbmF2aWdhdGlvblxuICAgIGlmIChwZW5kaW5nQWN0aW9uID09PSBIaXN0b3J5QWN0aW9uLlBvcCkge1xuICAgICAgLy8gRm9yd2FyZCB0YWtlcyBwcmVjZWRlbmNlIHNvIHRoZXkgYmVoYXZlIGxpa2UgdGhlIG9yaWdpbmFsIG5hdmlnYXRpb25cbiAgICAgIGxldCBwcmlvclBhdGhzID0gYXBwbGllZFZpZXdUcmFuc2l0aW9ucy5nZXQoc3RhdGUubG9jYXRpb24ucGF0aG5hbWUpO1xuICAgICAgaWYgKHByaW9yUGF0aHMgJiYgcHJpb3JQYXRocy5oYXMobG9jYXRpb24ucGF0aG5hbWUpKSB7XG4gICAgICAgIHZpZXdUcmFuc2l0aW9uT3B0cyA9IHtcbiAgICAgICAgICBjdXJyZW50TG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgICAgICAgIG5leHRMb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMuaGFzKGxvY2F0aW9uLnBhdGhuYW1lKSkge1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgcHJldmlvdXMgZm9yd2FyZCBuYXYsIGFzc3VtZSB3ZSdyZSBwb3BwaW5nIGJhY2sgdG9cbiAgICAgICAgLy8gdGhlIG5ldyBsb2NhdGlvbiBhbmQgZW5hYmxlIGlmIHRoYXQgbG9jYXRpb24gcHJldmlvdXNseSBlbmFibGVkXG4gICAgICAgIHZpZXdUcmFuc2l0aW9uT3B0cyA9IHtcbiAgICAgICAgICBjdXJyZW50TG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICAgIG5leHRMb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwZW5kaW5nVmlld1RyYW5zaXRpb25FbmFibGVkKSB7XG4gICAgICAvLyBTdG9yZSB0aGUgYXBwbGllZCB0cmFuc2l0aW9uIG9uIFBVU0gvUkVQTEFDRVxuICAgICAgbGV0IHRvUGF0aHMgPSBhcHBsaWVkVmlld1RyYW5zaXRpb25zLmdldChzdGF0ZS5sb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgICBpZiAodG9QYXRocykge1xuICAgICAgICB0b1BhdGhzLmFkZChsb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b1BhdGhzID0gbmV3IFNldDxzdHJpbmc+KFtsb2NhdGlvbi5wYXRobmFtZV0pO1xuICAgICAgICBhcHBsaWVkVmlld1RyYW5zaXRpb25zLnNldChzdGF0ZS5sb2NhdGlvbi5wYXRobmFtZSwgdG9QYXRocyk7XG4gICAgICB9XG4gICAgICB2aWV3VHJhbnNpdGlvbk9wdHMgPSB7XG4gICAgICAgIGN1cnJlbnRMb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICAgIG5leHRMb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICB9O1xuICAgIH1cblxuICAgIHVwZGF0ZVN0YXRlKFxuICAgICAge1xuICAgICAgICAuLi5uZXdTdGF0ZSwgLy8gbWF0Y2hlcywgZXJyb3JzLCBmZXRjaGVycyBnbyB0aHJvdWdoIGFzLWlzXG4gICAgICAgIGFjdGlvbkRhdGEsXG4gICAgICAgIGxvYWRlckRhdGEsXG4gICAgICAgIGhpc3RvcnlBY3Rpb246IHBlbmRpbmdBY3Rpb24sXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBpbml0aWFsaXplZDogdHJ1ZSxcbiAgICAgICAgbmF2aWdhdGlvbjogSURMRV9OQVZJR0FUSU9OLFxuICAgICAgICByZXZhbGlkYXRpb246IFwiaWRsZVwiLFxuICAgICAgICByZXN0b3JlU2Nyb2xsUG9zaXRpb246IGdldFNhdmVkU2Nyb2xsUG9zaXRpb24oXG4gICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgbmV3U3RhdGUubWF0Y2hlcyB8fCBzdGF0ZS5tYXRjaGVzXG4gICAgICAgICksXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgICAgYmxvY2tlcnMsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB2aWV3VHJhbnNpdGlvbk9wdHMsXG4gICAgICAgIGZsdXNoU3luYzogZmx1c2hTeW5jID09PSB0cnVlLFxuICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBSZXNldCBzdGF0ZWZ1bCBuYXZpZ2F0aW9uIHZhcnNcbiAgICBwZW5kaW5nQWN0aW9uID0gSGlzdG9yeUFjdGlvbi5Qb3A7XG4gICAgcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCA9IGZhbHNlO1xuICAgIHBlbmRpbmdWaWV3VHJhbnNpdGlvbkVuYWJsZWQgPSBmYWxzZTtcbiAgICBpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24gPSBmYWxzZTtcbiAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gZmFsc2U7XG4gICAgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXMgPSBbXTtcbiAgICBjYW5jZWxsZWRGZXRjaGVyTG9hZHMgPSBbXTtcbiAgfVxuXG4gIC8vIFRyaWdnZXIgYSBuYXZpZ2F0aW9uIGV2ZW50LCB3aGljaCBjYW4gZWl0aGVyIGJlIGEgbnVtZXJpY2FsIFBPUCBvciBhIFBVU0hcbiAgLy8gcmVwbGFjZSB3aXRoIGFuIG9wdGlvbmFsIHN1Ym1pc3Npb25cbiAgYXN5bmMgZnVuY3Rpb24gbmF2aWdhdGUoXG4gICAgdG86IG51bWJlciB8IFRvIHwgbnVsbCxcbiAgICBvcHRzPzogUm91dGVyTmF2aWdhdGVPcHRpb25zXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGluaXQuaGlzdG9yeS5nbyh0byk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IG5vcm1hbGl6ZWRQYXRoID0gbm9ybWFsaXplVG8oXG4gICAgICBzdGF0ZS5sb2NhdGlvbixcbiAgICAgIHN0YXRlLm1hdGNoZXMsXG4gICAgICBiYXNlbmFtZSxcbiAgICAgIGZ1dHVyZS52N19wcmVwZW5kQmFzZW5hbWUsXG4gICAgICB0byxcbiAgICAgIG9wdHM/LmZyb21Sb3V0ZUlkLFxuICAgICAgb3B0cz8ucmVsYXRpdmVcbiAgICApO1xuICAgIGxldCB7IHBhdGgsIHN1Ym1pc3Npb24sIGVycm9yIH0gPSBub3JtYWxpemVOYXZpZ2F0ZU9wdGlvbnMoXG4gICAgICBmdXR1cmUudjdfbm9ybWFsaXplRm9ybU1ldGhvZCxcbiAgICAgIGZhbHNlLFxuICAgICAgbm9ybWFsaXplZFBhdGgsXG4gICAgICBvcHRzXG4gICAgKTtcblxuICAgIGxldCBjdXJyZW50TG9jYXRpb24gPSBzdGF0ZS5sb2NhdGlvbjtcbiAgICBsZXQgbmV4dExvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oc3RhdGUubG9jYXRpb24sIHBhdGgsIG9wdHMgJiYgb3B0cy5zdGF0ZSk7XG5cbiAgICAvLyBXaGVuIHVzaW5nIG5hdmlnYXRlIGFzIGEgUFVTSC9SRVBMQUNFIHdlIGFyZW4ndCByZWFkaW5nIGFuIGFscmVhZHktZW5jb2RlZFxuICAgIC8vIFVSTCBmcm9tIHdpbmRvdy5sb2NhdGlvbiwgc28gd2UgbmVlZCB0byBlbmNvZGUgaXQgaGVyZSBzbyB0aGUgYmVoYXZpb3JcbiAgICAvLyByZW1haW5zIHRoZSBzYW1lIGFzIFBPUCBhbmQgbm9uLWRhdGEtcm91dGVyIHVzYWdlcy4gIG5ldyBVUkwoKSBkb2VzIGFsbFxuICAgIC8vIHRoZSBzYW1lIGVuY29kaW5nIHdlJ2QgZ2V0IGZyb20gYSBoaXN0b3J5LnB1c2hTdGF0ZS93aW5kb3cubG9jYXRpb24gcmVhZFxuICAgIC8vIHdpdGhvdXQgaGF2aW5nIHRvIHRvdWNoIGhpc3RvcnlcbiAgICBuZXh0TG9jYXRpb24gPSB7XG4gICAgICAuLi5uZXh0TG9jYXRpb24sXG4gICAgICAuLi5pbml0Lmhpc3RvcnkuZW5jb2RlTG9jYXRpb24obmV4dExvY2F0aW9uKSxcbiAgICB9O1xuXG4gICAgbGV0IHVzZXJSZXBsYWNlID0gb3B0cyAmJiBvcHRzLnJlcGxhY2UgIT0gbnVsbCA/IG9wdHMucmVwbGFjZSA6IHVuZGVmaW5lZDtcblxuICAgIGxldCBoaXN0b3J5QWN0aW9uID0gSGlzdG9yeUFjdGlvbi5QdXNoO1xuXG4gICAgaWYgKHVzZXJSZXBsYWNlID09PSB0cnVlKSB7XG4gICAgICBoaXN0b3J5QWN0aW9uID0gSGlzdG9yeUFjdGlvbi5SZXBsYWNlO1xuICAgIH0gZWxzZSBpZiAodXNlclJlcGxhY2UgPT09IGZhbHNlKSB7XG4gICAgICAvLyBuby1vcFxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBzdWJtaXNzaW9uICE9IG51bGwgJiZcbiAgICAgIGlzTXV0YXRpb25NZXRob2Qoc3VibWlzc2lvbi5mb3JtTWV0aG9kKSAmJlxuICAgICAgc3VibWlzc2lvbi5mb3JtQWN0aW9uID09PSBzdGF0ZS5sb2NhdGlvbi5wYXRobmFtZSArIHN0YXRlLmxvY2F0aW9uLnNlYXJjaFxuICAgICkge1xuICAgICAgLy8gQnkgZGVmYXVsdCBvbiBzdWJtaXNzaW9ucyB0byB0aGUgY3VycmVudCBsb2NhdGlvbiB3ZSBSRVBMQUNFIHNvIHRoYXRcbiAgICAgIC8vIHVzZXJzIGRvbid0IGhhdmUgdG8gZG91YmxlLWNsaWNrIHRoZSBiYWNrIGJ1dHRvbiB0byBnZXQgdG8gdGhlIHByaW9yXG4gICAgICAvLyBsb2NhdGlvbi4gIElmIHRoZSB1c2VyIHJlZGlyZWN0cyB0byBhIGRpZmZlcmVudCBsb2NhdGlvbiBmcm9tIHRoZVxuICAgICAgLy8gYWN0aW9uL2xvYWRlciB0aGlzIHdpbGwgYmUgaWdub3JlZCBhbmQgdGhlIHJlZGlyZWN0IHdpbGwgYmUgYSBQVVNIXG4gICAgICBoaXN0b3J5QWN0aW9uID0gSGlzdG9yeUFjdGlvbi5SZXBsYWNlO1xuICAgIH1cblxuICAgIGxldCBwcmV2ZW50U2Nyb2xsUmVzZXQgPVxuICAgICAgb3B0cyAmJiBcInByZXZlbnRTY3JvbGxSZXNldFwiIGluIG9wdHNcbiAgICAgICAgPyBvcHRzLnByZXZlbnRTY3JvbGxSZXNldCA9PT0gdHJ1ZVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGxldCBmbHVzaFN5bmMgPSAob3B0cyAmJiBvcHRzLnVuc3RhYmxlX2ZsdXNoU3luYykgPT09IHRydWU7XG5cbiAgICBsZXQgYmxvY2tlcktleSA9IHNob3VsZEJsb2NrTmF2aWdhdGlvbih7XG4gICAgICBjdXJyZW50TG9jYXRpb24sXG4gICAgICBuZXh0TG9jYXRpb24sXG4gICAgICBoaXN0b3J5QWN0aW9uLFxuICAgIH0pO1xuXG4gICAgaWYgKGJsb2NrZXJLZXkpIHtcbiAgICAgIC8vIFB1dCB0aGUgYmxvY2tlciBpbnRvIGEgYmxvY2tlZCBzdGF0ZVxuICAgICAgdXBkYXRlQmxvY2tlcihibG9ja2VyS2V5LCB7XG4gICAgICAgIHN0YXRlOiBcImJsb2NrZWRcIixcbiAgICAgICAgbG9jYXRpb246IG5leHRMb2NhdGlvbixcbiAgICAgICAgcHJvY2VlZCgpIHtcbiAgICAgICAgICB1cGRhdGVCbG9ja2VyKGJsb2NrZXJLZXkhLCB7XG4gICAgICAgICAgICBzdGF0ZTogXCJwcm9jZWVkaW5nXCIsXG4gICAgICAgICAgICBwcm9jZWVkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICByZXNldDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbG9jYXRpb246IG5leHRMb2NhdGlvbixcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyBTZW5kIHRoZSBzYW1lIG5hdmlnYXRpb24gdGhyb3VnaFxuICAgICAgICAgIG5hdmlnYXRlKHRvLCBvcHRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgbGV0IGJsb2NrZXJzID0gbmV3IE1hcChzdGF0ZS5ibG9ja2Vycyk7XG4gICAgICAgICAgYmxvY2tlcnMuc2V0KGJsb2NrZXJLZXkhLCBJRExFX0JMT0NLRVIpO1xuICAgICAgICAgIHVwZGF0ZVN0YXRlKHsgYmxvY2tlcnMgfSk7XG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgc3RhcnROYXZpZ2F0aW9uKGhpc3RvcnlBY3Rpb24sIG5leHRMb2NhdGlvbiwge1xuICAgICAgc3VibWlzc2lvbixcbiAgICAgIC8vIFNlbmQgdGhyb3VnaCB0aGUgZm9ybURhdGEgc2VyaWFsaXphdGlvbiBlcnJvciBpZiB3ZSBoYXZlIG9uZSBzbyB3ZSBjYW5cbiAgICAgIC8vIHJlbmRlciBhdCB0aGUgcmlnaHQgZXJyb3IgYm91bmRhcnkgYWZ0ZXIgd2UgbWF0Y2ggcm91dGVzXG4gICAgICBwZW5kaW5nRXJyb3I6IGVycm9yLFxuICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgcmVwbGFjZTogb3B0cyAmJiBvcHRzLnJlcGxhY2UsXG4gICAgICBlbmFibGVWaWV3VHJhbnNpdGlvbjogb3B0cyAmJiBvcHRzLnVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uLFxuICAgICAgZmx1c2hTeW5jLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gUmV2YWxpZGF0ZSBhbGwgY3VycmVudCBsb2FkZXJzLiAgSWYgYSBuYXZpZ2F0aW9uIGlzIGluIHByb2dyZXNzIG9yIGlmIHRoaXNcbiAgLy8gaXMgaW50ZXJydXB0ZWQgYnkgYSBuYXZpZ2F0aW9uLCBhbGxvdyB0aGlzIHRvIFwic3VjY2VlZFwiIGJ5IGNhbGxpbmcgYWxsXG4gIC8vIGxvYWRlcnMgZHVyaW5nIHRoZSBuZXh0IGxvYWRlciByb3VuZFxuICBmdW5jdGlvbiByZXZhbGlkYXRlKCkge1xuICAgIGludGVycnVwdEFjdGl2ZUxvYWRzKCk7XG4gICAgdXBkYXRlU3RhdGUoeyByZXZhbGlkYXRpb246IFwibG9hZGluZ1wiIH0pO1xuXG4gICAgLy8gSWYgd2UncmUgY3VycmVudGx5IHN1Ym1pdHRpbmcgYW4gYWN0aW9uLCB3ZSBkb24ndCBuZWVkIHRvIHN0YXJ0IGEgbmV3XG4gICAgLy8gbmF2aWdhdGlvbiwgd2UnbGwganVzdCBsZXQgdGhlIGZvbGxvdyB1cCBsb2FkZXIgZXhlY3V0aW9uIGNhbGwgYWxsIGxvYWRlcnNcbiAgICBpZiAoc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJzdWJtaXR0aW5nXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSdyZSBjdXJyZW50bHkgaW4gYW4gaWRsZSBzdGF0ZSwgc3RhcnQgYSBuZXcgbmF2aWdhdGlvbiBmb3IgdGhlIGN1cnJlbnRcbiAgICAvLyBhY3Rpb24vbG9jYXRpb24gYW5kIG1hcmsgaXQgYXMgdW5pbnRlcnJ1cHRlZCwgd2hpY2ggd2lsbCBza2lwIHRoZSBoaXN0b3J5XG4gICAgLy8gdXBkYXRlIGluIGNvbXBsZXRlTmF2aWdhdGlvblxuICAgIGlmIChzdGF0ZS5uYXZpZ2F0aW9uLnN0YXRlID09PSBcImlkbGVcIikge1xuICAgICAgc3RhcnROYXZpZ2F0aW9uKHN0YXRlLmhpc3RvcnlBY3Rpb24sIHN0YXRlLmxvY2F0aW9uLCB7XG4gICAgICAgIHN0YXJ0VW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbjogdHJ1ZSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSwgaWYgd2UncmUgY3VycmVudGx5IGluIGEgbG9hZGluZyBzdGF0ZSwganVzdCBzdGFydCBhIG5ld1xuICAgIC8vIG5hdmlnYXRpb24gdG8gdGhlIG5hdmlnYXRpb24ubG9jYXRpb24gYnV0IGRvIG5vdCB0cmlnZ2VyIGFuIHVuaW50ZXJydXB0ZWRcbiAgICAvLyByZXZhbGlkYXRpb24gc28gdGhhdCBoaXN0b3J5IGNvcnJlY3RseSB1cGRhdGVzIG9uY2UgdGhlIG5hdmlnYXRpb24gY29tcGxldGVzXG4gICAgc3RhcnROYXZpZ2F0aW9uKFxuICAgICAgcGVuZGluZ0FjdGlvbiB8fCBzdGF0ZS5oaXN0b3J5QWN0aW9uLFxuICAgICAgc3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbixcbiAgICAgIHsgb3ZlcnJpZGVOYXZpZ2F0aW9uOiBzdGF0ZS5uYXZpZ2F0aW9uIH1cbiAgICApO1xuICB9XG5cbiAgLy8gU3RhcnQgYSBuYXZpZ2F0aW9uIHRvIHRoZSBnaXZlbiBhY3Rpb24vbG9jYXRpb24uICBDYW4gb3B0aW9uYWxseSBwcm92aWRlIGFcbiAgLy8gb3ZlcnJpZGVOYXZpZ2F0aW9uIHdoaWNoIHdpbGwgb3ZlcnJpZGUgdGhlIG5vcm1hbExvYWQgaW4gdGhlIGNhc2Ugb2YgYSByZWRpcmVjdFxuICAvLyBuYXZpZ2F0aW9uXG4gIGFzeW5jIGZ1bmN0aW9uIHN0YXJ0TmF2aWdhdGlvbihcbiAgICBoaXN0b3J5QWN0aW9uOiBIaXN0b3J5QWN0aW9uLFxuICAgIGxvY2F0aW9uOiBMb2NhdGlvbixcbiAgICBvcHRzPzoge1xuICAgICAgc3VibWlzc2lvbj86IFN1Ym1pc3Npb247XG4gICAgICBmZXRjaGVyU3VibWlzc2lvbj86IFN1Ym1pc3Npb247XG4gICAgICBvdmVycmlkZU5hdmlnYXRpb24/OiBOYXZpZ2F0aW9uO1xuICAgICAgcGVuZGluZ0Vycm9yPzogRXJyb3JSZXNwb25zZUltcGw7XG4gICAgICBzdGFydFVuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24/OiBib29sZWFuO1xuICAgICAgcHJldmVudFNjcm9sbFJlc2V0PzogYm9vbGVhbjtcbiAgICAgIHJlcGxhY2U/OiBib29sZWFuO1xuICAgICAgZW5hYmxlVmlld1RyYW5zaXRpb24/OiBib29sZWFuO1xuICAgICAgZmx1c2hTeW5jPzogYm9vbGVhbjtcbiAgICB9XG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIEFib3J0IGFueSBpbi1wcm9ncmVzcyBuYXZpZ2F0aW9ucyBhbmQgc3RhcnQgYSBuZXcgb25lLiBVbnNldCBhbnkgb25nb2luZ1xuICAgIC8vIHVuaW50ZXJydXB0ZWQgcmV2YWxpZGF0aW9ucyB1bmxlc3MgdG9sZCBvdGhlcndpc2UsIHNpbmNlIHdlIHdhbnQgdGhpc1xuICAgIC8vIG5ldyBuYXZpZ2F0aW9uIHRvIHVwZGF0ZSBoaXN0b3J5IG5vcm1hbGx5XG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyICYmIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5hYm9ydCgpO1xuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG51bGw7XG4gICAgcGVuZGluZ0FjdGlvbiA9IGhpc3RvcnlBY3Rpb247XG4gICAgaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uID1cbiAgICAgIChvcHRzICYmIG9wdHMuc3RhcnRVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uKSA9PT0gdHJ1ZTtcblxuICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIGV2ZXJ5IHRpbWUgd2Ugc3RhcnQgYSBuZXcgbmF2aWdhdGlvbixcbiAgICAvLyBhbmQgdHJhY2sgd2hldGhlciB3ZSBzaG91bGQgcmVzZXQgc2Nyb2xsIG9uIGNvbXBsZXRpb25cbiAgICBzYXZlU2Nyb2xsUG9zaXRpb24oc3RhdGUubG9jYXRpb24sIHN0YXRlLm1hdGNoZXMpO1xuICAgIHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQgPSAob3B0cyAmJiBvcHRzLnByZXZlbnRTY3JvbGxSZXNldCkgPT09IHRydWU7XG5cbiAgICBwZW5kaW5nVmlld1RyYW5zaXRpb25FbmFibGVkID0gKG9wdHMgJiYgb3B0cy5lbmFibGVWaWV3VHJhbnNpdGlvbikgPT09IHRydWU7XG5cbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICBsZXQgbG9hZGluZ05hdmlnYXRpb24gPSBvcHRzICYmIG9wdHMub3ZlcnJpZGVOYXZpZ2F0aW9uO1xuICAgIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzVG9Vc2UsIGxvY2F0aW9uLCBiYXNlbmFtZSk7XG4gICAgbGV0IGZsdXNoU3luYyA9IChvcHRzICYmIG9wdHMuZmx1c2hTeW5jKSA9PT0gdHJ1ZTtcblxuICAgIC8vIFNob3J0IGNpcmN1aXQgd2l0aCBhIDQwNCBvbiB0aGUgcm9vdCBlcnJvciBib3VuZGFyeSBpZiB3ZSBtYXRjaCBub3RoaW5nXG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwgeyBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUgfSk7XG4gICAgICBsZXQgeyBtYXRjaGVzOiBub3RGb3VuZE1hdGNoZXMsIHJvdXRlIH0gPVxuICAgICAgICBnZXRTaG9ydENpcmN1aXRNYXRjaGVzKHJvdXRlc1RvVXNlKTtcbiAgICAgIC8vIENhbmNlbCBhbGwgcGVuZGluZyBkZWZlcnJlZCBvbiA0MDRzIHNpbmNlIHdlIGRvbid0IGtlZXAgYW55IHJvdXRlc1xuICAgICAgY2FuY2VsQWN0aXZlRGVmZXJyZWRzKCk7XG4gICAgICBjb21wbGV0ZU5hdmlnYXRpb24oXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICB7XG4gICAgICAgICAgbWF0Y2hlczogbm90Rm91bmRNYXRjaGVzLFxuICAgICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICAgIGVycm9yczoge1xuICAgICAgICAgICAgW3JvdXRlLmlkXTogZXJyb3IsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgeyBmbHVzaFN5bmMgfVxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTaG9ydCBjaXJjdWl0IGlmIGl0J3Mgb25seSBhIGhhc2ggY2hhbmdlIGFuZCBub3QgYSByZXZhbGlkYXRpb24gb3JcbiAgICAvLyBtdXRhdGlvbiBzdWJtaXNzaW9uLlxuICAgIC8vXG4gICAgLy8gSWdub3JlIG9uIGluaXRpYWwgcGFnZSBsb2FkcyBiZWNhdXNlIHNpbmNlIHRoZSBpbml0aWFsIGxvYWQgd2lsbCBhbHdheXNcbiAgICAvLyBiZSBcInNhbWUgaGFzaFwiLiAgRm9yIGV4YW1wbGUsIG9uIC9wYWdlI2hhc2ggYW5kIHN1Ym1pdCBhIDxGb3JtIG1ldGhvZD1cInBvc3RcIj5cbiAgICAvLyB3aGljaCB3aWxsIGRlZmF1bHQgdG8gYSBuYXZpZ2F0aW9uIHRvIC9wYWdlXG4gICAgaWYgKFxuICAgICAgc3RhdGUuaW5pdGlhbGl6ZWQgJiZcbiAgICAgICFpc1JldmFsaWRhdGlvblJlcXVpcmVkICYmXG4gICAgICBpc0hhc2hDaGFuZ2VPbmx5KHN0YXRlLmxvY2F0aW9uLCBsb2NhdGlvbikgJiZcbiAgICAgICEob3B0cyAmJiBvcHRzLnN1Ym1pc3Npb24gJiYgaXNNdXRhdGlvbk1ldGhvZChvcHRzLnN1Ym1pc3Npb24uZm9ybU1ldGhvZCkpXG4gICAgKSB7XG4gICAgICBjb21wbGV0ZU5hdmlnYXRpb24obG9jYXRpb24sIHsgbWF0Y2hlcyB9LCB7IGZsdXNoU3luYyB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYSBjb250cm9sbGVyL1JlcXVlc3QgZm9yIHRoaXMgbmF2aWdhdGlvblxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBsZXQgcmVxdWVzdCA9IGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KFxuICAgICAgaW5pdC5oaXN0b3J5LFxuICAgICAgbG9jYXRpb24sXG4gICAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgb3B0cyAmJiBvcHRzLnN1Ym1pc3Npb25cbiAgICApO1xuICAgIGxldCBwZW5kaW5nQWN0aW9uRGF0YTogUm91dGVEYXRhIHwgdW5kZWZpbmVkO1xuICAgIGxldCBwZW5kaW5nRXJyb3I6IFJvdXRlRGF0YSB8IHVuZGVmaW5lZDtcblxuICAgIGlmIChvcHRzICYmIG9wdHMucGVuZGluZ0Vycm9yKSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgcGVuZGluZ0Vycm9yLCBpdCBtZWFucyB0aGUgdXNlciBhdHRlbXB0ZWQgYSBHRVQgc3VibWlzc2lvblxuICAgICAgLy8gd2l0aCBiaW5hcnkgRm9ybURhdGEgc28gYXNzaWduIGhlcmUgYW5kIHNraXAgdG8gaGFuZGxlTG9hZGVycy4gIFRoYXRcbiAgICAgIC8vIHdheSB3ZSBoYW5kbGUgY2FsbGluZyBsb2FkZXJzIGFib3ZlIHRoZSBib3VuZGFyeSBldGMuICBJdCdzIG5vdCByZWFsbHlcbiAgICAgIC8vIGRpZmZlcmVudCBmcm9tIGFuIGFjdGlvbkVycm9yIGluIHRoYXQgc2Vuc2UuXG4gICAgICBwZW5kaW5nRXJyb3IgPSB7XG4gICAgICAgIFtmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMpLnJvdXRlLmlkXTogb3B0cy5wZW5kaW5nRXJyb3IsXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBvcHRzICYmXG4gICAgICBvcHRzLnN1Ym1pc3Npb24gJiZcbiAgICAgIGlzTXV0YXRpb25NZXRob2Qob3B0cy5zdWJtaXNzaW9uLmZvcm1NZXRob2QpXG4gICAgKSB7XG4gICAgICAvLyBDYWxsIGFjdGlvbiBpZiB3ZSByZWNlaXZlZCBhbiBhY3Rpb24gc3VibWlzc2lvblxuICAgICAgbGV0IGFjdGlvbk91dHB1dCA9IGF3YWl0IGhhbmRsZUFjdGlvbihcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIG9wdHMuc3VibWlzc2lvbixcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgeyByZXBsYWNlOiBvcHRzLnJlcGxhY2UsIGZsdXNoU3luYyB9XG4gICAgICApO1xuXG4gICAgICBpZiAoYWN0aW9uT3V0cHV0LnNob3J0Q2lyY3VpdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcGVuZGluZ0FjdGlvbkRhdGEgPSBhY3Rpb25PdXRwdXQucGVuZGluZ0FjdGlvbkRhdGE7XG4gICAgICBwZW5kaW5nRXJyb3IgPSBhY3Rpb25PdXRwdXQucGVuZGluZ0FjdGlvbkVycm9yO1xuICAgICAgbG9hZGluZ05hdmlnYXRpb24gPSBnZXRMb2FkaW5nTmF2aWdhdGlvbihsb2NhdGlvbiwgb3B0cy5zdWJtaXNzaW9uKTtcbiAgICAgIGZsdXNoU3luYyA9IGZhbHNlO1xuXG4gICAgICAvLyBDcmVhdGUgYSBHRVQgcmVxdWVzdCBmb3IgdGhlIGxvYWRlcnNcbiAgICAgIHJlcXVlc3QgPSBuZXcgUmVxdWVzdChyZXF1ZXN0LnVybCwgeyBzaWduYWw6IHJlcXVlc3Quc2lnbmFsIH0pO1xuICAgIH1cblxuICAgIC8vIENhbGwgbG9hZGVyc1xuICAgIGxldCB7IHNob3J0Q2lyY3VpdGVkLCBsb2FkZXJEYXRhLCBlcnJvcnMgfSA9IGF3YWl0IGhhbmRsZUxvYWRlcnMoXG4gICAgICByZXF1ZXN0LFxuICAgICAgbG9jYXRpb24sXG4gICAgICBtYXRjaGVzLFxuICAgICAgbG9hZGluZ05hdmlnYXRpb24sXG4gICAgICBvcHRzICYmIG9wdHMuc3VibWlzc2lvbixcbiAgICAgIG9wdHMgJiYgb3B0cy5mZXRjaGVyU3VibWlzc2lvbixcbiAgICAgIG9wdHMgJiYgb3B0cy5yZXBsYWNlLFxuICAgICAgZmx1c2hTeW5jLFxuICAgICAgcGVuZGluZ0FjdGlvbkRhdGEsXG4gICAgICBwZW5kaW5nRXJyb3JcbiAgICApO1xuXG4gICAgaWYgKHNob3J0Q2lyY3VpdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2xlYW4gdXAgbm93IHRoYXQgdGhlIGFjdGlvbi9sb2FkZXJzIGhhdmUgY29tcGxldGVkLiAgRG9uJ3QgY2xlYW4gdXAgaWZcbiAgICAvLyB3ZSBzaG9ydCBjaXJjdWl0ZWQgYmVjYXVzZSBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgd2lsbCBoYXZlIGFscmVhZHlcbiAgICAvLyBiZWVuIGFzc2lnbmVkIHRvIGEgbmV3IGNvbnRyb2xsZXIgZm9yIHRoZSBuZXh0IG5hdmlnYXRpb25cbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBudWxsO1xuXG4gICAgY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCB7XG4gICAgICBtYXRjaGVzLFxuICAgICAgLi4uKHBlbmRpbmdBY3Rpb25EYXRhID8geyBhY3Rpb25EYXRhOiBwZW5kaW5nQWN0aW9uRGF0YSB9IDoge30pLFxuICAgICAgbG9hZGVyRGF0YSxcbiAgICAgIGVycm9ycyxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIENhbGwgdGhlIGFjdGlvbiBtYXRjaGVkIGJ5IHRoZSBsZWFmIHJvdXRlIGZvciB0aGlzIG5hdmlnYXRpb24gYW5kIGhhbmRsZVxuICAvLyByZWRpcmVjdHMvZXJyb3JzXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUFjdGlvbihcbiAgICByZXF1ZXN0OiBSZXF1ZXN0LFxuICAgIGxvY2F0aW9uOiBMb2NhdGlvbixcbiAgICBzdWJtaXNzaW9uOiBTdWJtaXNzaW9uLFxuICAgIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgICBvcHRzOiB7IHJlcGxhY2U/OiBib29sZWFuOyBmbHVzaFN5bmM/OiBib29sZWFuIH0gPSB7fVxuICApOiBQcm9taXNlPEhhbmRsZUFjdGlvblJlc3VsdD4ge1xuICAgIGludGVycnVwdEFjdGl2ZUxvYWRzKCk7XG5cbiAgICAvLyBQdXQgdXMgaW4gYSBzdWJtaXR0aW5nIHN0YXRlXG4gICAgbGV0IG5hdmlnYXRpb24gPSBnZXRTdWJtaXR0aW5nTmF2aWdhdGlvbihsb2NhdGlvbiwgc3VibWlzc2lvbik7XG4gICAgdXBkYXRlU3RhdGUoeyBuYXZpZ2F0aW9uIH0sIHsgZmx1c2hTeW5jOiBvcHRzLmZsdXNoU3luYyA9PT0gdHJ1ZSB9KTtcblxuICAgIC8vIENhbGwgb3VyIGFjdGlvbiBhbmQgZ2V0IHRoZSByZXN1bHRcbiAgICBsZXQgcmVzdWx0OiBEYXRhUmVzdWx0O1xuICAgIGxldCBhY3Rpb25NYXRjaCA9IGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIGxvY2F0aW9uKTtcblxuICAgIGlmICghYWN0aW9uTWF0Y2gucm91dGUuYWN0aW9uICYmICFhY3Rpb25NYXRjaC5yb3V0ZS5sYXp5KSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXG4gICAgICAgIGVycm9yOiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICAgIHJvdXRlSWQ6IGFjdGlvbk1hdGNoLnJvdXRlLmlkLFxuICAgICAgICB9KSxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGF3YWl0IGNhbGxMb2FkZXJPckFjdGlvbihcbiAgICAgICAgXCJhY3Rpb25cIixcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgYWN0aW9uTWF0Y2gsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIG1hbmlmZXN0LFxuICAgICAgICBtYXBSb3V0ZVByb3BlcnRpZXMsXG4gICAgICAgIGJhc2VuYW1lXG4gICAgICApO1xuXG4gICAgICBpZiAocmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCByZXBsYWNlOiBib29sZWFuO1xuICAgICAgaWYgKG9wdHMgJiYgb3B0cy5yZXBsYWNlICE9IG51bGwpIHtcbiAgICAgICAgcmVwbGFjZSA9IG9wdHMucmVwbGFjZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIGRpZG4ndCBleHBsaWNpdHkgaW5kaWNhdGUgcmVwbGFjZSBiZWhhdmlvciwgcmVwbGFjZSBpZlxuICAgICAgICAvLyB3ZSByZWRpcmVjdGVkIHRvIHRoZSBleGFjdCBzYW1lIGxvY2F0aW9uIHdlJ3JlIGN1cnJlbnRseSBhdCB0byBhdm9pZFxuICAgICAgICAvLyBkb3VibGUgYmFjay1idXR0b25zXG4gICAgICAgIHJlcGxhY2UgPVxuICAgICAgICAgIHJlc3VsdC5sb2NhdGlvbiA9PT0gc3RhdGUubG9jYXRpb24ucGF0aG5hbWUgKyBzdGF0ZS5sb2NhdGlvbi5zZWFyY2g7XG4gICAgICB9XG4gICAgICBhd2FpdCBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihzdGF0ZSwgcmVzdWx0LCB7IHN1Ym1pc3Npb24sIHJlcGxhY2UgfSk7XG4gICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgIH1cblxuICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIFN0b3JlIG9mZiB0aGUgcGVuZGluZyBlcnJvciAtIHdlIHVzZSBpdCB0byBkZXRlcm1pbmUgd2hpY2ggbG9hZGVyc1xuICAgICAgLy8gdG8gY2FsbCBhbmQgd2lsbCBjb21taXQgaXQgd2hlbiB3ZSBjb21wbGV0ZSB0aGUgbmF2aWdhdGlvblxuICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMsIGFjdGlvbk1hdGNoLnJvdXRlLmlkKTtcblxuICAgICAgLy8gQnkgZGVmYXVsdCwgYWxsIHN1Ym1pc3Npb25zIGFyZSBSRVBMQUNFIG5hdmlnYXRpb25zLCBidXQgaWYgdGhlXG4gICAgICAvLyBhY3Rpb24gdGhyZXcgYW4gZXJyb3IgdGhhdCdsbCBiZSByZW5kZXJlZCBpbiBhbiBlcnJvckVsZW1lbnQsIHdlIGZhbGxcbiAgICAgIC8vIGJhY2sgdG8gUFVTSCBzbyB0aGF0IHRoZSB1c2VyIGNhbiB1c2UgdGhlIGJhY2sgYnV0dG9uIHRvIGdldCBiYWNrIHRvXG4gICAgICAvLyB0aGUgcHJlLXN1Ym1pc3Npb24gZm9ybSBsb2NhdGlvbiB0byB0cnkgYWdhaW5cbiAgICAgIGlmICgob3B0cyAmJiBvcHRzLnJlcGxhY2UpICE9PSB0cnVlKSB7XG4gICAgICAgIHBlbmRpbmdBY3Rpb24gPSBIaXN0b3J5QWN0aW9uLlB1c2g7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8vIFNlbmQgYmFjayBhbiBlbXB0eSBvYmplY3Qgd2UgY2FuIHVzZSB0byBjbGVhciBvdXQgYW55IHByaW9yIGFjdGlvbkRhdGFcbiAgICAgICAgcGVuZGluZ0FjdGlvbkRhdGE6IHt9LFxuICAgICAgICBwZW5kaW5nQWN0aW9uRXJyb3I6IHsgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZXJyb3IgfSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGlzRGVmZXJyZWRSZXN1bHQocmVzdWx0KSkge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDAsIHsgdHlwZTogXCJkZWZlci1hY3Rpb25cIiB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGVuZGluZ0FjdGlvbkRhdGE6IHsgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmRhdGEgfSxcbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBhbGwgYXBwbGljYWJsZSBsb2FkZXJzIGZvciB0aGUgZ2l2ZW4gbWF0Y2hlcywgaGFuZGxpbmcgcmVkaXJlY3RzLFxuICAvLyBlcnJvcnMsIGV0Yy5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlTG9hZGVycyhcbiAgICByZXF1ZXN0OiBSZXF1ZXN0LFxuICAgIGxvY2F0aW9uOiBMb2NhdGlvbixcbiAgICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gICAgb3ZlcnJpZGVOYXZpZ2F0aW9uPzogTmF2aWdhdGlvbixcbiAgICBzdWJtaXNzaW9uPzogU3VibWlzc2lvbixcbiAgICBmZXRjaGVyU3VibWlzc2lvbj86IFN1Ym1pc3Npb24sXG4gICAgcmVwbGFjZT86IGJvb2xlYW4sXG4gICAgZmx1c2hTeW5jPzogYm9vbGVhbixcbiAgICBwZW5kaW5nQWN0aW9uRGF0YT86IFJvdXRlRGF0YSxcbiAgICBwZW5kaW5nRXJyb3I/OiBSb3V0ZURhdGFcbiAgKTogUHJvbWlzZTxIYW5kbGVMb2FkZXJzUmVzdWx0PiB7XG4gICAgLy8gRmlndXJlIG91dCB0aGUgcmlnaHQgbmF2aWdhdGlvbiB3ZSB3YW50IHRvIHVzZSBmb3IgZGF0YSBsb2FkaW5nXG4gICAgbGV0IGxvYWRpbmdOYXZpZ2F0aW9uID1cbiAgICAgIG92ZXJyaWRlTmF2aWdhdGlvbiB8fCBnZXRMb2FkaW5nTmF2aWdhdGlvbihsb2NhdGlvbiwgc3VibWlzc2lvbik7XG5cbiAgICAvLyBJZiB0aGlzIHdhcyBhIHJlZGlyZWN0IGZyb20gYW4gYWN0aW9uIHdlIGRvbid0IGhhdmUgYSBcInN1Ym1pc3Npb25cIiBidXRcbiAgICAvLyB3ZSBoYXZlIGl0IG9uIHRoZSBsb2FkaW5nIG5hdmlnYXRpb24gc28gdXNlIHRoYXQgaWYgYXZhaWxhYmxlXG4gICAgbGV0IGFjdGl2ZVN1Ym1pc3Npb24gPVxuICAgICAgc3VibWlzc2lvbiB8fFxuICAgICAgZmV0Y2hlclN1Ym1pc3Npb24gfHxcbiAgICAgIGdldFN1Ym1pc3Npb25Gcm9tTmF2aWdhdGlvbihsb2FkaW5nTmF2aWdhdGlvbik7XG5cbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICBsZXQgW21hdGNoZXNUb0xvYWQsIHJldmFsaWRhdGluZ0ZldGNoZXJzXSA9IGdldE1hdGNoZXNUb0xvYWQoXG4gICAgICBpbml0Lmhpc3RvcnksXG4gICAgICBzdGF0ZSxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBhY3RpdmVTdWJtaXNzaW9uLFxuICAgICAgbG9jYXRpb24sXG4gICAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkLFxuICAgICAgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXMsXG4gICAgICBjYW5jZWxsZWRGZXRjaGVyTG9hZHMsXG4gICAgICBmZXRjaExvYWRNYXRjaGVzLFxuICAgICAgZmV0Y2hSZWRpcmVjdElkcyxcbiAgICAgIHJvdXRlc1RvVXNlLFxuICAgICAgYmFzZW5hbWUsXG4gICAgICBwZW5kaW5nQWN0aW9uRGF0YSxcbiAgICAgIHBlbmRpbmdFcnJvclxuICAgICk7XG5cbiAgICAvLyBDYW5jZWwgcGVuZGluZyBkZWZlcnJlZHMgZm9yIG5vLWxvbmdlci1tYXRjaGVkIHJvdXRlcyBvciByb3V0ZXMgd2UncmVcbiAgICAvLyBhYm91dCB0byByZWxvYWQuICBOb3RlIHRoYXQgaWYgdGhpcyBpcyBhbiBhY3Rpb24gcmVsb2FkIHdlIHdvdWxkIGhhdmVcbiAgICAvLyBhbHJlYWR5IGNhbmNlbGxlZCBhbGwgcGVuZGluZyBkZWZlcnJlZHMgc28gdGhpcyB3b3VsZCBiZSBhIG5vLW9wXG4gICAgY2FuY2VsQWN0aXZlRGVmZXJyZWRzKFxuICAgICAgKHJvdXRlSWQpID0+XG4gICAgICAgICEobWF0Y2hlcyAmJiBtYXRjaGVzLnNvbWUoKG0pID0+IG0ucm91dGUuaWQgPT09IHJvdXRlSWQpKSB8fFxuICAgICAgICAobWF0Y2hlc1RvTG9hZCAmJiBtYXRjaGVzVG9Mb2FkLnNvbWUoKG0pID0+IG0ucm91dGUuaWQgPT09IHJvdXRlSWQpKVxuICAgICk7XG5cbiAgICBwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCA9ICsraW5jcmVtZW50aW5nTG9hZElkO1xuXG4gICAgLy8gU2hvcnQgY2lyY3VpdCBpZiB3ZSBoYXZlIG5vIGxvYWRlcnMgdG8gcnVuXG4gICAgaWYgKG1hdGNoZXNUb0xvYWQubGVuZ3RoID09PSAwICYmIHJldmFsaWRhdGluZ0ZldGNoZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbGV0IHVwZGF0ZWRGZXRjaGVycyA9IG1hcmtGZXRjaFJlZGlyZWN0c0RvbmUoKTtcbiAgICAgIGNvbXBsZXRlTmF2aWdhdGlvbihcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIHtcbiAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICAgIC8vIENvbW1pdCBwZW5kaW5nIGVycm9yIGlmIHdlJ3JlIHNob3J0IGNpcmN1aXRpbmdcbiAgICAgICAgICBlcnJvcnM6IHBlbmRpbmdFcnJvciB8fCBudWxsLFxuICAgICAgICAgIC4uLihwZW5kaW5nQWN0aW9uRGF0YSA/IHsgYWN0aW9uRGF0YTogcGVuZGluZ0FjdGlvbkRhdGEgfSA6IHt9KSxcbiAgICAgICAgICAuLi4odXBkYXRlZEZldGNoZXJzID8geyBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgfSA6IHt9KSxcbiAgICAgICAgfSxcbiAgICAgICAgeyBmbHVzaFN5bmMgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7IHNob3J0Q2lyY3VpdGVkOiB0cnVlIH07XG4gICAgfVxuXG4gICAgLy8gSWYgdGhpcyBpcyBhbiB1bmludGVycnVwdGVkIHJldmFsaWRhdGlvbiwgd2UgcmVtYWluIGluIG91ciBjdXJyZW50IGlkbGVcbiAgICAvLyBzdGF0ZS4gIElmIG5vdCwgd2UgbmVlZCB0byBzd2l0Y2ggdG8gb3VyIGxvYWRpbmcgc3RhdGUgYW5kIGxvYWQgZGF0YSxcbiAgICAvLyBwcmVzZXJ2aW5nIGFueSBuZXcgYWN0aW9uIGRhdGEgb3IgZXhpc3RpbmcgYWN0aW9uIGRhdGEgKGluIHRoZSBjYXNlIG9mXG4gICAgLy8gYSByZXZhbGlkYXRpb24gaW50ZXJydXB0aW5nIGFuIGFjdGlvblJlbG9hZClcbiAgICBpZiAoIWlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbikge1xuICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaCgocmYpID0+IHtcbiAgICAgICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQocmYua2V5KTtcbiAgICAgICAgbGV0IHJldmFsaWRhdGluZ0ZldGNoZXIgPSBnZXRMb2FkaW5nRmV0Y2hlcihcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgZmV0Y2hlciA/IGZldGNoZXIuZGF0YSA6IHVuZGVmaW5lZFxuICAgICAgICApO1xuICAgICAgICBzdGF0ZS5mZXRjaGVycy5zZXQocmYua2V5LCByZXZhbGlkYXRpbmdGZXRjaGVyKTtcbiAgICAgIH0pO1xuICAgICAgbGV0IGFjdGlvbkRhdGEgPSBwZW5kaW5nQWN0aW9uRGF0YSB8fCBzdGF0ZS5hY3Rpb25EYXRhO1xuICAgICAgdXBkYXRlU3RhdGUoXG4gICAgICAgIHtcbiAgICAgICAgICBuYXZpZ2F0aW9uOiBsb2FkaW5nTmF2aWdhdGlvbixcbiAgICAgICAgICAuLi4oYWN0aW9uRGF0YVxuICAgICAgICAgICAgPyBPYmplY3Qua2V5cyhhY3Rpb25EYXRhKS5sZW5ndGggPT09IDBcbiAgICAgICAgICAgICAgPyB7IGFjdGlvbkRhdGE6IG51bGwgfVxuICAgICAgICAgICAgICA6IHsgYWN0aW9uRGF0YSB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAuLi4ocmV2YWxpZGF0aW5nRmV0Y2hlcnMubGVuZ3RoID4gMFxuICAgICAgICAgICAgPyB7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGZsdXNoU3luYyxcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKChyZikgPT4ge1xuICAgICAgaWYgKGZldGNoQ29udHJvbGxlcnMuaGFzKHJmLmtleSkpIHtcbiAgICAgICAgYWJvcnRGZXRjaGVyKHJmLmtleSk7XG4gICAgICB9XG4gICAgICBpZiAocmYuY29udHJvbGxlcikge1xuICAgICAgICAvLyBGZXRjaGVycyB1c2UgYW4gaW5kZXBlbmRlbnQgQWJvcnRDb250cm9sbGVyIHNvIHRoYXQgYWJvcnRpbmcgYSBmZXRjaGVyXG4gICAgICAgIC8vICh2aWEgZGVsZXRlRmV0Y2hlcikgZG9lcyBub3QgYWJvcnQgdGhlIHRyaWdnZXJpbmcgbmF2aWdhdGlvbiB0aGF0XG4gICAgICAgIC8vIHRyaWdnZXJlZCB0aGUgcmV2YWxpZGF0aW9uXG4gICAgICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KHJmLmtleSwgcmYuY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBQcm94eSBuYXZpZ2F0aW9uIGFib3J0IHRocm91Z2ggdG8gcmV2YWxpZGF0aW9uIGZldGNoZXJzXG4gICAgbGV0IGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9ucyA9ICgpID0+XG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKChmKSA9PiBhYm9ydEZldGNoZXIoZi5rZXkpKTtcbiAgICBpZiAocGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyKSB7XG4gICAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwiYWJvcnRcIixcbiAgICAgICAgYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCB7IHJlc3VsdHMsIGxvYWRlclJlc3VsdHMsIGZldGNoZXJSZXN1bHRzIH0gPVxuICAgICAgYXdhaXQgY2FsbExvYWRlcnNBbmRNYXliZVJlc29sdmVEYXRhKFxuICAgICAgICBzdGF0ZS5tYXRjaGVzLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBtYXRjaGVzVG9Mb2FkLFxuICAgICAgICByZXZhbGlkYXRpbmdGZXRjaGVycyxcbiAgICAgICAgcmVxdWVzdFxuICAgICAgKTtcblxuICAgIGlmIChyZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgIH1cblxuICAgIC8vIENsZWFuIHVwIF9hZnRlcl8gbG9hZGVycyBoYXZlIGNvbXBsZXRlZC4gIERvbid0IGNsZWFuIHVwIGlmIHdlIHNob3J0XG4gICAgLy8gY2lyY3VpdGVkIGJlY2F1c2UgZmV0Y2hDb250cm9sbGVycyB3b3VsZCBoYXZlIGJlZW4gYWJvcnRlZCBhbmRcbiAgICAvLyByZWFzc2lnbmVkIHRvIG5ldyBjb250cm9sbGVycyBmb3IgdGhlIG5leHQgbmF2aWdhdGlvblxuICAgIGlmIChwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIpIHtcbiAgICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJhYm9ydFwiLFxuICAgICAgICBhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnNcbiAgICAgICk7XG4gICAgfVxuICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2goKHJmKSA9PiBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShyZi5rZXkpKTtcblxuICAgIC8vIElmIGFueSBsb2FkZXJzIHJldHVybmVkIGEgcmVkaXJlY3QgUmVzcG9uc2UsIHN0YXJ0IGEgbmV3IFJFUExBQ0UgbmF2aWdhdGlvblxuICAgIGxldCByZWRpcmVjdCA9IGZpbmRSZWRpcmVjdChyZXN1bHRzKTtcbiAgICBpZiAocmVkaXJlY3QpIHtcbiAgICAgIGlmIChyZWRpcmVjdC5pZHggPj0gbWF0Y2hlc1RvTG9hZC5sZW5ndGgpIHtcbiAgICAgICAgLy8gSWYgdGhpcyByZWRpcmVjdCBjYW1lIGZyb20gYSBmZXRjaGVyIG1ha2Ugc3VyZSB3ZSBtYXJrIGl0IGluXG4gICAgICAgIC8vIGZldGNoUmVkaXJlY3RJZHMgc28gaXQgZG9lc24ndCBnZXQgcmV2YWxpZGF0ZWQgb24gdGhlIG5leHQgc2V0IG9mXG4gICAgICAgIC8vIGxvYWRlciBleGVjdXRpb25zXG4gICAgICAgIGxldCBmZXRjaGVyS2V5ID1cbiAgICAgICAgICByZXZhbGlkYXRpbmdGZXRjaGVyc1tyZWRpcmVjdC5pZHggLSBtYXRjaGVzVG9Mb2FkLmxlbmd0aF0ua2V5O1xuICAgICAgICBmZXRjaFJlZGlyZWN0SWRzLmFkZChmZXRjaGVyS2V5KTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHN0YXRlLCByZWRpcmVjdC5yZXN1bHQsIHsgcmVwbGFjZSB9KTtcbiAgICAgIHJldHVybiB7IHNob3J0Q2lyY3VpdGVkOiB0cnVlIH07XG4gICAgfVxuXG4gICAgLy8gUHJvY2VzcyBhbmQgY29tbWl0IG91dHB1dCBmcm9tIGxvYWRlcnNcbiAgICBsZXQgeyBsb2FkZXJEYXRhLCBlcnJvcnMgfSA9IHByb2Nlc3NMb2FkZXJEYXRhKFxuICAgICAgc3RhdGUsXG4gICAgICBtYXRjaGVzLFxuICAgICAgbWF0Y2hlc1RvTG9hZCxcbiAgICAgIGxvYWRlclJlc3VsdHMsXG4gICAgICBwZW5kaW5nRXJyb3IsXG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycyxcbiAgICAgIGZldGNoZXJSZXN1bHRzLFxuICAgICAgYWN0aXZlRGVmZXJyZWRzXG4gICAgKTtcblxuICAgIC8vIFdpcmUgdXAgc3Vic2NyaWJlcnMgdG8gdXBkYXRlIGxvYWRlckRhdGEgYXMgcHJvbWlzZXMgc2V0dGxlXG4gICAgYWN0aXZlRGVmZXJyZWRzLmZvckVhY2goKGRlZmVycmVkRGF0YSwgcm91dGVJZCkgPT4ge1xuICAgICAgZGVmZXJyZWREYXRhLnN1YnNjcmliZSgoYWJvcnRlZCkgPT4ge1xuICAgICAgICAvLyBOb3RlOiBObyBuZWVkIHRvIHVwZGF0ZVN0YXRlIGhlcmUgc2luY2UgdGhlIFRyYWNrZWRQcm9taXNlIG9uXG4gICAgICAgIC8vIGxvYWRlckRhdGEgaXMgc3RhYmxlIGFjcm9zcyByZXNvbHZlL3JlamVjdFxuICAgICAgICAvLyBSZW1vdmUgdGhpcyBpbnN0YW5jZSBpZiB3ZSB3ZXJlIGFib3J0ZWQgb3IgaWYgcHJvbWlzZXMgaGF2ZSBzZXR0bGVkXG4gICAgICAgIGlmIChhYm9ydGVkIHx8IGRlZmVycmVkRGF0YS5kb25lKSB7XG4gICAgICAgICAgYWN0aXZlRGVmZXJyZWRzLmRlbGV0ZShyb3V0ZUlkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBsZXQgdXBkYXRlZEZldGNoZXJzID0gbWFya0ZldGNoUmVkaXJlY3RzRG9uZSgpO1xuICAgIGxldCBkaWRBYm9ydEZldGNoTG9hZHMgPSBhYm9ydFN0YWxlRmV0Y2hMb2FkcyhwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCk7XG4gICAgbGV0IHNob3VsZFVwZGF0ZUZldGNoZXJzID1cbiAgICAgIHVwZGF0ZWRGZXRjaGVycyB8fCBkaWRBYm9ydEZldGNoTG9hZHMgfHwgcmV2YWxpZGF0aW5nRmV0Y2hlcnMubGVuZ3RoID4gMDtcblxuICAgIHJldHVybiB7XG4gICAgICBsb2FkZXJEYXRhLFxuICAgICAgZXJyb3JzLFxuICAgICAgLi4uKHNob3VsZFVwZGF0ZUZldGNoZXJzID8geyBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgfSA6IHt9KSxcbiAgICB9O1xuICB9XG5cbiAgLy8gVHJpZ2dlciBhIGZldGNoZXIgbG9hZC9zdWJtaXQgZm9yIHRoZSBnaXZlbiBmZXRjaGVyIGtleVxuICBmdW5jdGlvbiBmZXRjaChcbiAgICBrZXk6IHN0cmluZyxcbiAgICByb3V0ZUlkOiBzdHJpbmcsXG4gICAgaHJlZjogc3RyaW5nIHwgbnVsbCxcbiAgICBvcHRzPzogUm91dGVyRmV0Y2hPcHRpb25zXG4gICkge1xuICAgIGlmIChpc1NlcnZlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcInJvdXRlci5mZXRjaCgpIHdhcyBjYWxsZWQgZHVyaW5nIHRoZSBzZXJ2ZXIgcmVuZGVyLCBidXQgaXQgc2hvdWxkbid0IGJlLiBcIiArXG4gICAgICAgICAgXCJZb3UgYXJlIGxpa2VseSBjYWxsaW5nIGEgdXNlRmV0Y2hlcigpIG1ldGhvZCBpbiB0aGUgYm9keSBvZiB5b3VyIGNvbXBvbmVudC4gXCIgK1xuICAgICAgICAgIFwiVHJ5IG1vdmluZyBpdCB0byBhIHVzZUVmZmVjdCBvciBhIGNhbGxiYWNrLlwiXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmhhcyhrZXkpKSBhYm9ydEZldGNoZXIoa2V5KTtcbiAgICBsZXQgZmx1c2hTeW5jID0gKG9wdHMgJiYgb3B0cy51bnN0YWJsZV9mbHVzaFN5bmMpID09PSB0cnVlO1xuXG4gICAgbGV0IHJvdXRlc1RvVXNlID0gaW5GbGlnaHREYXRhUm91dGVzIHx8IGRhdGFSb3V0ZXM7XG4gICAgbGV0IG5vcm1hbGl6ZWRQYXRoID0gbm9ybWFsaXplVG8oXG4gICAgICBzdGF0ZS5sb2NhdGlvbixcbiAgICAgIHN0YXRlLm1hdGNoZXMsXG4gICAgICBiYXNlbmFtZSxcbiAgICAgIGZ1dHVyZS52N19wcmVwZW5kQmFzZW5hbWUsXG4gICAgICBocmVmLFxuICAgICAgcm91dGVJZCxcbiAgICAgIG9wdHM/LnJlbGF0aXZlXG4gICAgKTtcbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKHJvdXRlc1RvVXNlLCBub3JtYWxpemVkUGF0aCwgYmFzZW5hbWUpO1xuXG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICBzZXRGZXRjaGVyRXJyb3IoXG4gICAgICAgIGtleSxcbiAgICAgICAgcm91dGVJZCxcbiAgICAgICAgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHsgcGF0aG5hbWU6IG5vcm1hbGl6ZWRQYXRoIH0pLFxuICAgICAgICB7IGZsdXNoU3luYyB9XG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCB7IHBhdGgsIHN1Ym1pc3Npb24sIGVycm9yIH0gPSBub3JtYWxpemVOYXZpZ2F0ZU9wdGlvbnMoXG4gICAgICBmdXR1cmUudjdfbm9ybWFsaXplRm9ybU1ldGhvZCxcbiAgICAgIHRydWUsXG4gICAgICBub3JtYWxpemVkUGF0aCxcbiAgICAgIG9wdHNcbiAgICApO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBlcnJvciwgeyBmbHVzaFN5bmMgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IG1hdGNoID0gZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgcGF0aCk7XG5cbiAgICBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID0gKG9wdHMgJiYgb3B0cy5wcmV2ZW50U2Nyb2xsUmVzZXQpID09PSB0cnVlO1xuXG4gICAgaWYgKHN1Ym1pc3Npb24gJiYgaXNNdXRhdGlvbk1ldGhvZChzdWJtaXNzaW9uLmZvcm1NZXRob2QpKSB7XG4gICAgICBoYW5kbGVGZXRjaGVyQWN0aW9uKFxuICAgICAgICBrZXksXG4gICAgICAgIHJvdXRlSWQsXG4gICAgICAgIHBhdGgsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBmbHVzaFN5bmMsXG4gICAgICAgIHN1Ym1pc3Npb25cbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU3RvcmUgb2ZmIHRoZSBtYXRjaCBzbyB3ZSBjYW4gY2FsbCBpdCdzIHNob3VsZFJldmFsaWRhdGUgb24gc3Vic2VxdWVudFxuICAgIC8vIHJldmFsaWRhdGlvbnNcbiAgICBmZXRjaExvYWRNYXRjaGVzLnNldChrZXksIHsgcm91dGVJZCwgcGF0aCB9KTtcbiAgICBoYW5kbGVGZXRjaGVyTG9hZGVyKFxuICAgICAga2V5LFxuICAgICAgcm91dGVJZCxcbiAgICAgIHBhdGgsXG4gICAgICBtYXRjaCxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBmbHVzaFN5bmMsXG4gICAgICBzdWJtaXNzaW9uXG4gICAgKTtcbiAgfVxuXG4gIC8vIENhbGwgdGhlIGFjdGlvbiBmb3IgdGhlIG1hdGNoZWQgZmV0Y2hlci5zdWJtaXQoKSwgYW5kIHRoZW4gaGFuZGxlIHJlZGlyZWN0cyxcbiAgLy8gZXJyb3JzLCBhbmQgcmV2YWxpZGF0aW9uXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUZldGNoZXJBY3Rpb24oXG4gICAga2V5OiBzdHJpbmcsXG4gICAgcm91dGVJZDogc3RyaW5nLFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBtYXRjaDogQWdub3N0aWNEYXRhUm91dGVNYXRjaCxcbiAgICByZXF1ZXN0TWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICAgIGZsdXNoU3luYzogYm9vbGVhbixcbiAgICBzdWJtaXNzaW9uOiBTdWJtaXNzaW9uXG4gICkge1xuICAgIGludGVycnVwdEFjdGl2ZUxvYWRzKCk7XG4gICAgZmV0Y2hMb2FkTWF0Y2hlcy5kZWxldGUoa2V5KTtcblxuICAgIGlmICghbWF0Y2gucm91dGUuYWN0aW9uICYmICFtYXRjaC5yb3V0ZS5sYXp5KSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICBtZXRob2Q6IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCxcbiAgICAgICAgcGF0aG5hbWU6IHBhdGgsXG4gICAgICAgIHJvdXRlSWQ6IHJvdXRlSWQsXG4gICAgICB9KTtcbiAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGVycm9yLCB7IGZsdXNoU3luYyB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBQdXQgdGhpcyBmZXRjaGVyIGludG8gaXQncyBzdWJtaXR0aW5nIHN0YXRlXG4gICAgbGV0IGV4aXN0aW5nRmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldFN1Ym1pdHRpbmdGZXRjaGVyKHN1Ym1pc3Npb24sIGV4aXN0aW5nRmV0Y2hlciksIHtcbiAgICAgIGZsdXNoU3luYyxcbiAgICB9KTtcblxuICAgIC8vIENhbGwgdGhlIGFjdGlvbiBmb3IgdGhlIGZldGNoZXJcbiAgICBsZXQgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGxldCBmZXRjaFJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChcbiAgICAgIGluaXQuaGlzdG9yeSxcbiAgICAgIHBhdGgsXG4gICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgc3VibWlzc2lvblxuICAgICk7XG4gICAgZmV0Y2hDb250cm9sbGVycy5zZXQoa2V5LCBhYm9ydENvbnRyb2xsZXIpO1xuXG4gICAgbGV0IG9yaWdpbmF0aW5nTG9hZElkID0gaW5jcmVtZW50aW5nTG9hZElkO1xuICAgIGxldCBhY3Rpb25SZXN1bHQgPSBhd2FpdCBjYWxsTG9hZGVyT3JBY3Rpb24oXG4gICAgICBcImFjdGlvblwiLFxuICAgICAgZmV0Y2hSZXF1ZXN0LFxuICAgICAgbWF0Y2gsXG4gICAgICByZXF1ZXN0TWF0Y2hlcyxcbiAgICAgIG1hbmlmZXN0LFxuICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzLFxuICAgICAgYmFzZW5hbWVcbiAgICApO1xuXG4gICAgaWYgKGZldGNoUmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgLy8gV2UgY2FuIGRlbGV0ZSB0aGlzIHNvIGxvbmcgYXMgd2Ugd2VyZW4ndCBhYm9ydGVkIGJ5IG91ciBvd24gZmV0Y2hlclxuICAgICAgLy8gcmUtc3VibWl0IHdoaWNoIHdvdWxkIGhhdmUgcHV0IF9uZXdfIGNvbnRyb2xsZXIgaXMgaW4gZmV0Y2hDb250cm9sbGVyc1xuICAgICAgaWYgKGZldGNoQ29udHJvbGxlcnMuZ2V0KGtleSkgPT09IGFib3J0Q29udHJvbGxlcikge1xuICAgICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChkZWxldGVkRmV0Y2hlcnMuaGFzKGtleSkpIHtcbiAgICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldERvbmVGZXRjaGVyKHVuZGVmaW5lZCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KGFjdGlvblJlc3VsdCkpIHtcbiAgICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gICAgICBpZiAocGVuZGluZ05hdmlnYXRpb25Mb2FkSWQgPiBvcmlnaW5hdGluZ0xvYWRJZCkge1xuICAgICAgICAvLyBBIG5ldyBuYXZpZ2F0aW9uIHdhcyBraWNrZWQgb2ZmIGFmdGVyIG91ciBhY3Rpb24gc3RhcnRlZCwgc28gdGhhdFxuICAgICAgICAvLyBzaG91bGQgdGFrZSBwcmVjZWRlbmNlIG92ZXIgdGhpcyByZWRpcmVjdCBuYXZpZ2F0aW9uLiAgV2UgYWxyZWFkeVxuICAgICAgICAvLyBzZXQgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCBzbyBhbGwgbG9hZGVycyBmb3IgdGhlIG5ldyByb3V0ZSBzaG91bGRcbiAgICAgICAgLy8gZmlyZSB1bmxlc3Mgb3B0ZWQgb3V0IHZpYSBzaG91bGRSZXZhbGlkYXRlXG4gICAgICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldERvbmVGZXRjaGVyKHVuZGVmaW5lZCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmZXRjaFJlZGlyZWN0SWRzLmFkZChrZXkpO1xuICAgICAgICB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBnZXRMb2FkaW5nRmV0Y2hlcihzdWJtaXNzaW9uKSk7XG4gICAgICAgIHJldHVybiBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihzdGF0ZSwgYWN0aW9uUmVzdWx0LCB7XG4gICAgICAgICAgZmV0Y2hlclN1Ym1pc3Npb246IHN1Ym1pc3Npb24sXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFByb2Nlc3MgYW55IG5vbi1yZWRpcmVjdCBlcnJvcnMgdGhyb3duXG4gICAgaWYgKGlzRXJyb3JSZXN1bHQoYWN0aW9uUmVzdWx0KSkge1xuICAgICAgc2V0RmV0Y2hlckVycm9yKGtleSwgcm91dGVJZCwgYWN0aW9uUmVzdWx0LmVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNEZWZlcnJlZFJlc3VsdChhY3Rpb25SZXN1bHQpKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwgeyB0eXBlOiBcImRlZmVyLWFjdGlvblwiIH0pO1xuICAgIH1cblxuICAgIC8vIFN0YXJ0IHRoZSBkYXRhIGxvYWQgZm9yIGN1cnJlbnQgbWF0Y2hlcywgb3IgdGhlIG5leHQgbG9jYXRpb24gaWYgd2UncmVcbiAgICAvLyBpbiB0aGUgbWlkZGxlIG9mIGEgbmF2aWdhdGlvblxuICAgIGxldCBuZXh0TG9jYXRpb24gPSBzdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uIHx8IHN0YXRlLmxvY2F0aW9uO1xuICAgIGxldCByZXZhbGlkYXRpb25SZXF1ZXN0ID0gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoXG4gICAgICBpbml0Lmhpc3RvcnksXG4gICAgICBuZXh0TG9jYXRpb24sXG4gICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgKTtcbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICBsZXQgbWF0Y2hlcyA9XG4gICAgICBzdGF0ZS5uYXZpZ2F0aW9uLnN0YXRlICE9PSBcImlkbGVcIlxuICAgICAgICA/IG1hdGNoUm91dGVzKHJvdXRlc1RvVXNlLCBzdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uLCBiYXNlbmFtZSlcbiAgICAgICAgOiBzdGF0ZS5tYXRjaGVzO1xuXG4gICAgaW52YXJpYW50KG1hdGNoZXMsIFwiRGlkbid0IGZpbmQgYW55IG1hdGNoZXMgYWZ0ZXIgZmV0Y2hlciBhY3Rpb25cIik7XG5cbiAgICBsZXQgbG9hZElkID0gKytpbmNyZW1lbnRpbmdMb2FkSWQ7XG4gICAgZmV0Y2hSZWxvYWRJZHMuc2V0KGtleSwgbG9hZElkKTtcblxuICAgIGxldCBsb2FkRmV0Y2hlciA9IGdldExvYWRpbmdGZXRjaGVyKHN1Ym1pc3Npb24sIGFjdGlvblJlc3VsdC5kYXRhKTtcbiAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBsb2FkRmV0Y2hlcik7XG5cbiAgICBsZXQgW21hdGNoZXNUb0xvYWQsIHJldmFsaWRhdGluZ0ZldGNoZXJzXSA9IGdldE1hdGNoZXNUb0xvYWQoXG4gICAgICBpbml0Lmhpc3RvcnksXG4gICAgICBzdGF0ZSxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgbmV4dExvY2F0aW9uLFxuICAgICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCxcbiAgICAgIGNhbmNlbGxlZERlZmVycmVkUm91dGVzLFxuICAgICAgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLFxuICAgICAgZmV0Y2hMb2FkTWF0Y2hlcyxcbiAgICAgIGZldGNoUmVkaXJlY3RJZHMsXG4gICAgICByb3V0ZXNUb1VzZSxcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgeyBbbWF0Y2gucm91dGUuaWRdOiBhY3Rpb25SZXN1bHQuZGF0YSB9LFxuICAgICAgdW5kZWZpbmVkIC8vIE5vIG5lZWQgdG8gc2VuZCB0aHJvdWdoIGVycm9ycyBzaW5jZSB3ZSBzaG9ydCBjaXJjdWl0IGFib3ZlXG4gICAgKTtcblxuICAgIC8vIFB1dCBhbGwgcmV2YWxpZGF0aW5nIGZldGNoZXJzIGludG8gdGhlIGxvYWRpbmcgc3RhdGUsIGV4Y2VwdCBmb3IgdGhlXG4gICAgLy8gY3VycmVudCBmZXRjaGVyIHdoaWNoIHdlIHdhbnQgdG8ga2VlcCBpbiBpdCdzIGN1cnJlbnQgbG9hZGluZyBzdGF0ZSB3aGljaFxuICAgIC8vIGNvbnRhaW5zIGl0J3MgYWN0aW9uIHN1Ym1pc3Npb24gaW5mbyArIGFjdGlvbiBkYXRhXG4gICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnNcbiAgICAgIC5maWx0ZXIoKHJmKSA9PiByZi5rZXkgIT09IGtleSlcbiAgICAgIC5mb3JFYWNoKChyZikgPT4ge1xuICAgICAgICBsZXQgc3RhbGVLZXkgPSByZi5rZXk7XG4gICAgICAgIGxldCBleGlzdGluZ0ZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoc3RhbGVLZXkpO1xuICAgICAgICBsZXQgcmV2YWxpZGF0aW5nRmV0Y2hlciA9IGdldExvYWRpbmdGZXRjaGVyKFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICBleGlzdGluZ0ZldGNoZXIgPyBleGlzdGluZ0ZldGNoZXIuZGF0YSA6IHVuZGVmaW5lZFxuICAgICAgICApO1xuICAgICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoc3RhbGVLZXksIHJldmFsaWRhdGluZ0ZldGNoZXIpO1xuICAgICAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5oYXMoc3RhbGVLZXkpKSB7XG4gICAgICAgICAgYWJvcnRGZXRjaGVyKHN0YWxlS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmYuY29udHJvbGxlcikge1xuICAgICAgICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KHN0YWxlS2V5LCByZi5jb250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICB1cGRhdGVTdGF0ZSh7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9KTtcblxuICAgIGxldCBhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnMgPSAoKSA9PlxuICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaCgocmYpID0+IGFib3J0RmV0Y2hlcihyZi5rZXkpKTtcblxuICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwiYWJvcnRcIixcbiAgICAgIGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9uc1xuICAgICk7XG5cbiAgICBsZXQgeyByZXN1bHRzLCBsb2FkZXJSZXN1bHRzLCBmZXRjaGVyUmVzdWx0cyB9ID1cbiAgICAgIGF3YWl0IGNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YShcbiAgICAgICAgc3RhdGUubWF0Y2hlcyxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgbWF0Y2hlc1RvTG9hZCxcbiAgICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMsXG4gICAgICAgIHJldmFsaWRhdGlvblJlcXVlc3RcbiAgICAgICk7XG5cbiAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgXCJhYm9ydFwiLFxuICAgICAgYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zXG4gICAgKTtcblxuICAgIGZldGNoUmVsb2FkSWRzLmRlbGV0ZShrZXkpO1xuICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaCgocikgPT4gZmV0Y2hDb250cm9sbGVycy5kZWxldGUoci5rZXkpKTtcblxuICAgIGxldCByZWRpcmVjdCA9IGZpbmRSZWRpcmVjdChyZXN1bHRzKTtcbiAgICBpZiAocmVkaXJlY3QpIHtcbiAgICAgIGlmIChyZWRpcmVjdC5pZHggPj0gbWF0Y2hlc1RvTG9hZC5sZW5ndGgpIHtcbiAgICAgICAgLy8gSWYgdGhpcyByZWRpcmVjdCBjYW1lIGZyb20gYSBmZXRjaGVyIG1ha2Ugc3VyZSB3ZSBtYXJrIGl0IGluXG4gICAgICAgIC8vIGZldGNoUmVkaXJlY3RJZHMgc28gaXQgZG9lc24ndCBnZXQgcmV2YWxpZGF0ZWQgb24gdGhlIG5leHQgc2V0IG9mXG4gICAgICAgIC8vIGxvYWRlciBleGVjdXRpb25zXG4gICAgICAgIGxldCBmZXRjaGVyS2V5ID1cbiAgICAgICAgICByZXZhbGlkYXRpbmdGZXRjaGVyc1tyZWRpcmVjdC5pZHggLSBtYXRjaGVzVG9Mb2FkLmxlbmd0aF0ua2V5O1xuICAgICAgICBmZXRjaFJlZGlyZWN0SWRzLmFkZChmZXRjaGVyS2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihzdGF0ZSwgcmVkaXJlY3QucmVzdWx0KTtcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIGFuZCBjb21taXQgb3V0cHV0IGZyb20gbG9hZGVyc1xuICAgIGxldCB7IGxvYWRlckRhdGEsIGVycm9ycyB9ID0gcHJvY2Vzc0xvYWRlckRhdGEoXG4gICAgICBzdGF0ZSxcbiAgICAgIHN0YXRlLm1hdGNoZXMsXG4gICAgICBtYXRjaGVzVG9Mb2FkLFxuICAgICAgbG9hZGVyUmVzdWx0cyxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLFxuICAgICAgZmV0Y2hlclJlc3VsdHMsXG4gICAgICBhY3RpdmVEZWZlcnJlZHNcbiAgICApO1xuXG4gICAgLy8gU2luY2Ugd2UgbGV0IHJldmFsaWRhdGlvbnMgY29tcGxldGUgZXZlbiBpZiB0aGUgc3VibWl0dGluZyBmZXRjaGVyIHdhc1xuICAgIC8vIGRlbGV0ZWQsIG9ubHkgcHV0IGl0IGJhY2sgdG8gaWRsZSBpZiBpdCBoYXNuJ3QgYmVlbiBkZWxldGVkXG4gICAgaWYgKHN0YXRlLmZldGNoZXJzLmhhcyhrZXkpKSB7XG4gICAgICBsZXQgZG9uZUZldGNoZXIgPSBnZXREb25lRmV0Y2hlcihhY3Rpb25SZXN1bHQuZGF0YSk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgfVxuXG4gICAgYWJvcnRTdGFsZUZldGNoTG9hZHMobG9hZElkKTtcblxuICAgIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgaW4gYSBuYXZpZ2F0aW9uIGxvYWRpbmcgc3RhdGUgYW5kIHRoaXMgZmV0Y2hlciBpc1xuICAgIC8vIG1vcmUgcmVjZW50IHRoYW4gdGhlIG5hdmlnYXRpb24sIHdlIHdhbnQgdGhlIG5ld2VyIGRhdGEgc28gYWJvcnQgdGhlXG4gICAgLy8gbmF2aWdhdGlvbiBhbmQgY29tcGxldGUgaXQgd2l0aCB0aGUgZmV0Y2hlciBkYXRhXG4gICAgaWYgKFxuICAgICAgc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIgJiZcbiAgICAgIGxvYWRJZCA+IHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkXG4gICAgKSB7XG4gICAgICBpbnZhcmlhbnQocGVuZGluZ0FjdGlvbiwgXCJFeHBlY3RlZCBwZW5kaW5nIGFjdGlvblwiKTtcbiAgICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciAmJiBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuYWJvcnQoKTtcblxuICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKHN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24sIHtcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgbG9hZGVyRGF0YSxcbiAgICAgICAgZXJyb3JzLFxuICAgICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycyksXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb3RoZXJ3aXNlIGp1c3QgdXBkYXRlIHdpdGggdGhlIGZldGNoZXIgZGF0YSwgcHJlc2VydmluZyBhbnkgZXhpc3RpbmdcbiAgICAgIC8vIGxvYWRlckRhdGEgZm9yIGxvYWRlcnMgdGhhdCBkaWQgbm90IG5lZWQgdG8gcmVsb2FkLiAgV2UgaGF2ZSB0b1xuICAgICAgLy8gbWFudWFsbHkgbWVyZ2UgaGVyZSBzaW5jZSB3ZSBhcmVuJ3QgZ29pbmcgdGhyb3VnaCBjb21wbGV0ZU5hdmlnYXRpb25cbiAgICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgICAgZXJyb3JzLFxuICAgICAgICBsb2FkZXJEYXRhOiBtZXJnZUxvYWRlckRhdGEoXG4gICAgICAgICAgc3RhdGUubG9hZGVyRGF0YSxcbiAgICAgICAgICBsb2FkZXJEYXRhLFxuICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgZXJyb3JzXG4gICAgICAgICksXG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSxcbiAgICAgIH0pO1xuICAgICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIENhbGwgdGhlIG1hdGNoZWQgbG9hZGVyIGZvciBmZXRjaGVyLmxvYWQoKSwgaGFuZGxpbmcgcmVkaXJlY3RzLCBlcnJvcnMsIGV0Yy5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlRmV0Y2hlckxvYWRlcihcbiAgICBrZXk6IHN0cmluZyxcbiAgICByb3V0ZUlkOiBzdHJpbmcsXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIG1hdGNoOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoLFxuICAgIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgICBmbHVzaFN5bmM6IGJvb2xlYW4sXG4gICAgc3VibWlzc2lvbj86IFN1Ym1pc3Npb25cbiAgKSB7XG4gICAgbGV0IGV4aXN0aW5nRmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShcbiAgICAgIGtleSxcbiAgICAgIGdldExvYWRpbmdGZXRjaGVyKFxuICAgICAgICBzdWJtaXNzaW9uLFxuICAgICAgICBleGlzdGluZ0ZldGNoZXIgPyBleGlzdGluZ0ZldGNoZXIuZGF0YSA6IHVuZGVmaW5lZFxuICAgICAgKSxcbiAgICAgIHsgZmx1c2hTeW5jIH1cbiAgICApO1xuXG4gICAgLy8gQ2FsbCB0aGUgbG9hZGVyIGZvciB0aGlzIGZldGNoZXIgcm91dGUgbWF0Y2hcbiAgICBsZXQgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGxldCBmZXRjaFJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChcbiAgICAgIGluaXQuaGlzdG9yeSxcbiAgICAgIHBhdGgsXG4gICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgKTtcbiAgICBmZXRjaENvbnRyb2xsZXJzLnNldChrZXksIGFib3J0Q29udHJvbGxlcik7XG5cbiAgICBsZXQgb3JpZ2luYXRpbmdMb2FkSWQgPSBpbmNyZW1lbnRpbmdMb2FkSWQ7XG4gICAgbGV0IHJlc3VsdDogRGF0YVJlc3VsdCA9IGF3YWl0IGNhbGxMb2FkZXJPckFjdGlvbihcbiAgICAgIFwibG9hZGVyXCIsXG4gICAgICBmZXRjaFJlcXVlc3QsXG4gICAgICBtYXRjaCxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBtYW5pZmVzdCxcbiAgICAgIG1hcFJvdXRlUHJvcGVydGllcyxcbiAgICAgIGJhc2VuYW1lXG4gICAgKTtcblxuICAgIC8vIERlZmVycmVkIGlzbid0IHN1cHBvcnRlZCBmb3IgZmV0Y2hlciBsb2FkcywgYXdhaXQgZXZlcnl0aGluZyBhbmQgdHJlYXQgaXRcbiAgICAvLyBhcyBhIG5vcm1hbCBsb2FkLiAgcmVzb2x2ZURlZmVycmVkRGF0YSB3aWxsIHJldHVybiB1bmRlZmluZWQgaWYgdGhpc1xuICAgIC8vIGZldGNoZXIgZ2V0cyBhYm9ydGVkLCBzbyB3ZSBqdXN0IGxlYXZlIHJlc3VsdCB1bnRvdWNoZWQgYW5kIHNob3J0IGNpcmN1aXRcbiAgICAvLyBiZWxvdyBpZiB0aGF0IGhhcHBlbnNcbiAgICBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICByZXN1bHQgPVxuICAgICAgICAoYXdhaXQgcmVzb2x2ZURlZmVycmVkRGF0YShyZXN1bHQsIGZldGNoUmVxdWVzdC5zaWduYWwsIHRydWUpKSB8fFxuICAgICAgICByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gV2UgY2FuIGRlbGV0ZSB0aGlzIHNvIGxvbmcgYXMgd2Ugd2VyZW4ndCBhYm9ydGVkIGJ5IG91ciBvdXIgb3duIGZldGNoZXJcbiAgICAvLyByZS1sb2FkIHdoaWNoIHdvdWxkIGhhdmUgcHV0IF9uZXdfIGNvbnRyb2xsZXIgaXMgaW4gZmV0Y2hDb250cm9sbGVyc1xuICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmdldChrZXkpID09PSBhYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gICAgfVxuXG4gICAgaWYgKGZldGNoUmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChkZWxldGVkRmV0Y2hlcnMuaGFzKGtleSkpIHtcbiAgICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldERvbmVGZXRjaGVyKHVuZGVmaW5lZCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBsb2FkZXIgdGhyZXcgYSByZWRpcmVjdCBSZXNwb25zZSwgc3RhcnQgYSBuZXcgUkVQTEFDRSBuYXZpZ2F0aW9uXG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgaWYgKHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkID4gb3JpZ2luYXRpbmdMb2FkSWQpIHtcbiAgICAgICAgLy8gQSBuZXcgbmF2aWdhdGlvbiB3YXMga2lja2VkIG9mZiBhZnRlciBvdXIgbG9hZGVyIHN0YXJ0ZWQsIHNvIHRoYXRcbiAgICAgICAgLy8gc2hvdWxkIHRha2UgcHJlY2VkZW5jZSBvdmVyIHRoaXMgcmVkaXJlY3QgbmF2aWdhdGlvblxuICAgICAgICB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBnZXREb25lRmV0Y2hlcih1bmRlZmluZWQpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmV0Y2hSZWRpcmVjdElkcy5hZGQoa2V5KTtcbiAgICAgICAgYXdhaXQgc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24oc3RhdGUsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIGFueSBub24tcmVkaXJlY3QgZXJyb3JzIHRocm93blxuICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIHJlc3VsdC5lcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW52YXJpYW50KCFpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCksIFwiVW5oYW5kbGVkIGZldGNoZXIgZGVmZXJyZWQgZGF0YVwiKTtcblxuICAgIC8vIFB1dCB0aGUgZmV0Y2hlciBiYWNrIGludG8gYW4gaWRsZSBzdGF0ZVxuICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldERvbmVGZXRjaGVyKHJlc3VsdC5kYXRhKSk7XG4gIH1cblxuICAvKipcbiAgICogVXRpbGl0eSBmdW5jdGlvbiB0byBoYW5kbGUgcmVkaXJlY3RzIHJldHVybmVkIGZyb20gYW4gYWN0aW9uIG9yIGxvYWRlci5cbiAgICogTm9ybWFsbHksIGEgcmVkaXJlY3QgXCJyZXBsYWNlc1wiIHRoZSBuYXZpZ2F0aW9uIHRoYXQgdHJpZ2dlcmVkIGl0LiAgU28sIGZvclxuICAgKiBleGFtcGxlOlxuICAgKlxuICAgKiAgLSB1c2VyIGlzIG9uIC9hXG4gICAqICAtIHVzZXIgY2xpY2tzIGEgbGluayB0byAvYlxuICAgKiAgLSBsb2FkZXIgZm9yIC9iIHJlZGlyZWN0cyB0byAvY1xuICAgKlxuICAgKiBJbiBhIG5vbi1KUyBhcHAgdGhlIGJyb3dzZXIgd291bGQgdHJhY2sgdGhlIGluLWZsaWdodCBuYXZpZ2F0aW9uIHRvIC9iIGFuZFxuICAgKiB0aGVuIHJlcGxhY2UgaXQgd2l0aCAvYyB3aGVuIGl0IGVuY291bnRlcmVkIHRoZSByZWRpcmVjdCByZXNwb25zZS4gIEluXG4gICAqIHRoZSBlbmQgaXQgd291bGQgb25seSBldmVyIHVwZGF0ZSB0aGUgVVJMIGJhciB3aXRoIC9jLlxuICAgKlxuICAgKiBJbiBjbGllbnQtc2lkZSByb3V0aW5nIHVzaW5nIHB1c2hTdGF0ZS9yZXBsYWNlU3RhdGUsIHdlIGFpbSB0byBlbXVsYXRlXG4gICAqIHRoaXMgYmVoYXZpb3IgYW5kIHdlIGFsc28gZG8gbm90IHVwZGF0ZSBoaXN0b3J5IHVudGlsIHRoZSBlbmQgb2YgdGhlXG4gICAqIG5hdmlnYXRpb24gKGluY2x1ZGluZyBwcm9jZXNzZWQgcmVkaXJlY3RzKS4gIFRoaXMgbWVhbnMgdGhhdCB3ZSBuZXZlclxuICAgKiBhY3R1YWxseSB0b3VjaCBoaXN0b3J5IHVudGlsIHdlJ3ZlIHByb2Nlc3NlZCByZWRpcmVjdHMsIHNvIHdlIGp1c3QgdXNlXG4gICAqIHRoZSBoaXN0b3J5IGFjdGlvbiBmcm9tIHRoZSBvcmlnaW5hbCBuYXZpZ2F0aW9uIChQVVNIIG9yIFJFUExBQ0UpLlxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24oXG4gICAgc3RhdGU6IFJvdXRlclN0YXRlLFxuICAgIHJlZGlyZWN0OiBSZWRpcmVjdFJlc3VsdCxcbiAgICB7XG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgZmV0Y2hlclN1Ym1pc3Npb24sXG4gICAgICByZXBsYWNlLFxuICAgIH06IHtcbiAgICAgIHN1Ym1pc3Npb24/OiBTdWJtaXNzaW9uO1xuICAgICAgZmV0Y2hlclN1Ym1pc3Npb24/OiBTdWJtaXNzaW9uO1xuICAgICAgcmVwbGFjZT86IGJvb2xlYW47XG4gICAgfSA9IHt9XG4gICkge1xuICAgIGlmIChyZWRpcmVjdC5yZXZhbGlkYXRlKSB7XG4gICAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBsZXQgcmVkaXJlY3RMb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHN0YXRlLmxvY2F0aW9uLCByZWRpcmVjdC5sb2NhdGlvbiwge1xuICAgICAgX2lzUmVkaXJlY3Q6IHRydWUsXG4gICAgfSk7XG4gICAgaW52YXJpYW50KFxuICAgICAgcmVkaXJlY3RMb2NhdGlvbixcbiAgICAgIFwiRXhwZWN0ZWQgYSBsb2NhdGlvbiBvbiB0aGUgcmVkaXJlY3QgbmF2aWdhdGlvblwiXG4gICAgKTtcblxuICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgIGxldCBpc0RvY3VtZW50UmVsb2FkID0gZmFsc2U7XG5cbiAgICAgIGlmIChyZWRpcmVjdC5yZWxvYWREb2N1bWVudCkge1xuICAgICAgICAvLyBIYXJkIHJlbG9hZCBpZiB0aGUgcmVzcG9uc2UgY29udGFpbmVkIFgtUmVtaXgtUmVsb2FkLURvY3VtZW50XG4gICAgICAgIGlzRG9jdW1lbnRSZWxvYWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChBQlNPTFVURV9VUkxfUkVHRVgudGVzdChyZWRpcmVjdC5sb2NhdGlvbikpIHtcbiAgICAgICAgY29uc3QgdXJsID0gaW5pdC5oaXN0b3J5LmNyZWF0ZVVSTChyZWRpcmVjdC5sb2NhdGlvbik7XG4gICAgICAgIGlzRG9jdW1lbnRSZWxvYWQgPVxuICAgICAgICAgIC8vIEhhcmQgcmVsb2FkIGlmIGl0J3MgYW4gYWJzb2x1dGUgVVJMIHRvIGEgbmV3IG9yaWdpblxuICAgICAgICAgIHVybC5vcmlnaW4gIT09IHJvdXRlcldpbmRvdy5sb2NhdGlvbi5vcmlnaW4gfHxcbiAgICAgICAgICAvLyBIYXJkIHJlbG9hZCBpZiBpdCdzIGFuIGFic29sdXRlIFVSTCB0aGF0IGRvZXMgbm90IG1hdGNoIG91ciBiYXNlbmFtZVxuICAgICAgICAgIHN0cmlwQmFzZW5hbWUodXJsLnBhdGhuYW1lLCBiYXNlbmFtZSkgPT0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRG9jdW1lbnRSZWxvYWQpIHtcbiAgICAgICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgICAgICByb3V0ZXJXaW5kb3cubG9jYXRpb24ucmVwbGFjZShyZWRpcmVjdC5sb2NhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm91dGVyV2luZG93LmxvY2F0aW9uLmFzc2lnbihyZWRpcmVjdC5sb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBhYm9ydCBvbiByZWRpcmVjdHMsIHNpbmNlIHdlIGRvbid0IGRldGVjdCB0aGVcbiAgICAvLyByZWRpcmVjdCB1bnRpbCB0aGUgYWN0aW9uL2xvYWRlcnMgaGF2ZSBzZXR0bGVkXG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyID0gbnVsbDtcblxuICAgIGxldCByZWRpcmVjdEhpc3RvcnlBY3Rpb24gPVxuICAgICAgcmVwbGFjZSA9PT0gdHJ1ZSA/IEhpc3RvcnlBY3Rpb24uUmVwbGFjZSA6IEhpc3RvcnlBY3Rpb24uUHVzaDtcblxuICAgIC8vIFVzZSB0aGUgaW5jb21pbmcgc3VibWlzc2lvbiBpZiBwcm92aWRlZCwgZmFsbGJhY2sgb24gdGhlIGFjdGl2ZSBvbmUgaW5cbiAgICAvLyBzdGF0ZS5uYXZpZ2F0aW9uXG4gICAgbGV0IHsgZm9ybU1ldGhvZCwgZm9ybUFjdGlvbiwgZm9ybUVuY1R5cGUgfSA9IHN0YXRlLm5hdmlnYXRpb247XG4gICAgaWYgKFxuICAgICAgIXN1Ym1pc3Npb24gJiZcbiAgICAgICFmZXRjaGVyU3VibWlzc2lvbiAmJlxuICAgICAgZm9ybU1ldGhvZCAmJlxuICAgICAgZm9ybUFjdGlvbiAmJlxuICAgICAgZm9ybUVuY1R5cGVcbiAgICApIHtcbiAgICAgIHN1Ym1pc3Npb24gPSBnZXRTdWJtaXNzaW9uRnJvbU5hdmlnYXRpb24oc3RhdGUubmF2aWdhdGlvbik7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhpcyB3YXMgYSAzMDcvMzA4IHN1Ym1pc3Npb24gd2Ugd2FudCB0byBwcmVzZXJ2ZSB0aGUgSFRUUCBtZXRob2QgYW5kXG4gICAgLy8gcmUtc3VibWl0IHRoZSBHRVQvUE9TVC9QVVQvUEFUQ0gvREVMRVRFIGFzIGEgc3VibWlzc2lvbiBuYXZpZ2F0aW9uIHRvIHRoZVxuICAgIC8vIHJlZGlyZWN0ZWQgbG9jYXRpb25cbiAgICBsZXQgYWN0aXZlU3VibWlzc2lvbiA9IHN1Ym1pc3Npb24gfHwgZmV0Y2hlclN1Ym1pc3Npb247XG4gICAgaWYgKFxuICAgICAgcmVkaXJlY3RQcmVzZXJ2ZU1ldGhvZFN0YXR1c0NvZGVzLmhhcyhyZWRpcmVjdC5zdGF0dXMpICYmXG4gICAgICBhY3RpdmVTdWJtaXNzaW9uICYmXG4gICAgICBpc011dGF0aW9uTWV0aG9kKGFjdGl2ZVN1Ym1pc3Npb24uZm9ybU1ldGhvZClcbiAgICApIHtcbiAgICAgIGF3YWl0IHN0YXJ0TmF2aWdhdGlvbihyZWRpcmVjdEhpc3RvcnlBY3Rpb24sIHJlZGlyZWN0TG9jYXRpb24sIHtcbiAgICAgICAgc3VibWlzc2lvbjoge1xuICAgICAgICAgIC4uLmFjdGl2ZVN1Ym1pc3Npb24sXG4gICAgICAgICAgZm9ybUFjdGlvbjogcmVkaXJlY3QubG9jYXRpb24sXG4gICAgICAgIH0sXG4gICAgICAgIC8vIFByZXNlcnZlIHRoaXMgZmxhZyBhY3Jvc3MgcmVkaXJlY3RzXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgbmF2aWdhdGlvbiBzdWJtaXNzaW9uLCB3ZSB3aWxsIHByZXNlcnZlIGl0IHRocm91Z2ggdGhlXG4gICAgICAvLyByZWRpcmVjdCBuYXZpZ2F0aW9uXG4gICAgICBsZXQgb3ZlcnJpZGVOYXZpZ2F0aW9uID0gZ2V0TG9hZGluZ05hdmlnYXRpb24oXG4gICAgICAgIHJlZGlyZWN0TG9jYXRpb24sXG4gICAgICAgIHN1Ym1pc3Npb25cbiAgICAgICk7XG4gICAgICBhd2FpdCBzdGFydE5hdmlnYXRpb24ocmVkaXJlY3RIaXN0b3J5QWN0aW9uLCByZWRpcmVjdExvY2F0aW9uLCB7XG4gICAgICAgIG92ZXJyaWRlTmF2aWdhdGlvbixcbiAgICAgICAgLy8gU2VuZCBmZXRjaGVyIHN1Ym1pc3Npb25zIHRocm91Z2ggZm9yIHNob3VsZFJldmFsaWRhdGVcbiAgICAgICAgZmV0Y2hlclN1Ym1pc3Npb24sXG4gICAgICAgIC8vIFByZXNlcnZlIHRoaXMgZmxhZyBhY3Jvc3MgcmVkaXJlY3RzXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YShcbiAgICBjdXJyZW50TWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICAgIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgICBtYXRjaGVzVG9Mb2FkOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gICAgZmV0Y2hlcnNUb0xvYWQ6IFJldmFsaWRhdGluZ0ZldGNoZXJbXSxcbiAgICByZXF1ZXN0OiBSZXF1ZXN0XG4gICkge1xuICAgIC8vIENhbGwgYWxsIG5hdmlnYXRpb24gbG9hZGVycyBhbmQgcmV2YWxpZGF0aW5nIGZldGNoZXIgbG9hZGVycyBpbiBwYXJhbGxlbCxcbiAgICAvLyB0aGVuIHNsaWNlIG9mZiB0aGUgcmVzdWx0cyBpbnRvIHNlcGFyYXRlIGFycmF5cyBzbyB3ZSBjYW4gaGFuZGxlIHRoZW1cbiAgICAvLyBhY2NvcmRpbmdseVxuICAgIGxldCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgLi4ubWF0Y2hlc1RvTG9hZC5tYXAoKG1hdGNoKSA9PlxuICAgICAgICBjYWxsTG9hZGVyT3JBY3Rpb24oXG4gICAgICAgICAgXCJsb2FkZXJcIixcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgbWFuaWZlc3QsXG4gICAgICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzLFxuICAgICAgICAgIGJhc2VuYW1lXG4gICAgICAgIClcbiAgICAgICksXG4gICAgICAuLi5mZXRjaGVyc1RvTG9hZC5tYXAoKGYpID0+IHtcbiAgICAgICAgaWYgKGYubWF0Y2hlcyAmJiBmLm1hdGNoICYmIGYuY29udHJvbGxlcikge1xuICAgICAgICAgIHJldHVybiBjYWxsTG9hZGVyT3JBY3Rpb24oXG4gICAgICAgICAgICBcImxvYWRlclwiLFxuICAgICAgICAgICAgY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoaW5pdC5oaXN0b3J5LCBmLnBhdGgsIGYuY29udHJvbGxlci5zaWduYWwpLFxuICAgICAgICAgICAgZi5tYXRjaCxcbiAgICAgICAgICAgIGYubWF0Y2hlcyxcbiAgICAgICAgICAgIG1hbmlmZXN0LFxuICAgICAgICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgYmFzZW5hbWVcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBlcnJvcjogRXJyb3JSZXN1bHQgPSB7XG4gICAgICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmVycm9yLFxuICAgICAgICAgICAgZXJyb3I6IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7IHBhdGhuYW1lOiBmLnBhdGggfSksXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgIF0pO1xuICAgIGxldCBsb2FkZXJSZXN1bHRzID0gcmVzdWx0cy5zbGljZSgwLCBtYXRjaGVzVG9Mb2FkLmxlbmd0aCk7XG4gICAgbGV0IGZldGNoZXJSZXN1bHRzID0gcmVzdWx0cy5zbGljZShtYXRjaGVzVG9Mb2FkLmxlbmd0aCk7XG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICByZXNvbHZlRGVmZXJyZWRSZXN1bHRzKFxuICAgICAgICBjdXJyZW50TWF0Y2hlcyxcbiAgICAgICAgbWF0Y2hlc1RvTG9hZCxcbiAgICAgICAgbG9hZGVyUmVzdWx0cyxcbiAgICAgICAgbG9hZGVyUmVzdWx0cy5tYXAoKCkgPT4gcmVxdWVzdC5zaWduYWwpLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgc3RhdGUubG9hZGVyRGF0YVxuICAgICAgKSxcbiAgICAgIHJlc29sdmVEZWZlcnJlZFJlc3VsdHMoXG4gICAgICAgIGN1cnJlbnRNYXRjaGVzLFxuICAgICAgICBmZXRjaGVyc1RvTG9hZC5tYXAoKGYpID0+IGYubWF0Y2gpLFxuICAgICAgICBmZXRjaGVyUmVzdWx0cyxcbiAgICAgICAgZmV0Y2hlcnNUb0xvYWQubWFwKChmKSA9PiAoZi5jb250cm9sbGVyID8gZi5jb250cm9sbGVyLnNpZ25hbCA6IG51bGwpKSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKSxcbiAgICBdKTtcblxuICAgIHJldHVybiB7IHJlc3VsdHMsIGxvYWRlclJlc3VsdHMsIGZldGNoZXJSZXN1bHRzIH07XG4gIH1cblxuICBmdW5jdGlvbiBpbnRlcnJ1cHRBY3RpdmVMb2FkcygpIHtcbiAgICAvLyBFdmVyeSBpbnRlcnJ1cHRpb24gdHJpZ2dlcnMgYSByZXZhbGlkYXRpb25cbiAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gdHJ1ZTtcblxuICAgIC8vIENhbmNlbCBwZW5kaW5nIHJvdXRlLWxldmVsIGRlZmVycmVkcyBhbmQgbWFyayBjYW5jZWxsZWQgcm91dGVzIGZvclxuICAgIC8vIHJldmFsaWRhdGlvblxuICAgIGNhbmNlbGxlZERlZmVycmVkUm91dGVzLnB1c2goLi4uY2FuY2VsQWN0aXZlRGVmZXJyZWRzKCkpO1xuXG4gICAgLy8gQWJvcnQgaW4tZmxpZ2h0IGZldGNoZXIgbG9hZHNcbiAgICBmZXRjaExvYWRNYXRjaGVzLmZvckVhY2goKF8sIGtleSkgPT4ge1xuICAgICAgaWYgKGZldGNoQ29udHJvbGxlcnMuaGFzKGtleSkpIHtcbiAgICAgICAgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLnB1c2goa2V5KTtcbiAgICAgICAgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGZXRjaGVyU3RhdGUoXG4gICAga2V5OiBzdHJpbmcsXG4gICAgZmV0Y2hlcjogRmV0Y2hlcixcbiAgICBvcHRzOiB7IGZsdXNoU3luYz86IGJvb2xlYW4gfSA9IHt9XG4gICkge1xuICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGZldGNoZXIpO1xuICAgIHVwZGF0ZVN0YXRlKFxuICAgICAgeyBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgfSxcbiAgICAgIHsgZmx1c2hTeW5jOiAob3B0cyAmJiBvcHRzLmZsdXNoU3luYykgPT09IHRydWUgfVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRGZXRjaGVyRXJyb3IoXG4gICAga2V5OiBzdHJpbmcsXG4gICAgcm91dGVJZDogc3RyaW5nLFxuICAgIGVycm9yOiBhbnksXG4gICAgb3B0czogeyBmbHVzaFN5bmM/OiBib29sZWFuIH0gPSB7fVxuICApIHtcbiAgICBsZXQgYm91bmRhcnlNYXRjaCA9IGZpbmROZWFyZXN0Qm91bmRhcnkoc3RhdGUubWF0Y2hlcywgcm91dGVJZCk7XG4gICAgZGVsZXRlRmV0Y2hlcihrZXkpO1xuICAgIHVwZGF0ZVN0YXRlKFxuICAgICAge1xuICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICBbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF06IGVycm9yLFxuICAgICAgICB9LFxuICAgICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycyksXG4gICAgICB9LFxuICAgICAgeyBmbHVzaFN5bmM6IChvcHRzICYmIG9wdHMuZmx1c2hTeW5jKSA9PT0gdHJ1ZSB9XG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEZldGNoZXI8VERhdGEgPSBhbnk+KGtleTogc3RyaW5nKTogRmV0Y2hlcjxURGF0YT4ge1xuICAgIGlmIChmdXR1cmUudjdfZmV0Y2hlclBlcnNpc3QpIHtcbiAgICAgIGFjdGl2ZUZldGNoZXJzLnNldChrZXksIChhY3RpdmVGZXRjaGVycy5nZXQoa2V5KSB8fCAwKSArIDEpO1xuICAgICAgLy8gSWYgdGhpcyBmZXRjaGVyIHdhcyBwcmV2aW91c2x5IG1hcmtlZCBmb3IgZGVsZXRpb24sIHVubWFyayBpdCBzaW5jZSB3ZVxuICAgICAgLy8gaGF2ZSBhIG5ldyBpbnN0YW5jZVxuICAgICAgaWYgKGRlbGV0ZWRGZXRjaGVycy5oYXMoa2V5KSkge1xuICAgICAgICBkZWxldGVkRmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KSB8fCBJRExFX0ZFVENIRVI7XG4gIH1cblxuICBmdW5jdGlvbiBkZWxldGVGZXRjaGVyKGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICAvLyBEb24ndCBhYm9ydCB0aGUgY29udHJvbGxlciBpZiB0aGlzIGlzIGEgZGVsZXRpb24gb2YgYSBmZXRjaGVyLnN1Ym1pdCgpXG4gICAgLy8gaW4gaXQncyBsb2FkaW5nIHBoYXNlIHNpbmNlIC0gd2UgZG9uJ3Qgd2FudCB0byBhYm9ydCB0aGUgY29ycmVzcG9uZGluZ1xuICAgIC8vIHJldmFsaWRhdGlvbiBhbmQgd2FudCB0aGVtIHRvIGNvbXBsZXRlIGFuZCBsYW5kXG4gICAgaWYgKFxuICAgICAgZmV0Y2hDb250cm9sbGVycy5oYXMoa2V5KSAmJlxuICAgICAgIShmZXRjaGVyICYmIGZldGNoZXIuc3RhdGUgPT09IFwibG9hZGluZ1wiICYmIGZldGNoUmVsb2FkSWRzLmhhcyhrZXkpKVxuICAgICkge1xuICAgICAgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgfVxuICAgIGZldGNoTG9hZE1hdGNoZXMuZGVsZXRlKGtleSk7XG4gICAgZmV0Y2hSZWxvYWRJZHMuZGVsZXRlKGtleSk7XG4gICAgZmV0Y2hSZWRpcmVjdElkcy5kZWxldGUoa2V5KTtcbiAgICBkZWxldGVkRmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gICAgc3RhdGUuZmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWxldGVGZXRjaGVyQW5kVXBkYXRlU3RhdGUoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoZnV0dXJlLnY3X2ZldGNoZXJQZXJzaXN0KSB7XG4gICAgICBsZXQgY291bnQgPSAoYWN0aXZlRmV0Y2hlcnMuZ2V0KGtleSkgfHwgMCkgLSAxO1xuICAgICAgaWYgKGNvdW50IDw9IDApIHtcbiAgICAgICAgYWN0aXZlRmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gICAgICAgIGRlbGV0ZWRGZXRjaGVycy5hZGQoa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2ZUZldGNoZXJzLnNldChrZXksIGNvdW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlRmV0Y2hlcihrZXkpO1xuICAgIH1cbiAgICB1cGRhdGVTdGF0ZSh7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFib3J0RmV0Y2hlcihrZXk6IHN0cmluZykge1xuICAgIGxldCBjb250cm9sbGVyID0gZmV0Y2hDb250cm9sbGVycy5nZXQoa2V5KTtcbiAgICBpbnZhcmlhbnQoY29udHJvbGxlciwgYEV4cGVjdGVkIGZldGNoIGNvbnRyb2xsZXI6ICR7a2V5fWApO1xuICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFya0ZldGNoZXJzRG9uZShrZXlzOiBzdHJpbmdbXSkge1xuICAgIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XG4gICAgICBsZXQgZmV0Y2hlciA9IGdldEZldGNoZXIoa2V5KTtcbiAgICAgIGxldCBkb25lRmV0Y2hlciA9IGdldERvbmVGZXRjaGVyKGZldGNoZXIuZGF0YSk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya0ZldGNoUmVkaXJlY3RzRG9uZSgpOiBib29sZWFuIHtcbiAgICBsZXQgZG9uZUtleXMgPSBbXTtcbiAgICBsZXQgdXBkYXRlZEZldGNoZXJzID0gZmFsc2U7XG4gICAgZm9yIChsZXQga2V5IG9mIGZldGNoUmVkaXJlY3RJZHMpIHtcbiAgICAgIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgICBpbnZhcmlhbnQoZmV0Y2hlciwgYEV4cGVjdGVkIGZldGNoZXI6ICR7a2V5fWApO1xuICAgICAgaWYgKGZldGNoZXIuc3RhdGUgPT09IFwibG9hZGluZ1wiKSB7XG4gICAgICAgIGZldGNoUmVkaXJlY3RJZHMuZGVsZXRlKGtleSk7XG4gICAgICAgIGRvbmVLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgdXBkYXRlZEZldGNoZXJzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWFya0ZldGNoZXJzRG9uZShkb25lS2V5cyk7XG4gICAgcmV0dXJuIHVwZGF0ZWRGZXRjaGVycztcbiAgfVxuXG4gIGZ1bmN0aW9uIGFib3J0U3RhbGVGZXRjaExvYWRzKGxhbmRlZElkOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBsZXQgeWVldGVkS2V5cyA9IFtdO1xuICAgIGZvciAobGV0IFtrZXksIGlkXSBvZiBmZXRjaFJlbG9hZElkcykge1xuICAgICAgaWYgKGlkIDwgbGFuZGVkSWQpIHtcbiAgICAgICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICAgICAgaW52YXJpYW50KGZldGNoZXIsIGBFeHBlY3RlZCBmZXRjaGVyOiAke2tleX1gKTtcbiAgICAgICAgaWYgKGZldGNoZXIuc3RhdGUgPT09IFwibG9hZGluZ1wiKSB7XG4gICAgICAgICAgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgICAgICAgZmV0Y2hSZWxvYWRJZHMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgeWVldGVkS2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbWFya0ZldGNoZXJzRG9uZSh5ZWV0ZWRLZXlzKTtcbiAgICByZXR1cm4geWVldGVkS2V5cy5sZW5ndGggPiAwO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QmxvY2tlcihrZXk6IHN0cmluZywgZm46IEJsb2NrZXJGdW5jdGlvbikge1xuICAgIGxldCBibG9ja2VyOiBCbG9ja2VyID0gc3RhdGUuYmxvY2tlcnMuZ2V0KGtleSkgfHwgSURMRV9CTE9DS0VSO1xuXG4gICAgaWYgKGJsb2NrZXJGdW5jdGlvbnMuZ2V0KGtleSkgIT09IGZuKSB7XG4gICAgICBibG9ja2VyRnVuY3Rpb25zLnNldChrZXksIGZuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmxvY2tlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZUJsb2NrZXIoa2V5OiBzdHJpbmcpIHtcbiAgICBzdGF0ZS5ibG9ja2Vycy5kZWxldGUoa2V5KTtcbiAgICBibG9ja2VyRnVuY3Rpb25zLmRlbGV0ZShrZXkpO1xuICB9XG5cbiAgLy8gVXRpbGl0eSBmdW5jdGlvbiB0byB1cGRhdGUgYmxvY2tlcnMsIGVuc3VyaW5nIHZhbGlkIHN0YXRlIHRyYW5zaXRpb25zXG4gIGZ1bmN0aW9uIHVwZGF0ZUJsb2NrZXIoa2V5OiBzdHJpbmcsIG5ld0Jsb2NrZXI6IEJsb2NrZXIpIHtcbiAgICBsZXQgYmxvY2tlciA9IHN0YXRlLmJsb2NrZXJzLmdldChrZXkpIHx8IElETEVfQkxPQ0tFUjtcblxuICAgIC8vIFBvb3IgbWFucyBzdGF0ZSBtYWNoaW5lIDopXG4gICAgLy8gaHR0cHM6Ly9tZXJtYWlkLmxpdmUvZWRpdCNwYWtvOmVOcVZrYzlPd3pBTXhsOGw4bm5qQVlyRXRESU9IRUJJZ3d2S0pUUmVHeTNfbERwSXFPMjdrNmF3TUcwWGNyTGxuejg3bndkb25FU29nS1hYQnVFNzlycTc1WFpPMy15SGRzMFJKVnV2NzBZclBsVXJDRWUySGZyT1JTM3J1YnFaZnVodHBnNUM5d2s1dFo0VktjUlVxODhxOVo4UlMwLTQ4Y0UxaUhKa0wwdWdiSHVGTHVzOUw2c3BaeThuWDlNUDJDTmRvbVZhcG9zcXUzZkdheVQ4VDgtakpRd2hlcG9fVXRwZ0JRYURFVW9tMDRkWmhBTjFhSkJEbFVLSkJ4RTFjZUIyU21qME1sbi1JQlc1QUZVMmR3VWlrdHRfMlFhcTJkQmZhS2RFdXA4NVVWN1lkLWRLamxua2FibDJQdnIwRFRrVHJlTVxuICAgIGludmFyaWFudChcbiAgICAgIChibG9ja2VyLnN0YXRlID09PSBcInVuYmxvY2tlZFwiICYmIG5ld0Jsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiKSB8fFxuICAgICAgICAoYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIpIHx8XG4gICAgICAgIChibG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIiAmJiBuZXdCbG9ja2VyLnN0YXRlID09PSBcInByb2NlZWRpbmdcIikgfHxcbiAgICAgICAgKGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiICYmIG5ld0Jsb2NrZXIuc3RhdGUgPT09IFwidW5ibG9ja2VkXCIpIHx8XG4gICAgICAgIChibG9ja2VyLnN0YXRlID09PSBcInByb2NlZWRpbmdcIiAmJiBuZXdCbG9ja2VyLnN0YXRlID09PSBcInVuYmxvY2tlZFwiKSxcbiAgICAgIGBJbnZhbGlkIGJsb2NrZXIgc3RhdGUgdHJhbnNpdGlvbjogJHtibG9ja2VyLnN0YXRlfSAtPiAke25ld0Jsb2NrZXIuc3RhdGV9YFxuICAgICk7XG5cbiAgICBsZXQgYmxvY2tlcnMgPSBuZXcgTWFwKHN0YXRlLmJsb2NrZXJzKTtcbiAgICBibG9ja2Vycy5zZXQoa2V5LCBuZXdCbG9ja2VyKTtcbiAgICB1cGRhdGVTdGF0ZSh7IGJsb2NrZXJzIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkQmxvY2tOYXZpZ2F0aW9uKHtcbiAgICBjdXJyZW50TG9jYXRpb24sXG4gICAgbmV4dExvY2F0aW9uLFxuICAgIGhpc3RvcnlBY3Rpb24sXG4gIH06IHtcbiAgICBjdXJyZW50TG9jYXRpb246IExvY2F0aW9uO1xuICAgIG5leHRMb2NhdGlvbjogTG9jYXRpb247XG4gICAgaGlzdG9yeUFjdGlvbjogSGlzdG9yeUFjdGlvbjtcbiAgfSk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKGJsb2NrZXJGdW5jdGlvbnMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFdlIG9ueSBzdXBwb3J0IGEgc2luZ2xlIGFjdGl2ZSBibG9ja2VyIGF0IHRoZSBtb21lbnQgc2luY2Ugd2UgZG9uJ3QgaGF2ZVxuICAgIC8vIGFueSBjb21wZWxsaW5nIHVzZSBjYXNlcyBmb3IgbXVsdGktYmxvY2tlciB5ZXRcbiAgICBpZiAoYmxvY2tlckZ1bmN0aW9ucy5zaXplID4gMSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgXCJBIHJvdXRlciBvbmx5IHN1cHBvcnRzIG9uZSBibG9ja2VyIGF0IGEgdGltZVwiKTtcbiAgICB9XG5cbiAgICBsZXQgZW50cmllcyA9IEFycmF5LmZyb20oYmxvY2tlckZ1bmN0aW9ucy5lbnRyaWVzKCkpO1xuICAgIGxldCBbYmxvY2tlcktleSwgYmxvY2tlckZ1bmN0aW9uXSA9IGVudHJpZXNbZW50cmllcy5sZW5ndGggLSAxXTtcbiAgICBsZXQgYmxvY2tlciA9IHN0YXRlLmJsb2NrZXJzLmdldChibG9ja2VyS2V5KTtcblxuICAgIGlmIChibG9ja2VyICYmIGJsb2NrZXIuc3RhdGUgPT09IFwicHJvY2VlZGluZ1wiKSB7XG4gICAgICAvLyBJZiB0aGUgYmxvY2tlciBpcyBjdXJyZW50bHkgcHJvY2VlZGluZywgd2UgZG9uJ3QgbmVlZCB0byByZS1jaGVja1xuICAgICAgLy8gaXQgYW5kIGNhbiBsZXQgdGhpcyBuYXZpZ2F0aW9uIGNvbnRpbnVlXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQXQgdGhpcyBwb2ludCwgd2Uga25vdyB3ZSdyZSB1bmJsb2NrZWQvYmxvY2tlZCBzbyB3ZSBuZWVkIHRvIGNoZWNrIHRoZVxuICAgIC8vIHVzZXItcHJvdmlkZWQgYmxvY2tlciBmdW5jdGlvblxuICAgIGlmIChibG9ja2VyRnVuY3Rpb24oeyBjdXJyZW50TG9jYXRpb24sIG5leHRMb2NhdGlvbiwgaGlzdG9yeUFjdGlvbiB9KSkge1xuICAgICAgcmV0dXJuIGJsb2NrZXJLZXk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsQWN0aXZlRGVmZXJyZWRzKFxuICAgIHByZWRpY2F0ZT86IChyb3V0ZUlkOiBzdHJpbmcpID0+IGJvb2xlYW5cbiAgKTogc3RyaW5nW10ge1xuICAgIGxldCBjYW5jZWxsZWRSb3V0ZUlkczogc3RyaW5nW10gPSBbXTtcbiAgICBhY3RpdmVEZWZlcnJlZHMuZm9yRWFjaCgoZGZkLCByb3V0ZUlkKSA9PiB7XG4gICAgICBpZiAoIXByZWRpY2F0ZSB8fCBwcmVkaWNhdGUocm91dGVJZCkpIHtcbiAgICAgICAgLy8gQ2FuY2VsIHRoZSBkZWZlcnJlZCAtIGJ1dCBkbyBub3QgcmVtb3ZlIGZyb20gYWN0aXZlRGVmZXJyZWRzIGhlcmUgLVxuICAgICAgICAvLyB3ZSByZWx5IG9uIHRoZSBzdWJzY3JpYmVycyB0byBkbyB0aGF0IHNvIG91ciB0ZXN0cyBjYW4gYXNzZXJ0IHByb3BlclxuICAgICAgICAvLyBjbGVhbnVwIHZpYSBfaW50ZXJuYWxBY3RpdmVEZWZlcnJlZHNcbiAgICAgICAgZGZkLmNhbmNlbCgpO1xuICAgICAgICBjYW5jZWxsZWRSb3V0ZUlkcy5wdXNoKHJvdXRlSWQpO1xuICAgICAgICBhY3RpdmVEZWZlcnJlZHMuZGVsZXRlKHJvdXRlSWQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjYW5jZWxsZWRSb3V0ZUlkcztcbiAgfVxuXG4gIC8vIE9wdCBpbiB0byBjYXB0dXJpbmcgYW5kIHJlcG9ydGluZyBzY3JvbGwgcG9zaXRpb25zIGR1cmluZyBuYXZpZ2F0aW9ucyxcbiAgLy8gdXNlZCBieSB0aGUgPFNjcm9sbFJlc3RvcmF0aW9uPiBjb21wb25lbnRcbiAgZnVuY3Rpb24gZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24oXG4gICAgcG9zaXRpb25zOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+LFxuICAgIGdldFBvc2l0aW9uOiBHZXRTY3JvbGxQb3NpdGlvbkZ1bmN0aW9uLFxuICAgIGdldEtleT86IEdldFNjcm9sbFJlc3RvcmF0aW9uS2V5RnVuY3Rpb25cbiAgKSB7XG4gICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnMgPSBwb3NpdGlvbnM7XG4gICAgZ2V0U2Nyb2xsUG9zaXRpb24gPSBnZXRQb3NpdGlvbjtcbiAgICBnZXRTY3JvbGxSZXN0b3JhdGlvbktleSA9IGdldEtleSB8fCBudWxsO1xuXG4gICAgLy8gUGVyZm9ybSBpbml0aWFsIGh5ZHJhdGlvbiBzY3JvbGwgcmVzdG9yYXRpb24sIHNpbmNlIHdlIG1pc3MgdGhlIGJvYXQgb25cbiAgICAvLyB0aGUgaW5pdGlhbCB1cGRhdGVTdGF0ZSgpIGJlY2F1c2Ugd2UndmUgbm90IHlldCByZW5kZXJlZCA8U2Nyb2xsUmVzdG9yYXRpb24vPlxuICAgIC8vIGFuZCB0aGVyZWZvcmUgaGF2ZSBubyBzYXZlZFNjcm9sbFBvc2l0aW9ucyBhdmFpbGFibGVcbiAgICBpZiAoIWluaXRpYWxTY3JvbGxSZXN0b3JlZCAmJiBzdGF0ZS5uYXZpZ2F0aW9uID09PSBJRExFX05BVklHQVRJT04pIHtcbiAgICAgIGluaXRpYWxTY3JvbGxSZXN0b3JlZCA9IHRydWU7XG4gICAgICBsZXQgeSA9IGdldFNhdmVkU2Nyb2xsUG9zaXRpb24oc3RhdGUubG9jYXRpb24sIHN0YXRlLm1hdGNoZXMpO1xuICAgICAgaWYgKHkgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVTdGF0ZSh7IHJlc3RvcmVTY3JvbGxQb3NpdGlvbjogeSB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnMgPSBudWxsO1xuICAgICAgZ2V0U2Nyb2xsUG9zaXRpb24gPSBudWxsO1xuICAgICAgZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkgPSBudWxsO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTY3JvbGxLZXkobG9jYXRpb246IExvY2F0aW9uLCBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10pIHtcbiAgICBpZiAoZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkpIHtcbiAgICAgIGxldCBrZXkgPSBnZXRTY3JvbGxSZXN0b3JhdGlvbktleShcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIG1hdGNoZXMubWFwKChtKSA9PiBjb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaChtLCBzdGF0ZS5sb2FkZXJEYXRhKSlcbiAgICAgICk7XG4gICAgICByZXR1cm4ga2V5IHx8IGxvY2F0aW9uLmtleTtcbiAgICB9XG4gICAgcmV0dXJuIGxvY2F0aW9uLmtleTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNhdmVTY3JvbGxQb3NpdGlvbihcbiAgICBsb2NhdGlvbjogTG9jYXRpb24sXG4gICAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdXG4gICk6IHZvaWQge1xuICAgIGlmIChzYXZlZFNjcm9sbFBvc2l0aW9ucyAmJiBnZXRTY3JvbGxQb3NpdGlvbikge1xuICAgICAgbGV0IGtleSA9IGdldFNjcm9sbEtleShsb2NhdGlvbiwgbWF0Y2hlcyk7XG4gICAgICBzYXZlZFNjcm9sbFBvc2l0aW9uc1trZXldID0gZ2V0U2Nyb2xsUG9zaXRpb24oKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTYXZlZFNjcm9sbFBvc2l0aW9uKFxuICAgIGxvY2F0aW9uOiBMb2NhdGlvbixcbiAgICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW11cbiAgKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgaWYgKHNhdmVkU2Nyb2xsUG9zaXRpb25zKSB7XG4gICAgICBsZXQga2V5ID0gZ2V0U2Nyb2xsS2V5KGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICAgIGxldCB5ID0gc2F2ZWRTY3JvbGxQb3NpdGlvbnNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgeSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4geTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBfaW50ZXJuYWxTZXRSb3V0ZXMobmV3Um91dGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdFtdKSB7XG4gICAgbWFuaWZlc3QgPSB7fTtcbiAgICBpbkZsaWdodERhdGFSb3V0ZXMgPSBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKFxuICAgICAgbmV3Um91dGVzLFxuICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgbWFuaWZlc3RcbiAgICApO1xuICB9XG5cbiAgcm91dGVyID0ge1xuICAgIGdldCBiYXNlbmFtZSgpIHtcbiAgICAgIHJldHVybiBiYXNlbmFtZTtcbiAgICB9LFxuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LFxuICAgIGdldCByb3V0ZXMoKSB7XG4gICAgICByZXR1cm4gZGF0YVJvdXRlcztcbiAgICB9LFxuICAgIGdldCB3aW5kb3coKSB7XG4gICAgICByZXR1cm4gcm91dGVyV2luZG93O1xuICAgIH0sXG4gICAgaW5pdGlhbGl6ZSxcbiAgICBzdWJzY3JpYmUsXG4gICAgZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24sXG4gICAgbmF2aWdhdGUsXG4gICAgZmV0Y2gsXG4gICAgcmV2YWxpZGF0ZSxcbiAgICAvLyBQYXNzdGhyb3VnaCB0byBoaXN0b3J5LWF3YXJlIGNyZWF0ZUhyZWYgdXNlZCBieSB1c2VIcmVmIHNvIHdlIGdldCBwcm9wZXJcbiAgICAvLyBoYXNoLWF3YXJlIFVSTHMgaW4gRE9NIHBhdGhzXG4gICAgY3JlYXRlSHJlZjogKHRvOiBUbykgPT4gaW5pdC5oaXN0b3J5LmNyZWF0ZUhyZWYodG8pLFxuICAgIGVuY29kZUxvY2F0aW9uOiAodG86IFRvKSA9PiBpbml0Lmhpc3RvcnkuZW5jb2RlTG9jYXRpb24odG8pLFxuICAgIGdldEZldGNoZXIsXG4gICAgZGVsZXRlRmV0Y2hlcjogZGVsZXRlRmV0Y2hlckFuZFVwZGF0ZVN0YXRlLFxuICAgIGRpc3Bvc2UsXG4gICAgZ2V0QmxvY2tlcixcbiAgICBkZWxldGVCbG9ja2VyLFxuICAgIF9pbnRlcm5hbEZldGNoQ29udHJvbGxlcnM6IGZldGNoQ29udHJvbGxlcnMsXG4gICAgX2ludGVybmFsQWN0aXZlRGVmZXJyZWRzOiBhY3RpdmVEZWZlcnJlZHMsXG4gICAgLy8gVE9ETzogUmVtb3ZlIHNldFJvdXRlcywgaXQncyB0ZW1wb3JhcnkgdG8gYXZvaWQgZGVhbGluZyB3aXRoXG4gICAgLy8gdXBkYXRpbmcgdGhlIHRyZWUgd2hpbGUgdmFsaWRhdGluZyB0aGUgdXBkYXRlIGFsZ29yaXRobS5cbiAgICBfaW50ZXJuYWxTZXRSb3V0ZXMsXG4gIH07XG5cbiAgcmV0dXJuIHJvdXRlcjtcbn1cbi8vI2VuZHJlZ2lvblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIGNyZWF0ZVN0YXRpY0hhbmRsZXJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmV4cG9ydCBjb25zdCBVTlNBRkVfREVGRVJSRURfU1lNQk9MID0gU3ltYm9sKFwiZGVmZXJyZWRcIik7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlU3RhdGljSGFuZGxlck9wdGlvbnMge1xuICBiYXNlbmFtZT86IHN0cmluZztcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgbWFwUm91dGVQcm9wZXJ0aWVzYCBpbnN0ZWFkXG4gICAqL1xuICBkZXRlY3RFcnJvckJvdW5kYXJ5PzogRGV0ZWN0RXJyb3JCb3VuZGFyeUZ1bmN0aW9uO1xuICBtYXBSb3V0ZVByb3BlcnRpZXM/OiBNYXBSb3V0ZVByb3BlcnRpZXNGdW5jdGlvbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN0YXRpY0hhbmRsZXIoXG4gIHJvdXRlczogQWdub3N0aWNSb3V0ZU9iamVjdFtdLFxuICBvcHRzPzogQ3JlYXRlU3RhdGljSGFuZGxlck9wdGlvbnNcbik6IFN0YXRpY0hhbmRsZXIge1xuICBpbnZhcmlhbnQoXG4gICAgcm91dGVzLmxlbmd0aCA+IDAsXG4gICAgXCJZb3UgbXVzdCBwcm92aWRlIGEgbm9uLWVtcHR5IHJvdXRlcyBhcnJheSB0byBjcmVhdGVTdGF0aWNIYW5kbGVyXCJcbiAgKTtcblxuICBsZXQgbWFuaWZlc3Q6IFJvdXRlTWFuaWZlc3QgPSB7fTtcbiAgbGV0IGJhc2VuYW1lID0gKG9wdHMgPyBvcHRzLmJhc2VuYW1lIDogbnVsbCkgfHwgXCIvXCI7XG4gIGxldCBtYXBSb3V0ZVByb3BlcnRpZXM6IE1hcFJvdXRlUHJvcGVydGllc0Z1bmN0aW9uO1xuICBpZiAob3B0cz8ubWFwUm91dGVQcm9wZXJ0aWVzKSB7XG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzID0gb3B0cy5tYXBSb3V0ZVByb3BlcnRpZXM7XG4gIH0gZWxzZSBpZiAob3B0cz8uZGV0ZWN0RXJyb3JCb3VuZGFyeSkge1xuICAgIC8vIElmIHRoZXkgYXJlIHN0aWxsIHVzaW5nIHRoZSBkZXByZWNhdGVkIHZlcnNpb24sIHdyYXAgaXQgd2l0aCB0aGUgbmV3IEFQSVxuICAgIGxldCBkZXRlY3RFcnJvckJvdW5kYXJ5ID0gb3B0cy5kZXRlY3RFcnJvckJvdW5kYXJ5O1xuICAgIG1hcFJvdXRlUHJvcGVydGllcyA9IChyb3V0ZSkgPT4gKHtcbiAgICAgIGhhc0Vycm9yQm91bmRhcnk6IGRldGVjdEVycm9yQm91bmRhcnkocm91dGUpLFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG1hcFJvdXRlUHJvcGVydGllcyA9IGRlZmF1bHRNYXBSb3V0ZVByb3BlcnRpZXM7XG4gIH1cblxuICBsZXQgZGF0YVJvdXRlcyA9IGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMoXG4gICAgcm91dGVzLFxuICAgIG1hcFJvdXRlUHJvcGVydGllcyxcbiAgICB1bmRlZmluZWQsXG4gICAgbWFuaWZlc3RcbiAgKTtcblxuICAvKipcbiAgICogVGhlIHF1ZXJ5KCkgbWV0aG9kIGlzIGludGVuZGVkIGZvciBkb2N1bWVudCByZXF1ZXN0cywgaW4gd2hpY2ggd2Ugd2FudCB0b1xuICAgKiBjYWxsIGFuIG9wdGlvbmFsIGFjdGlvbiBhbmQgcG90ZW50aWFsbHkgbXVsdGlwbGUgbG9hZGVycyBmb3IgYWxsIG5lc3RlZFxuICAgKiByb3V0ZXMuICBJdCByZXR1cm5zIGEgU3RhdGljSGFuZGxlckNvbnRleHQgb2JqZWN0LCB3aGljaCBpcyB2ZXJ5IHNpbWlsYXJcbiAgICogdG8gdGhlIHJvdXRlciBzdGF0ZSAobG9jYXRpb24sIGxvYWRlckRhdGEsIGFjdGlvbkRhdGEsIGVycm9ycywgZXRjLikgYW5kXG4gICAqIGFsc28gYWRkcyBTU1Itc3BlY2lmaWMgaW5mb3JtYXRpb24gc3VjaCBhcyB0aGUgc3RhdHVzQ29kZSBhbmQgaGVhZGVyc1xuICAgKiBmcm9tIGFjdGlvbi9sb2FkZXJzIFJlc3BvbnNlcy5cbiAgICpcbiAgICogSXQgX3Nob3VsZF8gbmV2ZXIgdGhyb3cgYW5kIHNob3VsZCByZXBvcnQgYWxsIGVycm9ycyB0aHJvdWdoIHRoZVxuICAgKiByZXR1cm5lZCBjb250ZXh0LmVycm9ycyBvYmplY3QsIHByb3Blcmx5IGFzc29jaWF0aW5nIGVycm9ycyB0byB0aGVpciBlcnJvclxuICAgKiBib3VuZGFyeS4gIEFkZGl0aW9uYWxseSwgaXQgdHJhY2tzIF9kZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkIHdoaWNoIGNhbiBiZVxuICAgKiB1c2VkIHRvIGVtdWxhdGUgUmVhY3QgZXJyb3IgYm91bmRhcmllcyBkdXJpbmcgU1NyIGJ5IHBlcmZvcm1pbmcgYSBzZWNvbmRcbiAgICogcGFzcyBvbmx5IGRvd24gdG8gdGhlIGJvdW5kYXJ5SWQuXG4gICAqXG4gICAqIFRoZSBvbmUgZXhjZXB0aW9uIHdoZXJlIHdlIGRvIG5vdCByZXR1cm4gYSBTdGF0aWNIYW5kbGVyQ29udGV4dCBpcyB3aGVuIGFcbiAgICogcmVkaXJlY3QgcmVzcG9uc2UgaXMgcmV0dXJuZWQgb3IgdGhyb3duIGZyb20gYW55IGFjdGlvbi9sb2FkZXIuICBXZVxuICAgKiBwcm9wYWdhdGUgdGhhdCBvdXQgYW5kIHJldHVybiB0aGUgcmF3IFJlc3BvbnNlIHNvIHRoZSBIVFRQIHNlcnZlciBjYW5cbiAgICogcmV0dXJuIGl0IGRpcmVjdGx5LlxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gcXVlcnkoXG4gICAgcmVxdWVzdDogUmVxdWVzdCxcbiAgICB7IHJlcXVlc3RDb250ZXh0IH06IHsgcmVxdWVzdENvbnRleHQ/OiB1bmtub3duIH0gPSB7fVxuICApOiBQcm9taXNlPFN0YXRpY0hhbmRsZXJDb250ZXh0IHwgUmVzcG9uc2U+IHtcbiAgICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgbGV0IG1ldGhvZCA9IHJlcXVlc3QubWV0aG9kO1xuICAgIGxldCBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKFwiXCIsIGNyZWF0ZVBhdGgodXJsKSwgbnVsbCwgXCJkZWZhdWx0XCIpO1xuICAgIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMoZGF0YVJvdXRlcywgbG9jYXRpb24sIGJhc2VuYW1lKTtcblxuICAgIC8vIFNTUiBzdXBwb3J0cyBIRUFEIHJlcXVlc3RzIHdoaWxlIFNQQSBkb2Vzbid0XG4gICAgaWYgKCFpc1ZhbGlkTWV0aG9kKG1ldGhvZCkgJiYgbWV0aG9kICE9PSBcIkhFQURcIikge1xuICAgICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHsgbWV0aG9kIH0pO1xuICAgICAgbGV0IHsgbWF0Y2hlczogbWV0aG9kTm90QWxsb3dlZE1hdGNoZXMsIHJvdXRlIH0gPVxuICAgICAgICBnZXRTaG9ydENpcmN1aXRNYXRjaGVzKGRhdGFSb3V0ZXMpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYmFzZW5hbWUsXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBtYXRjaGVzOiBtZXRob2ROb3RBbGxvd2VkTWF0Y2hlcyxcbiAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgIGFjdGlvbkRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yczoge1xuICAgICAgICAgIFtyb3V0ZS5pZF06IGVycm9yLFxuICAgICAgICB9LFxuICAgICAgICBzdGF0dXNDb2RlOiBlcnJvci5zdGF0dXMsXG4gICAgICAgIGxvYWRlckhlYWRlcnM6IHt9LFxuICAgICAgICBhY3Rpb25IZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aXZlRGVmZXJyZWRzOiBudWxsLFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCFtYXRjaGVzKSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwgeyBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUgfSk7XG4gICAgICBsZXQgeyBtYXRjaGVzOiBub3RGb3VuZE1hdGNoZXMsIHJvdXRlIH0gPVxuICAgICAgICBnZXRTaG9ydENpcmN1aXRNYXRjaGVzKGRhdGFSb3V0ZXMpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYmFzZW5hbWUsXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBtYXRjaGVzOiBub3RGb3VuZE1hdGNoZXMsXG4gICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICBhY3Rpb25EYXRhOiBudWxsLFxuICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICBbcm91dGUuaWRdOiBlcnJvcixcbiAgICAgICAgfSxcbiAgICAgICAgc3RhdHVzQ29kZTogZXJyb3Iuc3RhdHVzLFxuICAgICAgICBsb2FkZXJIZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aW9uSGVhZGVyczoge30sXG4gICAgICAgIGFjdGl2ZURlZmVycmVkczogbnVsbCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5SW1wbChyZXF1ZXN0LCBsb2NhdGlvbiwgbWF0Y2hlcywgcmVxdWVzdENvbnRleHQpO1xuICAgIGlmIChpc1Jlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gV2hlbiByZXR1cm5pbmcgU3RhdGljSGFuZGxlckNvbnRleHQsIHdlIHBhdGNoIGJhY2sgaW4gdGhlIGxvY2F0aW9uIGhlcmVcbiAgICAvLyBzaW5jZSB3ZSBuZWVkIGl0IGZvciBSZWFjdCBDb250ZXh0LiAgQnV0IHRoaXMgaGVscHMga2VlcCBvdXIgc3VibWl0IGFuZFxuICAgIC8vIGxvYWRSb3V0ZURhdGEgb3BlcmF0aW5nIG9uIGEgUmVxdWVzdCBpbnN0ZWFkIG9mIGEgTG9jYXRpb25cbiAgICByZXR1cm4geyBsb2NhdGlvbiwgYmFzZW5hbWUsIC4uLnJlc3VsdCB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBxdWVyeVJvdXRlKCkgbWV0aG9kIGlzIGludGVuZGVkIGZvciB0YXJnZXRlZCByb3V0ZSByZXF1ZXN0cywgZWl0aGVyXG4gICAqIGZvciBmZXRjaCA/X2RhdGEgcmVxdWVzdHMgb3IgcmVzb3VyY2Ugcm91dGUgcmVxdWVzdHMuICBJbiB0aGlzIGNhc2UsIHdlXG4gICAqIGFyZSBvbmx5IGV2ZXIgY2FsbGluZyBhIHNpbmdsZSBhY3Rpb24gb3IgbG9hZGVyLCBhbmQgd2UgYXJlIHJldHVybmluZyB0aGVcbiAgICogcmV0dXJuZWQgdmFsdWUgZGlyZWN0bHkuICBJbiBtb3N0IGNhc2VzLCB0aGlzIHdpbGwgYmUgYSBSZXNwb25zZSByZXR1cm5lZFxuICAgKiBmcm9tIHRoZSBhY3Rpb24vbG9hZGVyLCBidXQgaXQgbWF5IGJlIGEgcHJpbWl0aXZlIG9yIG90aGVyIHZhbHVlIGFzIHdlbGwgLVxuICAgKiBhbmQgaW4gc3VjaCBjYXNlcyB0aGUgY2FsbGluZyBjb250ZXh0IHNob3VsZCBoYW5kbGUgdGhhdCBhY2NvcmRpbmdseS5cbiAgICpcbiAgICogV2UgZG8gcmVzcGVjdCB0aGUgdGhyb3cvcmV0dXJuIGRpZmZlcmVudGlhdGlvbiwgc28gaWYgYW4gYWN0aW9uL2xvYWRlclxuICAgKiB0aHJvd3MsIHRoZW4gdGhpcyBtZXRob2Qgd2lsbCB0aHJvdyB0aGUgdmFsdWUuICBUaGlzIGlzIGltcG9ydGFudCBzbyB3ZVxuICAgKiBjYW4gZG8gcHJvcGVyIGJvdW5kYXJ5IGlkZW50aWZpY2F0aW9uIGluIFJlbWl4IHdoZXJlIGEgdGhyb3duIFJlc3BvbnNlXG4gICAqIG11c3QgZ28gdG8gdGhlIENhdGNoIEJvdW5kYXJ5IGJ1dCBhIHJldHVybmVkIFJlc3BvbnNlIGlzIGhhcHB5LXBhdGguXG4gICAqXG4gICAqIE9uZSB0aGluZyB0byBub3RlIGlzIHRoYXQgYW55IFJvdXRlci1pbml0aWF0ZWQgRXJyb3JzIHRoYXQgbWFrZSBzZW5zZVxuICAgKiB0byBhc3NvY2lhdGUgd2l0aCBhIHN0YXR1cyBjb2RlIHdpbGwgYmUgdGhyb3duIGFzIGFuIEVycm9yUmVzcG9uc2VcbiAgICogaW5zdGFuY2Ugd2hpY2ggaW5jbHVkZSB0aGUgcmF3IEVycm9yLCBzdWNoIHRoYXQgdGhlIGNhbGxpbmcgY29udGV4dCBjYW5cbiAgICogc2VyaWFsaXplIHRoZSBlcnJvciBhcyB0aGV5IHNlZSBmaXQgd2hpbGUgaW5jbHVkaW5nIHRoZSBwcm9wZXIgcmVzcG9uc2VcbiAgICogY29kZS4gIEV4YW1wbGVzIGhlcmUgYXJlIDQwNCBhbmQgNDA1IGVycm9ycyB0aGF0IG9jY3VyIHByaW9yIHRvIHJlYWNoaW5nXG4gICAqIGFueSB1c2VyLWRlZmluZWQgbG9hZGVycy5cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIHF1ZXJ5Um91dGUoXG4gICAgcmVxdWVzdDogUmVxdWVzdCxcbiAgICB7XG4gICAgICByb3V0ZUlkLFxuICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgfTogeyByZXF1ZXN0Q29udGV4dD86IHVua25vd247IHJvdXRlSWQ/OiBzdHJpbmcgfSA9IHt9XG4gICk6IFByb21pc2U8YW55PiB7XG4gICAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgIGxldCBtZXRob2QgPSByZXF1ZXN0Lm1ldGhvZDtcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihcIlwiLCBjcmVhdGVQYXRoKHVybCksIG51bGwsIFwiZGVmYXVsdFwiKTtcbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKGRhdGFSb3V0ZXMsIGxvY2F0aW9uLCBiYXNlbmFtZSk7XG5cbiAgICAvLyBTU1Igc3VwcG9ydHMgSEVBRCByZXF1ZXN0cyB3aGlsZSBTUEEgZG9lc24ndFxuICAgIGlmICghaXNWYWxpZE1ldGhvZChtZXRob2QpICYmIG1ldGhvZCAhPT0gXCJIRUFEXCIgJiYgbWV0aG9kICE9PSBcIk9QVElPTlNcIikge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHsgbWV0aG9kIH0pO1xuICAgIH0gZWxzZSBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7IHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSB9KTtcbiAgICB9XG5cbiAgICBsZXQgbWF0Y2ggPSByb3V0ZUlkXG4gICAgICA/IG1hdGNoZXMuZmluZCgobSkgPT4gbS5yb3V0ZS5pZCA9PT0gcm91dGVJZClcbiAgICAgIDogZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgbG9jYXRpb24pO1xuXG4gICAgaWYgKHJvdXRlSWQgJiYgIW1hdGNoKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMywge1xuICAgICAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgIHJvdXRlSWQsXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCFtYXRjaCkge1xuICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGl0IEkgZG9uJ3QgdGhpbms/XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwgeyBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUgfSk7XG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5SW1wbChcbiAgICAgIHJlcXVlc3QsXG4gICAgICBsb2NhdGlvbixcbiAgICAgIG1hdGNoZXMsXG4gICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgIG1hdGNoXG4gICAgKTtcbiAgICBpZiAoaXNSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGxldCBlcnJvciA9IHJlc3VsdC5lcnJvcnMgPyBPYmplY3QudmFsdWVzKHJlc3VsdC5lcnJvcnMpWzBdIDogdW5kZWZpbmVkO1xuICAgIGlmIChlcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBJZiB3ZSBnb3QgYmFjayByZXN1bHQuZXJyb3JzLCB0aGF0IG1lYW5zIHRoZSBsb2FkZXIvYWN0aW9uIHRocmV3XG4gICAgICAvLyBfc29tZXRoaW5nXyB0aGF0IHdhc24ndCBhIFJlc3BvbnNlLCBidXQgaXQncyBub3QgZ3VhcmFudGVlZC9yZXF1aXJlZFxuICAgICAgLy8gdG8gYmUgYW4gYGluc3RhbmNlb2YgRXJyb3JgIGVpdGhlciwgc28gd2UgaGF2ZSB0byB1c2UgdGhyb3cgaGVyZSB0b1xuICAgICAgLy8gcHJlc2VydmUgdGhlIFwiZXJyb3JcIiBzdGF0ZSBvdXRzaWRlIG9mIHF1ZXJ5SW1wbC5cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIC8vIFBpY2sgb2ZmIHRoZSByaWdodCBzdGF0ZSB2YWx1ZSB0byByZXR1cm5cbiAgICBpZiAocmVzdWx0LmFjdGlvbkRhdGEpIHtcbiAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHJlc3VsdC5hY3Rpb25EYXRhKVswXTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0LmxvYWRlckRhdGEpIHtcbiAgICAgIGxldCBkYXRhID0gT2JqZWN0LnZhbHVlcyhyZXN1bHQubG9hZGVyRGF0YSlbMF07XG4gICAgICBpZiAocmVzdWx0LmFjdGl2ZURlZmVycmVkcz8uW21hdGNoLnJvdXRlLmlkXSkge1xuICAgICAgICBkYXRhW1VOU0FGRV9ERUZFUlJFRF9TWU1CT0xdID0gcmVzdWx0LmFjdGl2ZURlZmVycmVkc1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gcXVlcnlJbXBsKFxuICAgIHJlcXVlc3Q6IFJlcXVlc3QsXG4gICAgbG9jYXRpb246IExvY2F0aW9uLFxuICAgIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgICByZXF1ZXN0Q29udGV4dDogdW5rbm93bixcbiAgICByb3V0ZU1hdGNoPzogQWdub3N0aWNEYXRhUm91dGVNYXRjaFxuICApOiBQcm9taXNlPE9taXQ8U3RhdGljSGFuZGxlckNvbnRleHQsIFwibG9jYXRpb25cIiB8IFwiYmFzZW5hbWVcIj4gfCBSZXNwb25zZT4ge1xuICAgIGludmFyaWFudChcbiAgICAgIHJlcXVlc3Quc2lnbmFsLFxuICAgICAgXCJxdWVyeSgpL3F1ZXJ5Um91dGUoKSByZXF1ZXN0cyBtdXN0IGNvbnRhaW4gYW4gQWJvcnRDb250cm9sbGVyIHNpZ25hbFwiXG4gICAgKTtcblxuICAgIHRyeSB7XG4gICAgICBpZiAoaXNNdXRhdGlvbk1ldGhvZChyZXF1ZXN0Lm1ldGhvZC50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgc3VibWl0KFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICByb3V0ZU1hdGNoIHx8IGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIGxvY2F0aW9uKSxcbiAgICAgICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgICAgICByb3V0ZU1hdGNoICE9IG51bGxcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IGxvYWRSb3V0ZURhdGEoXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIHJlcXVlc3RDb250ZXh0LFxuICAgICAgICByb3V0ZU1hdGNoXG4gICAgICApO1xuICAgICAgcmV0dXJuIGlzUmVzcG9uc2UocmVzdWx0KVxuICAgICAgICA/IHJlc3VsdFxuICAgICAgICA6IHtcbiAgICAgICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgICAgIGFjdGlvbkRhdGE6IG51bGwsXG4gICAgICAgICAgICBhY3Rpb25IZWFkZXJzOiB7fSxcbiAgICAgICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHRocmV3L3JldHVybmVkIGEgUmVzcG9uc2UgaW4gY2FsbExvYWRlck9yQWN0aW9uLCB3ZSB0aHJvd1xuICAgICAgLy8gaXQgdG8gYmFpbCBvdXQgYW5kIHRoZW4gcmV0dXJuIG9yIHRocm93IGhlcmUgYmFzZWQgb24gd2hldGhlciB0aGUgdXNlclxuICAgICAgLy8gcmV0dXJuZWQgb3IgdGhyZXdcbiAgICAgIGlmIChpc1F1ZXJ5Um91dGVSZXNwb25zZShlKSkge1xuICAgICAgICBpZiAoZS50eXBlID09PSBSZXN1bHRUeXBlLmVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgZS5yZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZS5yZXNwb25zZTtcbiAgICAgIH1cbiAgICAgIC8vIFJlZGlyZWN0cyBhcmUgYWx3YXlzIHJldHVybmVkIHNpbmNlIHRoZXkgZG9uJ3QgcHJvcGFnYXRlIHRvIGNhdGNoXG4gICAgICAvLyBib3VuZGFyaWVzXG4gICAgICBpZiAoaXNSZWRpcmVjdFJlc3BvbnNlKGUpKSB7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBzdWJtaXQoXG4gICAgcmVxdWVzdDogUmVxdWVzdCxcbiAgICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gICAgYWN0aW9uTWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gsXG4gICAgcmVxdWVzdENvbnRleHQ6IHVua25vd24sXG4gICAgaXNSb3V0ZVJlcXVlc3Q6IGJvb2xlYW5cbiAgKTogUHJvbWlzZTxPbWl0PFN0YXRpY0hhbmRsZXJDb250ZXh0LCBcImxvY2F0aW9uXCIgfCBcImJhc2VuYW1lXCI+IHwgUmVzcG9uc2U+IHtcbiAgICBsZXQgcmVzdWx0OiBEYXRhUmVzdWx0O1xuXG4gICAgaWYgKCFhY3Rpb25NYXRjaC5yb3V0ZS5hY3Rpb24gJiYgIWFjdGlvbk1hdGNoLnJvdXRlLmxhenkpIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7XG4gICAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgIHBhdGhuYW1lOiBuZXcgVVJMKHJlcXVlc3QudXJsKS5wYXRobmFtZSxcbiAgICAgICAgcm91dGVJZDogYWN0aW9uTWF0Y2gucm91dGUuaWQsXG4gICAgICB9KTtcbiAgICAgIGlmIChpc1JvdXRlUmVxdWVzdCkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgdHlwZTogUmVzdWx0VHlwZS5lcnJvcixcbiAgICAgICAgZXJyb3IsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBhd2FpdCBjYWxsTG9hZGVyT3JBY3Rpb24oXG4gICAgICAgIFwiYWN0aW9uXCIsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGFjdGlvbk1hdGNoLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBtYW5pZmVzdCxcbiAgICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzLFxuICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgeyBpc1N0YXRpY1JlcXVlc3Q6IHRydWUsIGlzUm91dGVSZXF1ZXN0LCByZXF1ZXN0Q29udGV4dCB9XG4gICAgICApO1xuXG4gICAgICBpZiAocmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICBsZXQgbWV0aG9kID0gaXNSb3V0ZVJlcXVlc3QgPyBcInF1ZXJ5Um91dGVcIiA6IFwicXVlcnlcIjtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGAke21ldGhvZH0oKSBjYWxsIGFib3J0ZWQ6ICR7cmVxdWVzdC5tZXRob2R9ICR7cmVxdWVzdC51cmx9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIFVoaGhoIC0gdGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLCB3ZSBzaG91bGQgYWx3YXlzIHRocm93IHRoZXNlIGZyb21cbiAgICAgIC8vIGNhbGxMb2FkZXJPckFjdGlvbiwgYnV0IHRoZSB0eXBlIG5hcnJvd2luZyBoZXJlIGtlZXBzIFRTIGhhcHB5IGFuZCB3ZVxuICAgICAgLy8gY2FuIGdldCBiYWNrIG9uIHRoZSBcInRocm93IGFsbCByZWRpcmVjdCByZXNwb25zZXNcIiB0cmFpbiBoZXJlIHNob3VsZFxuICAgICAgLy8gdGhpcyBldmVyIGhhcHBlbiA6L1xuICAgICAgdGhyb3cgbmV3IFJlc3BvbnNlKG51bGwsIHtcbiAgICAgICAgc3RhdHVzOiByZXN1bHQuc3RhdHVzLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246IHJlc3VsdC5sb2NhdGlvbixcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDAwLCB7IHR5cGU6IFwiZGVmZXItYWN0aW9uXCIgfSk7XG4gICAgICBpZiAoaXNSb3V0ZVJlcXVlc3QpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXG4gICAgICAgIGVycm9yLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoaXNSb3V0ZVJlcXVlc3QpIHtcbiAgICAgIC8vIE5vdGU6IFRoaXMgc2hvdWxkIG9ubHkgYmUgbm9uLVJlc3BvbnNlIHZhbHVlcyBpZiB3ZSBnZXQgaGVyZSwgc2luY2VcbiAgICAgIC8vIGlzUm91dGVSZXF1ZXN0IHNob3VsZCB0aHJvdyBhbnkgUmVzcG9uc2UgcmVjZWl2ZWQgaW4gY2FsbExvYWRlck9yQWN0aW9uXG4gICAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAgIHRocm93IHJlc3VsdC5lcnJvcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWF0Y2hlczogW2FjdGlvbk1hdGNoXSxcbiAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgIGFjdGlvbkRhdGE6IHsgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmRhdGEgfSxcbiAgICAgICAgZXJyb3JzOiBudWxsLFxuICAgICAgICAvLyBOb3RlOiBzdGF0dXNDb2RlICsgaGVhZGVycyBhcmUgdW51c2VkIGhlcmUgc2luY2UgcXVlcnlSb3V0ZSB3aWxsXG4gICAgICAgIC8vIHJldHVybiB0aGUgcmF3IFJlc3BvbnNlIG9yIHZhbHVlXG4gICAgICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICAgICAgbG9hZGVySGVhZGVyczoge30sXG4gICAgICAgIGFjdGlvbkhlYWRlcnM6IHt9LFxuICAgICAgICBhY3RpdmVEZWZlcnJlZHM6IG51bGwsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIFN0b3JlIG9mZiB0aGUgcGVuZGluZyBlcnJvciAtIHdlIHVzZSBpdCB0byBkZXRlcm1pbmUgd2hpY2ggbG9hZGVyc1xuICAgICAgLy8gdG8gY2FsbCBhbmQgd2lsbCBjb21taXQgaXQgd2hlbiB3ZSBjb21wbGV0ZSB0aGUgbmF2aWdhdGlvblxuICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMsIGFjdGlvbk1hdGNoLnJvdXRlLmlkKTtcbiAgICAgIGxldCBjb250ZXh0ID0gYXdhaXQgbG9hZFJvdXRlRGF0YShcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAge1xuICAgICAgICAgIFtib3VuZGFyeU1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmVycm9yLFxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICAvLyBhY3Rpb24gc3RhdHVzIGNvZGVzIHRha2UgcHJlY2VkZW5jZSBvdmVyIGxvYWRlciBzdGF0dXMgY29kZXNcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmNvbnRleHQsXG4gICAgICAgIHN0YXR1c0NvZGU6IGlzUm91dGVFcnJvclJlc3BvbnNlKHJlc3VsdC5lcnJvcilcbiAgICAgICAgICA/IHJlc3VsdC5lcnJvci5zdGF0dXNcbiAgICAgICAgICA6IDUwMCxcbiAgICAgICAgYWN0aW9uRGF0YTogbnVsbCxcbiAgICAgICAgYWN0aW9uSGVhZGVyczoge1xuICAgICAgICAgIC4uLihyZXN1bHQuaGVhZGVycyA/IHsgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmhlYWRlcnMgfSA6IHt9KSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGEgR0VUIHJlcXVlc3QgZm9yIHRoZSBsb2FkZXJzXG4gICAgbGV0IGxvYWRlclJlcXVlc3QgPSBuZXcgUmVxdWVzdChyZXF1ZXN0LnVybCwge1xuICAgICAgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzLFxuICAgICAgcmVkaXJlY3Q6IHJlcXVlc3QucmVkaXJlY3QsXG4gICAgICBzaWduYWw6IHJlcXVlc3Quc2lnbmFsLFxuICAgIH0pO1xuICAgIGxldCBjb250ZXh0ID0gYXdhaXQgbG9hZFJvdXRlRGF0YShsb2FkZXJSZXF1ZXN0LCBtYXRjaGVzLCByZXF1ZXN0Q29udGV4dCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uY29udGV4dCxcbiAgICAgIC8vIGFjdGlvbiBzdGF0dXMgY29kZXMgdGFrZSBwcmVjZWRlbmNlIG92ZXIgbG9hZGVyIHN0YXR1cyBjb2Rlc1xuICAgICAgLi4uKHJlc3VsdC5zdGF0dXNDb2RlID8geyBzdGF0dXNDb2RlOiByZXN1bHQuc3RhdHVzQ29kZSB9IDoge30pLFxuICAgICAgYWN0aW9uRGF0YToge1xuICAgICAgICBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZGF0YSxcbiAgICAgIH0sXG4gICAgICBhY3Rpb25IZWFkZXJzOiB7XG4gICAgICAgIC4uLihyZXN1bHQuaGVhZGVycyA/IHsgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmhlYWRlcnMgfSA6IHt9KSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGxvYWRSb3V0ZURhdGEoXG4gICAgcmVxdWVzdDogUmVxdWVzdCxcbiAgICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gICAgcmVxdWVzdENvbnRleHQ6IHVua25vd24sXG4gICAgcm91dGVNYXRjaD86IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gsXG4gICAgcGVuZGluZ0FjdGlvbkVycm9yPzogUm91dGVEYXRhXG4gICk6IFByb21pc2U8XG4gICAgfCBPbWl0PFxuICAgICAgICBTdGF0aWNIYW5kbGVyQ29udGV4dCxcbiAgICAgICAgXCJsb2NhdGlvblwiIHwgXCJiYXNlbmFtZVwiIHwgXCJhY3Rpb25EYXRhXCIgfCBcImFjdGlvbkhlYWRlcnNcIlxuICAgICAgPlxuICAgIHwgUmVzcG9uc2VcbiAgPiB7XG4gICAgbGV0IGlzUm91dGVSZXF1ZXN0ID0gcm91dGVNYXRjaCAhPSBudWxsO1xuXG4gICAgLy8gU2hvcnQgY2lyY3VpdCBpZiB3ZSBoYXZlIG5vIGxvYWRlcnMgdG8gcnVuIChxdWVyeVJvdXRlKCkpXG4gICAgaWYgKFxuICAgICAgaXNSb3V0ZVJlcXVlc3QgJiZcbiAgICAgICFyb3V0ZU1hdGNoPy5yb3V0ZS5sb2FkZXIgJiZcbiAgICAgICFyb3V0ZU1hdGNoPy5yb3V0ZS5sYXp5XG4gICAgKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwge1xuICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICBwYXRobmFtZTogbmV3IFVSTChyZXF1ZXN0LnVybCkucGF0aG5hbWUsXG4gICAgICAgIHJvdXRlSWQ6IHJvdXRlTWF0Y2g/LnJvdXRlLmlkLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgbGV0IHJlcXVlc3RNYXRjaGVzID0gcm91dGVNYXRjaFxuICAgICAgPyBbcm91dGVNYXRjaF1cbiAgICAgIDogZ2V0TG9hZGVyTWF0Y2hlc1VudGlsQm91bmRhcnkoXG4gICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICBPYmplY3Qua2V5cyhwZW5kaW5nQWN0aW9uRXJyb3IgfHwge30pWzBdXG4gICAgICAgICk7XG4gICAgbGV0IG1hdGNoZXNUb0xvYWQgPSByZXF1ZXN0TWF0Y2hlcy5maWx0ZXIoXG4gICAgICAobSkgPT4gbS5yb3V0ZS5sb2FkZXIgfHwgbS5yb3V0ZS5sYXp5XG4gICAgKTtcblxuICAgIC8vIFNob3J0IGNpcmN1aXQgaWYgd2UgaGF2ZSBubyBsb2FkZXJzIHRvIHJ1biAocXVlcnkoKSlcbiAgICBpZiAobWF0Y2hlc1RvTG9hZC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIC8vIEFkZCBhIG51bGwgZm9yIGFsbCBtYXRjaGVkIHJvdXRlcyBmb3IgcHJvcGVyIHJldmFsaWRhdGlvbiBvbiB0aGUgY2xpZW50XG4gICAgICAgIGxvYWRlckRhdGE6IG1hdGNoZXMucmVkdWNlKFxuICAgICAgICAgIChhY2MsIG0pID0+IE9iamVjdC5hc3NpZ24oYWNjLCB7IFttLnJvdXRlLmlkXTogbnVsbCB9KSxcbiAgICAgICAgICB7fVxuICAgICAgICApLFxuICAgICAgICBlcnJvcnM6IHBlbmRpbmdBY3Rpb25FcnJvciB8fCBudWxsLFxuICAgICAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgICAgIGxvYWRlckhlYWRlcnM6IHt9LFxuICAgICAgICBhY3RpdmVEZWZlcnJlZHM6IG51bGwsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGxldCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgLi4ubWF0Y2hlc1RvTG9hZC5tYXAoKG1hdGNoKSA9PlxuICAgICAgICBjYWxsTG9hZGVyT3JBY3Rpb24oXG4gICAgICAgICAgXCJsb2FkZXJcIixcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgbWFuaWZlc3QsXG4gICAgICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzLFxuICAgICAgICAgIGJhc2VuYW1lLFxuICAgICAgICAgIHsgaXNTdGF0aWNSZXF1ZXN0OiB0cnVlLCBpc1JvdXRlUmVxdWVzdCwgcmVxdWVzdENvbnRleHQgfVxuICAgICAgICApXG4gICAgICApLFxuICAgIF0pO1xuXG4gICAgaWYgKHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIGxldCBtZXRob2QgPSBpc1JvdXRlUmVxdWVzdCA/IFwicXVlcnlSb3V0ZVwiIDogXCJxdWVyeVwiO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgJHttZXRob2R9KCkgY2FsbCBhYm9ydGVkOiAke3JlcXVlc3QubWV0aG9kfSAke3JlcXVlc3QudXJsfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gUHJvY2VzcyBhbmQgY29tbWl0IG91dHB1dCBmcm9tIGxvYWRlcnNcbiAgICBsZXQgYWN0aXZlRGVmZXJyZWRzID0gbmV3IE1hcDxzdHJpbmcsIERlZmVycmVkRGF0YT4oKTtcbiAgICBsZXQgY29udGV4dCA9IHByb2Nlc3NSb3V0ZUxvYWRlckRhdGEoXG4gICAgICBtYXRjaGVzLFxuICAgICAgbWF0Y2hlc1RvTG9hZCxcbiAgICAgIHJlc3VsdHMsXG4gICAgICBwZW5kaW5nQWN0aW9uRXJyb3IsXG4gICAgICBhY3RpdmVEZWZlcnJlZHNcbiAgICApO1xuXG4gICAgLy8gQWRkIGEgbnVsbCBmb3IgYW55IG5vbi1sb2FkZXIgbWF0Y2hlcyBmb3IgcHJvcGVyIHJldmFsaWRhdGlvbiBvbiB0aGUgY2xpZW50XG4gICAgbGV0IGV4ZWN1dGVkTG9hZGVycyA9IG5ldyBTZXQ8c3RyaW5nPihcbiAgICAgIG1hdGNoZXNUb0xvYWQubWFwKChtYXRjaCkgPT4gbWF0Y2gucm91dGUuaWQpXG4gICAgKTtcbiAgICBtYXRjaGVzLmZvckVhY2goKG1hdGNoKSA9PiB7XG4gICAgICBpZiAoIWV4ZWN1dGVkTG9hZGVycy5oYXMobWF0Y2gucm91dGUuaWQpKSB7XG4gICAgICAgIGNvbnRleHQubG9hZGVyRGF0YVttYXRjaC5yb3V0ZS5pZF0gPSBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmNvbnRleHQsXG4gICAgICBtYXRjaGVzLFxuICAgICAgYWN0aXZlRGVmZXJyZWRzOlxuICAgICAgICBhY3RpdmVEZWZlcnJlZHMuc2l6ZSA+IDBcbiAgICAgICAgICA/IE9iamVjdC5mcm9tRW50cmllcyhhY3RpdmVEZWZlcnJlZHMuZW50cmllcygpKVxuICAgICAgICAgIDogbnVsbCxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkYXRhUm91dGVzLFxuICAgIHF1ZXJ5LFxuICAgIHF1ZXJ5Um91dGUsXG4gIH07XG59XG5cbi8vI2VuZHJlZ2lvblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIEhlbHBlcnNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogR2l2ZW4gYW4gZXhpc3RpbmcgU3RhdGljSGFuZGxlckNvbnRleHQgYW5kIGFuIGVycm9yIHRocm93biBhdCByZW5kZXIgdGltZSxcbiAqIHByb3ZpZGUgYW4gdXBkYXRlZCBTdGF0aWNIYW5kbGVyQ29udGV4dCBzdWl0YWJsZSBmb3IgYSBzZWNvbmQgU1NSIHJlbmRlclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhdGljQ29udGV4dEZyb21FcnJvcihcbiAgcm91dGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdFtdLFxuICBjb250ZXh0OiBTdGF0aWNIYW5kbGVyQ29udGV4dCxcbiAgZXJyb3I6IGFueVxuKSB7XG4gIGxldCBuZXdDb250ZXh0OiBTdGF0aWNIYW5kbGVyQ29udGV4dCA9IHtcbiAgICAuLi5jb250ZXh0LFxuICAgIHN0YXR1c0NvZGU6IDUwMCxcbiAgICBlcnJvcnM6IHtcbiAgICAgIFtjb250ZXh0Ll9kZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkIHx8IHJvdXRlc1swXS5pZF06IGVycm9yLFxuICAgIH0sXG4gIH07XG4gIHJldHVybiBuZXdDb250ZXh0O1xufVxuXG5mdW5jdGlvbiBpc1N1Ym1pc3Npb25OYXZpZ2F0aW9uKFxuICBvcHRzOiBCYXNlTmF2aWdhdGVPckZldGNoT3B0aW9uc1xuKTogb3B0cyBpcyBTdWJtaXNzaW9uTmF2aWdhdGVPcHRpb25zIHtcbiAgcmV0dXJuIChcbiAgICBvcHRzICE9IG51bGwgJiZcbiAgICAoKFwiZm9ybURhdGFcIiBpbiBvcHRzICYmIG9wdHMuZm9ybURhdGEgIT0gbnVsbCkgfHxcbiAgICAgIChcImJvZHlcIiBpbiBvcHRzICYmIG9wdHMuYm9keSAhPT0gdW5kZWZpbmVkKSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVG8oXG4gIGxvY2F0aW9uOiBQYXRoLFxuICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gIGJhc2VuYW1lOiBzdHJpbmcsXG4gIHByZXBlbmRCYXNlbmFtZTogYm9vbGVhbixcbiAgdG86IFRvIHwgbnVsbCxcbiAgZnJvbVJvdXRlSWQ/OiBzdHJpbmcsXG4gIHJlbGF0aXZlPzogUmVsYXRpdmVSb3V0aW5nVHlwZVxuKSB7XG4gIGxldCBjb250ZXh0dWFsTWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdO1xuICBsZXQgYWN0aXZlUm91dGVNYXRjaDogQWdub3N0aWNEYXRhUm91dGVNYXRjaCB8IHVuZGVmaW5lZDtcbiAgaWYgKGZyb21Sb3V0ZUlkKSB7XG4gICAgLy8gR3JhYiBtYXRjaGVzIHVwIHRvIHRoZSBjYWxsaW5nIHJvdXRlIHNvIG91ciByb3V0ZS1yZWxhdGl2ZSBsb2dpYyBpc1xuICAgIC8vIHJlbGF0aXZlIHRvIHRoZSBjb3JyZWN0IHNvdXJjZSByb3V0ZVxuICAgIGNvbnRleHR1YWxNYXRjaGVzID0gW107XG4gICAgZm9yIChsZXQgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgICAgY29udGV4dHVhbE1hdGNoZXMucHVzaChtYXRjaCk7XG4gICAgICBpZiAobWF0Y2gucm91dGUuaWQgPT09IGZyb21Sb3V0ZUlkKSB7XG4gICAgICAgIGFjdGl2ZVJvdXRlTWF0Y2ggPSBtYXRjaDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnRleHR1YWxNYXRjaGVzID0gbWF0Y2hlcztcbiAgICBhY3RpdmVSb3V0ZU1hdGNoID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgLy8gUmVzb2x2ZSB0aGUgcmVsYXRpdmUgcGF0aFxuICBsZXQgcGF0aCA9IHJlc29sdmVUbyhcbiAgICB0byA/IHRvIDogXCIuXCIsXG4gICAgZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMoY29udGV4dHVhbE1hdGNoZXMpLm1hcCgobSkgPT4gbS5wYXRobmFtZUJhc2UpLFxuICAgIHN0cmlwQmFzZW5hbWUobG9jYXRpb24ucGF0aG5hbWUsIGJhc2VuYW1lKSB8fCBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICByZWxhdGl2ZSA9PT0gXCJwYXRoXCJcbiAgKTtcblxuICAvLyBXaGVuIGB0b2AgaXMgbm90IHNwZWNpZmllZCB3ZSBpbmhlcml0IHNlYXJjaC9oYXNoIGZyb20gdGhlIGN1cnJlbnRcbiAgLy8gbG9jYXRpb24sIHVubGlrZSB3aGVuIHRvPVwiLlwiIGFuZCB3ZSBqdXN0IGluaGVyaXQgdGhlIHBhdGguXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL3JlbWl4L2lzc3Vlcy85MjdcbiAgaWYgKHRvID09IG51bGwpIHtcbiAgICBwYXRoLnNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaDtcbiAgICBwYXRoLmhhc2ggPSBsb2NhdGlvbi5oYXNoO1xuICB9XG5cbiAgLy8gQWRkIGFuID9pbmRleCBwYXJhbSBmb3IgbWF0Y2hlZCBpbmRleCByb3V0ZXMgaWYgd2UgZG9uJ3QgYWxyZWFkeSBoYXZlIG9uZVxuICBpZiAoXG4gICAgKHRvID09IG51bGwgfHwgdG8gPT09IFwiXCIgfHwgdG8gPT09IFwiLlwiKSAmJlxuICAgIGFjdGl2ZVJvdXRlTWF0Y2ggJiZcbiAgICBhY3RpdmVSb3V0ZU1hdGNoLnJvdXRlLmluZGV4ICYmXG4gICAgIWhhc05ha2VkSW5kZXhRdWVyeShwYXRoLnNlYXJjaClcbiAgKSB7XG4gICAgcGF0aC5zZWFyY2ggPSBwYXRoLnNlYXJjaFxuICAgICAgPyBwYXRoLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgXCI/aW5kZXgmXCIpXG4gICAgICA6IFwiP2luZGV4XCI7XG4gIH1cblxuICAvLyBJZiB3ZSdyZSBvcGVyYXRpbmcgd2l0aGluIGEgYmFzZW5hbWUsIHByZXBlbmQgaXQgdG8gdGhlIHBhdGhuYW1lLiAgSWZcbiAgLy8gdGhpcyBpcyBhIHJvb3QgbmF2aWdhdGlvbiwgdGhlbiBqdXN0IHVzZSB0aGUgcmF3IGJhc2VuYW1lIHdoaWNoIGFsbG93c1xuICAvLyB0aGUgYmFzZW5hbWUgdG8gaGF2ZSBmdWxsIGNvbnRyb2wgb3ZlciB0aGUgcHJlc2VuY2Ugb2YgYSB0cmFpbGluZyBzbGFzaFxuICAvLyBvbiByb290IGFjdGlvbnNcbiAgaWYgKHByZXBlbmRCYXNlbmFtZSAmJiBiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICBwYXRoLnBhdGhuYW1lID1cbiAgICAgIHBhdGgucGF0aG5hbWUgPT09IFwiL1wiID8gYmFzZW5hbWUgOiBqb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRoLnBhdGhuYW1lXSk7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlUGF0aChwYXRoKTtcbn1cblxuLy8gTm9ybWFsaXplIG5hdmlnYXRpb24gb3B0aW9ucyBieSBjb252ZXJ0aW5nIGZvcm1NZXRob2Q9R0VUIGZvcm1EYXRhIG9iamVjdHMgdG9cbi8vIFVSTFNlYXJjaFBhcmFtcyBzbyB0aGV5IGJlaGF2ZSBpZGVudGljYWxseSB0byBsaW5rcyB3aXRoIHF1ZXJ5IHBhcmFtc1xuZnVuY3Rpb24gbm9ybWFsaXplTmF2aWdhdGVPcHRpb25zKFxuICBub3JtYWxpemVGb3JtTWV0aG9kOiBib29sZWFuLFxuICBpc0ZldGNoZXI6IGJvb2xlYW4sXG4gIHBhdGg6IHN0cmluZyxcbiAgb3B0cz86IEJhc2VOYXZpZ2F0ZU9yRmV0Y2hPcHRpb25zXG4pOiB7XG4gIHBhdGg6IHN0cmluZztcbiAgc3VibWlzc2lvbj86IFN1Ym1pc3Npb247XG4gIGVycm9yPzogRXJyb3JSZXNwb25zZUltcGw7XG59IHtcbiAgLy8gUmV0dXJuIGxvY2F0aW9uIHZlcmJhdGltIG9uIG5vbi1zdWJtaXNzaW9uIG5hdmlnYXRpb25zXG4gIGlmICghb3B0cyB8fCAhaXNTdWJtaXNzaW9uTmF2aWdhdGlvbihvcHRzKSkge1xuICAgIHJldHVybiB7IHBhdGggfTtcbiAgfVxuXG4gIGlmIChvcHRzLmZvcm1NZXRob2QgJiYgIWlzVmFsaWRNZXRob2Qob3B0cy5mb3JtTWV0aG9kKSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoLFxuICAgICAgZXJyb3I6IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7IG1ldGhvZDogb3B0cy5mb3JtTWV0aG9kIH0pLFxuICAgIH07XG4gIH1cblxuICBsZXQgZ2V0SW52YWxpZEJvZHlFcnJvciA9ICgpID0+ICh7XG4gICAgcGF0aCxcbiAgICBlcnJvcjogZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDAsIHsgdHlwZTogXCJpbnZhbGlkLWJvZHlcIiB9KSxcbiAgfSk7XG5cbiAgLy8gQ3JlYXRlIGEgU3VibWlzc2lvbiBvbiBub24tR0VUIG5hdmlnYXRpb25zXG4gIGxldCByYXdGb3JtTWV0aG9kID0gb3B0cy5mb3JtTWV0aG9kIHx8IFwiZ2V0XCI7XG4gIGxldCBmb3JtTWV0aG9kID0gbm9ybWFsaXplRm9ybU1ldGhvZFxuICAgID8gKHJhd0Zvcm1NZXRob2QudG9VcHBlckNhc2UoKSBhcyBWN19Gb3JtTWV0aG9kKVxuICAgIDogKHJhd0Zvcm1NZXRob2QudG9Mb3dlckNhc2UoKSBhcyBGb3JtTWV0aG9kKTtcbiAgbGV0IGZvcm1BY3Rpb24gPSBzdHJpcEhhc2hGcm9tUGF0aChwYXRoKTtcblxuICBpZiAob3B0cy5ib2R5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAob3B0cy5mb3JtRW5jVHlwZSA9PT0gXCJ0ZXh0L3BsYWluXCIpIHtcbiAgICAgIC8vIHRleHQgb25seSBzdXBwb3J0IFBPU1QvUFVUL1BBVENIL0RFTEVURSBzdWJtaXNzaW9uc1xuICAgICAgaWYgKCFpc011dGF0aW9uTWV0aG9kKGZvcm1NZXRob2QpKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnZhbGlkQm9keUVycm9yKCk7XG4gICAgICB9XG5cbiAgICAgIGxldCB0ZXh0ID1cbiAgICAgICAgdHlwZW9mIG9wdHMuYm9keSA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgID8gb3B0cy5ib2R5XG4gICAgICAgICAgOiBvcHRzLmJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSB8fFxuICAgICAgICAgICAgb3B0cy5ib2R5IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zXG4gICAgICAgICAgPyAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3JtLWNvbnRyb2wtaW5mcmFzdHJ1Y3R1cmUuaHRtbCNwbGFpbi10ZXh0LWZvcm0tZGF0YVxuICAgICAgICAgICAgQXJyYXkuZnJvbShvcHRzLmJvZHkuZW50cmllcygpKS5yZWR1Y2UoXG4gICAgICAgICAgICAgIChhY2MsIFtuYW1lLCB2YWx1ZV0pID0+IGAke2FjY30ke25hbWV9PSR7dmFsdWV9XFxuYCxcbiAgICAgICAgICAgICAgXCJcIlxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogU3RyaW5nKG9wdHMuYm9keSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIHN1Ym1pc3Npb246IHtcbiAgICAgICAgICBmb3JtTWV0aG9kLFxuICAgICAgICAgIGZvcm1BY3Rpb24sXG4gICAgICAgICAgZm9ybUVuY1R5cGU6IG9wdHMuZm9ybUVuY1R5cGUsXG4gICAgICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgICAgICBqc29uOiB1bmRlZmluZWQsXG4gICAgICAgICAgdGV4dCxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChvcHRzLmZvcm1FbmNUeXBlID09PSBcImFwcGxpY2F0aW9uL2pzb25cIikge1xuICAgICAgLy8ganNvbiBvbmx5IHN1cHBvcnRzIFBPU1QvUFVUL1BBVENIL0RFTEVURSBzdWJtaXNzaW9uc1xuICAgICAgaWYgKCFpc011dGF0aW9uTWV0aG9kKGZvcm1NZXRob2QpKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnZhbGlkQm9keUVycm9yKCk7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBqc29uID1cbiAgICAgICAgICB0eXBlb2Ygb3B0cy5ib2R5ID09PSBcInN0cmluZ1wiID8gSlNPTi5wYXJzZShvcHRzLmJvZHkpIDogb3B0cy5ib2R5O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBzdWJtaXNzaW9uOiB7XG4gICAgICAgICAgICBmb3JtTWV0aG9kLFxuICAgICAgICAgICAgZm9ybUFjdGlvbixcbiAgICAgICAgICAgIGZvcm1FbmNUeXBlOiBvcHRzLmZvcm1FbmNUeXBlLFxuICAgICAgICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGpzb24sXG4gICAgICAgICAgICB0ZXh0OiB1bmRlZmluZWQsXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGdldEludmFsaWRCb2R5RXJyb3IoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpbnZhcmlhbnQoXG4gICAgdHlwZW9mIEZvcm1EYXRhID09PSBcImZ1bmN0aW9uXCIsXG4gICAgXCJGb3JtRGF0YSBpcyBub3QgYXZhaWxhYmxlIGluIHRoaXMgZW52aXJvbm1lbnRcIlxuICApO1xuXG4gIGxldCBzZWFyY2hQYXJhbXM6IFVSTFNlYXJjaFBhcmFtcztcbiAgbGV0IGZvcm1EYXRhOiBGb3JtRGF0YTtcblxuICBpZiAob3B0cy5mb3JtRGF0YSkge1xuICAgIHNlYXJjaFBhcmFtcyA9IGNvbnZlcnRGb3JtRGF0YVRvU2VhcmNoUGFyYW1zKG9wdHMuZm9ybURhdGEpO1xuICAgIGZvcm1EYXRhID0gb3B0cy5mb3JtRGF0YTtcbiAgfSBlbHNlIGlmIChvcHRzLmJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuICAgIHNlYXJjaFBhcmFtcyA9IGNvbnZlcnRGb3JtRGF0YVRvU2VhcmNoUGFyYW1zKG9wdHMuYm9keSk7XG4gICAgZm9ybURhdGEgPSBvcHRzLmJvZHk7XG4gIH0gZWxzZSBpZiAob3B0cy5ib2R5IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zKSB7XG4gICAgc2VhcmNoUGFyYW1zID0gb3B0cy5ib2R5O1xuICAgIGZvcm1EYXRhID0gY29udmVydFNlYXJjaFBhcmFtc1RvRm9ybURhdGEoc2VhcmNoUGFyYW1zKTtcbiAgfSBlbHNlIGlmIChvcHRzLmJvZHkgPT0gbnVsbCkge1xuICAgIHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKG9wdHMuYm9keSk7XG4gICAgICBmb3JtRGF0YSA9IGNvbnZlcnRTZWFyY2hQYXJhbXNUb0Zvcm1EYXRhKHNlYXJjaFBhcmFtcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGdldEludmFsaWRCb2R5RXJyb3IoKTtcbiAgICB9XG4gIH1cblxuICBsZXQgc3VibWlzc2lvbjogU3VibWlzc2lvbiA9IHtcbiAgICBmb3JtTWV0aG9kLFxuICAgIGZvcm1BY3Rpb24sXG4gICAgZm9ybUVuY1R5cGU6XG4gICAgICAob3B0cyAmJiBvcHRzLmZvcm1FbmNUeXBlKSB8fCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLFxuICAgIGZvcm1EYXRhLFxuICAgIGpzb246IHVuZGVmaW5lZCxcbiAgICB0ZXh0OiB1bmRlZmluZWQsXG4gIH07XG5cbiAgaWYgKGlzTXV0YXRpb25NZXRob2Qoc3VibWlzc2lvbi5mb3JtTWV0aG9kKSkge1xuICAgIHJldHVybiB7IHBhdGgsIHN1Ym1pc3Npb24gfTtcbiAgfVxuXG4gIC8vIEZsYXR0ZW4gc3VibWlzc2lvbiBvbnRvIFVSTFNlYXJjaFBhcmFtcyBmb3IgR0VUIHN1Ym1pc3Npb25zXG4gIGxldCBwYXJzZWRQYXRoID0gcGFyc2VQYXRoKHBhdGgpO1xuICAvLyBPbiBHRVQgbmF2aWdhdGlvbiBzdWJtaXNzaW9ucyB3ZSBjYW4gZHJvcCB0aGUgP2luZGV4IHBhcmFtIGZyb20gdGhlXG4gIC8vIHJlc3VsdGluZyBsb2NhdGlvbiBzaW5jZSBhbGwgbG9hZGVycyB3aWxsIHJ1bi4gIEJ1dCBmZXRjaGVyIEdFVCBzdWJtaXNzaW9uc1xuICAvLyBvbmx5IHJ1biBhIHNpbmdsZSBsb2FkZXIgc28gd2UgbmVlZCB0byBwcmVzZXJ2ZSBhbnkgaW5jb21pbmcgP2luZGV4IHBhcmFtc1xuICBpZiAoaXNGZXRjaGVyICYmIHBhcnNlZFBhdGguc2VhcmNoICYmIGhhc05ha2VkSW5kZXhRdWVyeShwYXJzZWRQYXRoLnNlYXJjaCkpIHtcbiAgICBzZWFyY2hQYXJhbXMuYXBwZW5kKFwiaW5kZXhcIiwgXCJcIik7XG4gIH1cbiAgcGFyc2VkUGF0aC5zZWFyY2ggPSBgPyR7c2VhcmNoUGFyYW1zfWA7XG5cbiAgcmV0dXJuIHsgcGF0aDogY3JlYXRlUGF0aChwYXJzZWRQYXRoKSwgc3VibWlzc2lvbiB9O1xufVxuXG4vLyBGaWx0ZXIgb3V0IGFsbCByb3V0ZXMgYmVsb3cgYW55IGNhdWdodCBlcnJvciBhcyB0aGV5IGFyZW4ndCBnb2luZyB0b1xuLy8gcmVuZGVyIHNvIHdlIGRvbid0IG5lZWQgdG8gbG9hZCB0aGVtXG5mdW5jdGlvbiBnZXRMb2FkZXJNYXRjaGVzVW50aWxCb3VuZGFyeShcbiAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICBib3VuZGFyeUlkPzogc3RyaW5nXG4pIHtcbiAgbGV0IGJvdW5kYXJ5TWF0Y2hlcyA9IG1hdGNoZXM7XG4gIGlmIChib3VuZGFyeUlkKSB7XG4gICAgbGV0IGluZGV4ID0gbWF0Y2hlcy5maW5kSW5kZXgoKG0pID0+IG0ucm91dGUuaWQgPT09IGJvdW5kYXJ5SWQpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBib3VuZGFyeU1hdGNoZXMgPSBtYXRjaGVzLnNsaWNlKDAsIGluZGV4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJvdW5kYXJ5TWF0Y2hlcztcbn1cblxuZnVuY3Rpb24gZ2V0TWF0Y2hlc1RvTG9hZChcbiAgaGlzdG9yeTogSGlzdG9yeSxcbiAgc3RhdGU6IFJvdXRlclN0YXRlLFxuICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gIHN1Ym1pc3Npb246IFN1Ym1pc3Npb24gfCB1bmRlZmluZWQsXG4gIGxvY2F0aW9uOiBMb2NhdGlvbixcbiAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZDogYm9vbGVhbixcbiAgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXM6IHN0cmluZ1tdLFxuICBjYW5jZWxsZWRGZXRjaGVyTG9hZHM6IHN0cmluZ1tdLFxuICBmZXRjaExvYWRNYXRjaGVzOiBNYXA8c3RyaW5nLCBGZXRjaExvYWRNYXRjaD4sXG4gIGZldGNoUmVkaXJlY3RJZHM6IFNldDxzdHJpbmc+LFxuICByb3V0ZXNUb1VzZTogQWdub3N0aWNEYXRhUm91dGVPYmplY3RbXSxcbiAgYmFzZW5hbWU6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgcGVuZGluZ0FjdGlvbkRhdGE/OiBSb3V0ZURhdGEsXG4gIHBlbmRpbmdFcnJvcj86IFJvdXRlRGF0YVxuKTogW0Fnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSwgUmV2YWxpZGF0aW5nRmV0Y2hlcltdXSB7XG4gIGxldCBhY3Rpb25SZXN1bHQgPSBwZW5kaW5nRXJyb3JcbiAgICA/IE9iamVjdC52YWx1ZXMocGVuZGluZ0Vycm9yKVswXVxuICAgIDogcGVuZGluZ0FjdGlvbkRhdGFcbiAgICA/IE9iamVjdC52YWx1ZXMocGVuZGluZ0FjdGlvbkRhdGEpWzBdXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgbGV0IGN1cnJlbnRVcmwgPSBoaXN0b3J5LmNyZWF0ZVVSTChzdGF0ZS5sb2NhdGlvbik7XG4gIGxldCBuZXh0VXJsID0gaGlzdG9yeS5jcmVhdGVVUkwobG9jYXRpb24pO1xuXG4gIC8vIFBpY2sgbmF2aWdhdGlvbiBtYXRjaGVzIHRoYXQgYXJlIG5ldC1uZXcgb3IgcXVhbGlmeSBmb3IgcmV2YWxpZGF0aW9uXG4gIGxldCBib3VuZGFyeUlkID0gcGVuZGluZ0Vycm9yID8gT2JqZWN0LmtleXMocGVuZGluZ0Vycm9yKVswXSA6IHVuZGVmaW5lZDtcbiAgbGV0IGJvdW5kYXJ5TWF0Y2hlcyA9IGdldExvYWRlck1hdGNoZXNVbnRpbEJvdW5kYXJ5KG1hdGNoZXMsIGJvdW5kYXJ5SWQpO1xuXG4gIGxldCBuYXZpZ2F0aW9uTWF0Y2hlcyA9IGJvdW5kYXJ5TWF0Y2hlcy5maWx0ZXIoKG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIGlmIChtYXRjaC5yb3V0ZS5sYXp5KSB7XG4gICAgICAvLyBXZSBoYXZlbid0IGxvYWRlZCB0aGlzIHJvdXRlIHlldCBzbyB3ZSBkb24ndCBrbm93IGlmIGl0J3MgZ290IGEgbG9hZGVyIVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChtYXRjaC5yb3V0ZS5sb2FkZXIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEFsd2F5cyBjYWxsIHRoZSBsb2FkZXIgb24gbmV3IHJvdXRlIGluc3RhbmNlcyBhbmQgcGVuZGluZyBkZWZlciBjYW5jZWxsYXRpb25zXG4gICAgaWYgKFxuICAgICAgaXNOZXdMb2FkZXIoc3RhdGUubG9hZGVyRGF0YSwgc3RhdGUubWF0Y2hlc1tpbmRleF0sIG1hdGNoKSB8fFxuICAgICAgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXMuc29tZSgoaWQpID0+IGlkID09PSBtYXRjaC5yb3V0ZS5pZClcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gZm9yIHdoZW4gd2UgcmV2YWxpZGF0ZS4gIElmIHRoZSByb3V0ZVxuICAgIC8vIHByb3ZpZGVzIGl0J3Mgb3duIGltcGxlbWVudGF0aW9uLCB0aGVuIHdlIGdpdmUgdGhlbSBmdWxsIGNvbnRyb2wgYnV0XG4gICAgLy8gcHJvdmlkZSB0aGlzIHZhbHVlIHNvIHRoZXkgY2FuIGxldmVyYWdlIGl0IGlmIG5lZWRlZCBhZnRlciB0aGV5IGNoZWNrXG4gICAgLy8gdGhlaXIgb3duIHNwZWNpZmljIHVzZSBjYXNlc1xuICAgIGxldCBjdXJyZW50Um91dGVNYXRjaCA9IHN0YXRlLm1hdGNoZXNbaW5kZXhdO1xuICAgIGxldCBuZXh0Um91dGVNYXRjaCA9IG1hdGNoO1xuXG4gICAgcmV0dXJuIHNob3VsZFJldmFsaWRhdGVMb2FkZXIobWF0Y2gsIHtcbiAgICAgIGN1cnJlbnRVcmwsXG4gICAgICBjdXJyZW50UGFyYW1zOiBjdXJyZW50Um91dGVNYXRjaC5wYXJhbXMsXG4gICAgICBuZXh0VXJsLFxuICAgICAgbmV4dFBhcmFtczogbmV4dFJvdXRlTWF0Y2gucGFyYW1zLFxuICAgICAgLi4uc3VibWlzc2lvbixcbiAgICAgIGFjdGlvblJlc3VsdCxcbiAgICAgIGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlOlxuICAgICAgICAvLyBGb3JjZWQgcmV2YWxpZGF0aW9uIGR1ZSB0byBzdWJtaXNzaW9uLCB1c2VSZXZhbGlkYXRvciwgb3IgWC1SZW1peC1SZXZhbGlkYXRlXG4gICAgICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgfHxcbiAgICAgICAgLy8gQ2xpY2tlZCB0aGUgc2FtZSBsaW5rLCByZXN1Ym1pdHRlZCBhIEdFVCBmb3JtXG4gICAgICAgIGN1cnJlbnRVcmwucGF0aG5hbWUgKyBjdXJyZW50VXJsLnNlYXJjaCA9PT1cbiAgICAgICAgICBuZXh0VXJsLnBhdGhuYW1lICsgbmV4dFVybC5zZWFyY2ggfHxcbiAgICAgICAgLy8gU2VhcmNoIHBhcmFtcyBhZmZlY3QgYWxsIGxvYWRlcnNcbiAgICAgICAgY3VycmVudFVybC5zZWFyY2ggIT09IG5leHRVcmwuc2VhcmNoIHx8XG4gICAgICAgIGlzTmV3Um91dGVJbnN0YW5jZShjdXJyZW50Um91dGVNYXRjaCwgbmV4dFJvdXRlTWF0Y2gpLFxuICAgIH0pO1xuICB9KTtcblxuICAvLyBQaWNrIGZldGNoZXIubG9hZHMgdGhhdCBuZWVkIHRvIGJlIHJldmFsaWRhdGVkXG4gIGxldCByZXZhbGlkYXRpbmdGZXRjaGVyczogUmV2YWxpZGF0aW5nRmV0Y2hlcltdID0gW107XG4gIGZldGNoTG9hZE1hdGNoZXMuZm9yRWFjaCgoZiwga2V5KSA9PiB7XG4gICAgLy8gRG9uJ3QgcmV2YWxpZGF0ZSBpZiBmZXRjaGVyIHdvbid0IGJlIHByZXNlbnQgaW4gdGhlIHN1YnNlcXVlbnQgcmVuZGVyXG4gICAgaWYgKCFtYXRjaGVzLnNvbWUoKG0pID0+IG0ucm91dGUuaWQgPT09IGYucm91dGVJZCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgZmV0Y2hlck1hdGNoZXMgPSBtYXRjaFJvdXRlcyhyb3V0ZXNUb1VzZSwgZi5wYXRoLCBiYXNlbmFtZSk7XG5cbiAgICAvLyBJZiB0aGUgZmV0Y2hlciBwYXRoIG5vIGxvbmdlciBtYXRjaGVzLCBwdXNoIGl0IGluIHdpdGggbnVsbCBtYXRjaGVzIHNvXG4gICAgLy8gd2UgY2FuIHRyaWdnZXIgYSA0MDQgaW4gY2FsbExvYWRlcnNBbmRNYXliZVJlc29sdmVEYXRhLiAgTm90ZSB0aGlzIGlzXG4gICAgLy8gY3VycmVudGx5IG9ubHkgYSB1c2UtY2FzZSBmb3IgUmVtaXggSE1SIHdoZXJlIHRoZSByb3V0ZSB0cmVlIGNhbiBjaGFuZ2VcbiAgICAvLyBhdCBydW50aW1lIGFuZCByZW1vdmUgYSByb3V0ZSBwcmV2aW91c2x5IGxvYWRlZCB2aWEgYSBmZXRjaGVyXG4gICAgaWYgKCFmZXRjaGVyTWF0Y2hlcykge1xuICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMucHVzaCh7XG4gICAgICAgIGtleSxcbiAgICAgICAgcm91dGVJZDogZi5yb3V0ZUlkLFxuICAgICAgICBwYXRoOiBmLnBhdGgsXG4gICAgICAgIG1hdGNoZXM6IG51bGwsXG4gICAgICAgIG1hdGNoOiBudWxsLFxuICAgICAgICBjb250cm9sbGVyOiBudWxsLFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUmV2YWxpZGF0aW5nIGZldGNoZXJzIGFyZSBkZWNvdXBsZWQgZnJvbSB0aGUgcm91dGUgbWF0Y2hlcyBzaW5jZSB0aGV5XG4gICAgLy8gbG9hZCBmcm9tIGEgc3RhdGljIGhyZWYuICBUaGV5IHJldmFsaWRhdGUgYmFzZWQgb24gZXhwbGljaXQgcmV2YWxpZGF0aW9uXG4gICAgLy8gKHN1Ym1pc3Npb24sIHVzZVJldmFsaWRhdG9yLCBvciBYLVJlbWl4LVJldmFsaWRhdGUpXG4gICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICBsZXQgZmV0Y2hlck1hdGNoID0gZ2V0VGFyZ2V0TWF0Y2goZmV0Y2hlck1hdGNoZXMsIGYucGF0aCk7XG5cbiAgICBsZXQgc2hvdWxkUmV2YWxpZGF0ZSA9IGZhbHNlO1xuICAgIGlmIChmZXRjaFJlZGlyZWN0SWRzLmhhcyhrZXkpKSB7XG4gICAgICAvLyBOZXZlciB0cmlnZ2VyIGEgcmV2YWxpZGF0aW9uIG9mIGFuIGFjdGl2ZWx5IHJlZGlyZWN0aW5nIGZldGNoZXJcbiAgICAgIHNob3VsZFJldmFsaWRhdGUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGNhbmNlbGxlZEZldGNoZXJMb2Fkcy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAvLyBBbHdheXMgcmV2YWxpZGF0ZSBpZiB0aGUgZmV0Y2hlciB3YXMgY2FuY2VsbGVkXG4gICAgICBzaG91bGRSZXZhbGlkYXRlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgZmV0Y2hlciAmJlxuICAgICAgZmV0Y2hlci5zdGF0ZSAhPT0gXCJpZGxlXCIgJiZcbiAgICAgIGZldGNoZXIuZGF0YSA9PT0gdW5kZWZpbmVkXG4gICAgKSB7XG4gICAgICAvLyBJZiB0aGUgZmV0Y2hlciBoYXNuJ3QgZXZlciBjb21wbGV0ZWQgbG9hZGluZyB5ZXQsIHRoZW4gdGhpcyBpc24ndCBhXG4gICAgICAvLyByZXZhbGlkYXRpb24sIGl0IHdvdWxkIGp1c3QgYmUgYSBicmFuZCBuZXcgbG9hZCBpZiBhbiBleHBsaWNpdFxuICAgICAgLy8gcmV2YWxpZGF0aW9uIGlzIHJlcXVpcmVkXG4gICAgICBzaG91bGRSZXZhbGlkYXRlID0gaXNSZXZhbGlkYXRpb25SZXF1aXJlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlIGZhbGwgYmFjayBvbiBhbnkgdXNlci1kZWZpbmVkIHNob3VsZFJldmFsaWRhdGUsIGRlZmF1bHRpbmdcbiAgICAgIC8vIHRvIGV4cGxpY2l0IHJldmFsaWRhdGlvbnMgb25seVxuICAgICAgc2hvdWxkUmV2YWxpZGF0ZSA9IHNob3VsZFJldmFsaWRhdGVMb2FkZXIoZmV0Y2hlck1hdGNoLCB7XG4gICAgICAgIGN1cnJlbnRVcmwsXG4gICAgICAgIGN1cnJlbnRQYXJhbXM6IHN0YXRlLm1hdGNoZXNbc3RhdGUubWF0Y2hlcy5sZW5ndGggLSAxXS5wYXJhbXMsXG4gICAgICAgIG5leHRVcmwsXG4gICAgICAgIG5leHRQYXJhbXM6IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5wYXJhbXMsXG4gICAgICAgIC4uLnN1Ym1pc3Npb24sXG4gICAgICAgIGFjdGlvblJlc3VsdCxcbiAgICAgICAgZGVmYXVsdFNob3VsZFJldmFsaWRhdGU6IGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkUmV2YWxpZGF0ZSkge1xuICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMucHVzaCh7XG4gICAgICAgIGtleSxcbiAgICAgICAgcm91dGVJZDogZi5yb3V0ZUlkLFxuICAgICAgICBwYXRoOiBmLnBhdGgsXG4gICAgICAgIG1hdGNoZXM6IGZldGNoZXJNYXRjaGVzLFxuICAgICAgICBtYXRjaDogZmV0Y2hlck1hdGNoLFxuICAgICAgICBjb250cm9sbGVyOiBuZXcgQWJvcnRDb250cm9sbGVyKCksXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBbbmF2aWdhdGlvbk1hdGNoZXMsIHJldmFsaWRhdGluZ0ZldGNoZXJzXTtcbn1cblxuZnVuY3Rpb24gaXNOZXdMb2FkZXIoXG4gIGN1cnJlbnRMb2FkZXJEYXRhOiBSb3V0ZURhdGEsXG4gIGN1cnJlbnRNYXRjaDogQWdub3N0aWNEYXRhUm91dGVNYXRjaCxcbiAgbWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hcbikge1xuICBsZXQgaXNOZXcgPVxuICAgIC8vIFthXSAtPiBbYSwgYl1cbiAgICAhY3VycmVudE1hdGNoIHx8XG4gICAgLy8gW2EsIGJdIC0+IFthLCBjXVxuICAgIG1hdGNoLnJvdXRlLmlkICE9PSBjdXJyZW50TWF0Y2gucm91dGUuaWQ7XG5cbiAgLy8gSGFuZGxlIHRoZSBjYXNlIHRoYXQgd2UgZG9uJ3QgaGF2ZSBkYXRhIGZvciBhIHJlLXVzZWQgcm91dGUsIHBvdGVudGlhbGx5XG4gIC8vIGZyb20gYSBwcmlvciBlcnJvciBvciBmcm9tIGEgY2FuY2VsbGVkIHBlbmRpbmcgZGVmZXJyZWRcbiAgbGV0IGlzTWlzc2luZ0RhdGEgPSBjdXJyZW50TG9hZGVyRGF0YVttYXRjaC5yb3V0ZS5pZF0gPT09IHVuZGVmaW5lZDtcblxuICAvLyBBbHdheXMgbG9hZCBpZiB0aGlzIGlzIGEgbmV0LW5ldyByb3V0ZSBvciB3ZSBkb24ndCB5ZXQgaGF2ZSBkYXRhXG4gIHJldHVybiBpc05ldyB8fCBpc01pc3NpbmdEYXRhO1xufVxuXG5mdW5jdGlvbiBpc05ld1JvdXRlSW5zdGFuY2UoXG4gIGN1cnJlbnRNYXRjaDogQWdub3N0aWNEYXRhUm91dGVNYXRjaCxcbiAgbWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hcbikge1xuICBsZXQgY3VycmVudFBhdGggPSBjdXJyZW50TWF0Y2gucm91dGUucGF0aDtcbiAgcmV0dXJuIChcbiAgICAvLyBwYXJhbSBjaGFuZ2UgZm9yIHRoaXMgbWF0Y2gsIC91c2Vycy8xMjMgLT4gL3VzZXJzLzQ1NlxuICAgIGN1cnJlbnRNYXRjaC5wYXRobmFtZSAhPT0gbWF0Y2gucGF0aG5hbWUgfHxcbiAgICAvLyBzcGxhdCBwYXJhbSBjaGFuZ2VkLCB3aGljaCBpcyBub3QgcHJlc2VudCBpbiBtYXRjaC5wYXRoXG4gICAgLy8gZS5nLiAvZmlsZXMvaW1hZ2VzL2F2YXRhci5qcGcgLT4gZmlsZXMvZmluYW5jZXMueGxzXG4gICAgKGN1cnJlbnRQYXRoICE9IG51bGwgJiZcbiAgICAgIGN1cnJlbnRQYXRoLmVuZHNXaXRoKFwiKlwiKSAmJlxuICAgICAgY3VycmVudE1hdGNoLnBhcmFtc1tcIipcIl0gIT09IG1hdGNoLnBhcmFtc1tcIipcIl0pXG4gICk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFJldmFsaWRhdGVMb2FkZXIoXG4gIGxvYWRlck1hdGNoOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoLFxuICBhcmc6IFNob3VsZFJldmFsaWRhdGVGdW5jdGlvbkFyZ3Ncbikge1xuICBpZiAobG9hZGVyTWF0Y2gucm91dGUuc2hvdWxkUmV2YWxpZGF0ZSkge1xuICAgIGxldCByb3V0ZUNob2ljZSA9IGxvYWRlck1hdGNoLnJvdXRlLnNob3VsZFJldmFsaWRhdGUoYXJnKTtcbiAgICBpZiAodHlwZW9mIHJvdXRlQ2hvaWNlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgcmV0dXJuIHJvdXRlQ2hvaWNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhcmcuZGVmYXVsdFNob3VsZFJldmFsaWRhdGU7XG59XG5cbi8qKlxuICogRXhlY3V0ZSByb3V0ZS5sYXp5KCkgbWV0aG9kcyB0byBsYXppbHkgbG9hZCByb3V0ZSBtb2R1bGVzIChsb2FkZXIsIGFjdGlvbixcbiAqIHNob3VsZFJldmFsaWRhdGUpIGFuZCB1cGRhdGUgdGhlIHJvdXRlTWFuaWZlc3QgaW4gcGxhY2Ugd2hpY2ggc2hhcmVzIG9iamVjdHNcbiAqIHdpdGggZGF0YVJvdXRlcyBzbyB0aG9zZSBnZXQgdXBkYXRlZCBhcyB3ZWxsLlxuICovXG5hc3luYyBmdW5jdGlvbiBsb2FkTGF6eVJvdXRlTW9kdWxlKFxuICByb3V0ZTogQWdub3N0aWNEYXRhUm91dGVPYmplY3QsXG4gIG1hcFJvdXRlUHJvcGVydGllczogTWFwUm91dGVQcm9wZXJ0aWVzRnVuY3Rpb24sXG4gIG1hbmlmZXN0OiBSb3V0ZU1hbmlmZXN0XG4pIHtcbiAgaWYgKCFyb3V0ZS5sYXp5KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IGxhenlSb3V0ZSA9IGF3YWl0IHJvdXRlLmxhenkoKTtcblxuICAvLyBJZiB0aGUgbGF6eSByb3V0ZSBmdW5jdGlvbiB3YXMgZXhlY3V0ZWQgYW5kIHJlbW92ZWQgYnkgYW5vdGhlciBwYXJhbGxlbFxuICAvLyBjYWxsIHRoZW4gd2UgY2FuIHJldHVybiAtIGZpcnN0IGxhenkoKSB0byBmaW5pc2ggd2lucyBiZWNhdXNlIHRoZSByZXR1cm5cbiAgLy8gdmFsdWUgb2YgbGF6eSBpcyBleHBlY3RlZCB0byBiZSBzdGF0aWNcbiAgaWYgKCFyb3V0ZS5sYXp5KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IHJvdXRlVG9VcGRhdGUgPSBtYW5pZmVzdFtyb3V0ZS5pZF07XG4gIGludmFyaWFudChyb3V0ZVRvVXBkYXRlLCBcIk5vIHJvdXRlIGZvdW5kIGluIG1hbmlmZXN0XCIpO1xuXG4gIC8vIFVwZGF0ZSB0aGUgcm91dGUgaW4gcGxhY2UuICBUaGlzIHNob3VsZCBiZSBzYWZlIGJlY2F1c2UgdGhlcmUncyBubyB3YXlcbiAgLy8gd2UgY291bGQgeWV0IGJlIHNpdHRpbmcgb24gdGhpcyByb3V0ZSBhcyB3ZSBjYW4ndCBnZXQgdGhlcmUgd2l0aG91dFxuICAvLyByZXNvbHZpbmcgbGF6eSgpIGZpcnN0LlxuICAvL1xuICAvLyBUaGlzIGlzIGRpZmZlcmVudCB0aGFuIHRoZSBITVIgXCJ1cGRhdGVcIiB1c2UtY2FzZSB3aGVyZSB3ZSBtYXkgYWN0aXZlbHkgYmVcbiAgLy8gb24gdGhlIHJvdXRlIGJlaW5nIHVwZGF0ZWQuICBUaGUgbWFpbiBjb25jZXJuIGJvaWxzIGRvd24gdG8gXCJkb2VzIHRoaXNcbiAgLy8gbXV0YXRpb24gYWZmZWN0IGFueSBvbmdvaW5nIG5hdmlnYXRpb25zIG9yIGFueSBjdXJyZW50IHN0YXRlLm1hdGNoZXNcbiAgLy8gdmFsdWVzP1wiLiAgSWYgbm90LCBpdCBzaG91bGQgYmUgc2FmZSB0byB1cGRhdGUgaW4gcGxhY2UuXG4gIGxldCByb3V0ZVVwZGF0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fTtcbiAgZm9yIChsZXQgbGF6eVJvdXRlUHJvcGVydHkgaW4gbGF6eVJvdXRlKSB7XG4gICAgbGV0IHN0YXRpY1JvdXRlVmFsdWUgPVxuICAgICAgcm91dGVUb1VwZGF0ZVtsYXp5Um91dGVQcm9wZXJ0eSBhcyBrZXlvZiB0eXBlb2Ygcm91dGVUb1VwZGF0ZV07XG5cbiAgICBsZXQgaXNQcm9wZXJ0eVN0YXRpY2FsbHlEZWZpbmVkID1cbiAgICAgIHN0YXRpY1JvdXRlVmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgLy8gVGhpcyBwcm9wZXJ0eSBpc24ndCBzdGF0aWMgc2luY2UgaXQgc2hvdWxkIGFsd2F5cyBiZSB1cGRhdGVkIGJhc2VkXG4gICAgICAvLyBvbiB0aGUgcm91dGUgdXBkYXRlc1xuICAgICAgbGF6eVJvdXRlUHJvcGVydHkgIT09IFwiaGFzRXJyb3JCb3VuZGFyeVwiO1xuXG4gICAgd2FybmluZyhcbiAgICAgICFpc1Byb3BlcnR5U3RhdGljYWxseURlZmluZWQsXG4gICAgICBgUm91dGUgXCIke3JvdXRlVG9VcGRhdGUuaWR9XCIgaGFzIGEgc3RhdGljIHByb3BlcnR5IFwiJHtsYXp5Um91dGVQcm9wZXJ0eX1cIiBgICtcbiAgICAgICAgYGRlZmluZWQgYnV0IGl0cyBsYXp5IGZ1bmN0aW9uIGlzIGFsc28gcmV0dXJuaW5nIGEgdmFsdWUgZm9yIHRoaXMgcHJvcGVydHkuIGAgK1xuICAgICAgICBgVGhlIGxhenkgcm91dGUgcHJvcGVydHkgXCIke2xhenlSb3V0ZVByb3BlcnR5fVwiIHdpbGwgYmUgaWdub3JlZC5gXG4gICAgKTtcblxuICAgIGlmIChcbiAgICAgICFpc1Byb3BlcnR5U3RhdGljYWxseURlZmluZWQgJiZcbiAgICAgICFpbW11dGFibGVSb3V0ZUtleXMuaGFzKGxhenlSb3V0ZVByb3BlcnR5IGFzIEltbXV0YWJsZVJvdXRlS2V5KVxuICAgICkge1xuICAgICAgcm91dGVVcGRhdGVzW2xhenlSb3V0ZVByb3BlcnR5XSA9XG4gICAgICAgIGxhenlSb3V0ZVtsYXp5Um91dGVQcm9wZXJ0eSBhcyBrZXlvZiB0eXBlb2YgbGF6eVJvdXRlXTtcbiAgICB9XG4gIH1cblxuICAvLyBNdXRhdGUgdGhlIHJvdXRlIHdpdGggdGhlIHByb3ZpZGVkIHVwZGF0ZXMuICBEbyB0aGlzIGZpcnN0IHNvIHdlIHBhc3NcbiAgLy8gdGhlIHVwZGF0ZWQgdmVyc2lvbiB0byBtYXBSb3V0ZVByb3BlcnRpZXNcbiAgT2JqZWN0LmFzc2lnbihyb3V0ZVRvVXBkYXRlLCByb3V0ZVVwZGF0ZXMpO1xuXG4gIC8vIE11dGF0ZSB0aGUgYGhhc0Vycm9yQm91bmRhcnlgIHByb3BlcnR5IG9uIHRoZSByb3V0ZSBiYXNlZCBvbiB0aGUgcm91dGVcbiAgLy8gdXBkYXRlcyBhbmQgcmVtb3ZlIHRoZSBgbGF6eWAgZnVuY3Rpb24gc28gd2UgZG9uJ3QgcmVzb2x2ZSB0aGUgbGF6eVxuICAvLyByb3V0ZSBhZ2Fpbi5cbiAgT2JqZWN0LmFzc2lnbihyb3V0ZVRvVXBkYXRlLCB7XG4gICAgLy8gVG8ga2VlcCB0aGluZ3MgZnJhbWV3b3JrIGFnbm9zdGljLCB3ZSB1c2UgdGhlIHByb3ZpZGVkXG4gICAgLy8gYG1hcFJvdXRlUHJvcGVydGllc2AgKG9yIHdyYXBwZWQgYGRldGVjdEVycm9yQm91bmRhcnlgKSBmdW5jdGlvbiB0b1xuICAgIC8vIHNldCB0aGUgZnJhbWV3b3JrLWF3YXJlIHByb3BlcnRpZXMgKGBlbGVtZW50YC9gaGFzRXJyb3JCb3VuZGFyeWApIHNpbmNlXG4gICAgLy8gdGhlIGxvZ2ljIHdpbGwgZGlmZmVyIGJldHdlZW4gZnJhbWV3b3Jrcy5cbiAgICAuLi5tYXBSb3V0ZVByb3BlcnRpZXMocm91dGVUb1VwZGF0ZSksXG4gICAgbGF6eTogdW5kZWZpbmVkLFxuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY2FsbExvYWRlck9yQWN0aW9uKFxuICB0eXBlOiBcImxvYWRlclwiIHwgXCJhY3Rpb25cIixcbiAgcmVxdWVzdDogUmVxdWVzdCxcbiAgbWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gsXG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgbWFuaWZlc3Q6IFJvdXRlTWFuaWZlc3QsXG4gIG1hcFJvdXRlUHJvcGVydGllczogTWFwUm91dGVQcm9wZXJ0aWVzRnVuY3Rpb24sXG4gIGJhc2VuYW1lOiBzdHJpbmcsXG4gIG9wdHM6IHtcbiAgICBpc1N0YXRpY1JlcXVlc3Q/OiBib29sZWFuO1xuICAgIGlzUm91dGVSZXF1ZXN0PzogYm9vbGVhbjtcbiAgICByZXF1ZXN0Q29udGV4dD86IHVua25vd247XG4gIH0gPSB7fVxuKTogUHJvbWlzZTxEYXRhUmVzdWx0PiB7XG4gIGxldCByZXN1bHRUeXBlO1xuICBsZXQgcmVzdWx0O1xuICBsZXQgb25SZWplY3Q6ICgoKSA9PiB2b2lkKSB8IHVuZGVmaW5lZDtcblxuICBsZXQgcnVuSGFuZGxlciA9IChoYW5kbGVyOiBBY3Rpb25GdW5jdGlvbiB8IExvYWRlckZ1bmN0aW9uKSA9PiB7XG4gICAgLy8gU2V0dXAgYSBwcm9taXNlIHdlIGNhbiByYWNlIGFnYWluc3Qgc28gdGhhdCBhYm9ydCBzaWduYWxzIHNob3J0IGNpcmN1aXRcbiAgICBsZXQgcmVqZWN0OiAoKSA9PiB2b2lkO1xuICAgIGxldCBhYm9ydFByb21pc2UgPSBuZXcgUHJvbWlzZSgoXywgcikgPT4gKHJlamVjdCA9IHIpKTtcbiAgICBvblJlamVjdCA9ICgpID0+IHJlamVjdCgpO1xuICAgIHJlcXVlc3Quc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvblJlamVjdCk7XG4gICAgcmV0dXJuIFByb21pc2UucmFjZShbXG4gICAgICBoYW5kbGVyKHtcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgcGFyYW1zOiBtYXRjaC5wYXJhbXMsXG4gICAgICAgIGNvbnRleHQ6IG9wdHMucmVxdWVzdENvbnRleHQsXG4gICAgICB9KSxcbiAgICAgIGFib3J0UHJvbWlzZSxcbiAgICBdKTtcbiAgfTtcblxuICB0cnkge1xuICAgIGxldCBoYW5kbGVyID0gbWF0Y2gucm91dGVbdHlwZV07XG5cbiAgICBpZiAobWF0Y2gucm91dGUubGF6eSkge1xuICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgLy8gUnVuIHN0YXRpY2FsbHkgZGVmaW5lZCBoYW5kbGVyIGluIHBhcmFsbGVsIHdpdGggbGF6eSgpXG4gICAgICAgIGxldCBoYW5kbGVyRXJyb3I7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgLy8gSWYgdGhlIGhhbmRsZXIgdGhyb3dzLCBkb24ndCBsZXQgaXQgaW1tZWRpYXRlbHkgYnViYmxlIG91dCxcbiAgICAgICAgICAvLyBzaW5jZSB3ZSBuZWVkIHRvIGxldCB0aGUgbGF6eSgpIGV4ZWN1dGlvbiBmaW5pc2ggc28gd2Uga25vdyBpZiB0aGlzXG4gICAgICAgICAgLy8gcm91dGUgaGFzIGEgYm91bmRhcnkgdGhhdCBjYW4gaGFuZGxlIHRoZSBlcnJvclxuICAgICAgICAgIHJ1bkhhbmRsZXIoaGFuZGxlcikuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIGhhbmRsZXJFcnJvciA9IGU7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgbG9hZExhenlSb3V0ZU1vZHVsZShtYXRjaC5yb3V0ZSwgbWFwUm91dGVQcm9wZXJ0aWVzLCBtYW5pZmVzdCksXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAoaGFuZGxlckVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgaGFuZGxlckVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IHZhbHVlc1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIExvYWQgbGF6eSByb3V0ZSBtb2R1bGUsIHRoZW4gcnVuIGFueSByZXR1cm5lZCBoYW5kbGVyXG4gICAgICAgIGF3YWl0IGxvYWRMYXp5Um91dGVNb2R1bGUobWF0Y2gucm91dGUsIG1hcFJvdXRlUHJvcGVydGllcywgbWFuaWZlc3QpO1xuXG4gICAgICAgIGhhbmRsZXIgPSBtYXRjaC5yb3V0ZVt0eXBlXTtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAvLyBIYW5kbGVyIHN0aWxsIHJ1biBldmVuIGlmIHdlIGdvdCBpbnRlcnJ1cHRlZCB0byBtYWludGFpbiBjb25zaXN0ZW5jeVxuICAgICAgICAgIC8vIHdpdGggdW4tYWJvcnRhYmxlIGJlaGF2aW9yIG9mIGhhbmRsZXIgZXhlY3V0aW9uIG9uIG5vbi1sYXp5IG9yXG4gICAgICAgICAgLy8gcHJldmlvdXNseS1sYXp5LWxvYWRlZCByb3V0ZXNcbiAgICAgICAgICByZXN1bHQgPSBhd2FpdCBydW5IYW5kbGVyKGhhbmRsZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiYWN0aW9uXCIpIHtcbiAgICAgICAgICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgICAgICAgbGV0IHBhdGhuYW1lID0gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaDtcbiAgICAgICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgcm91dGVJZDogbWF0Y2gucm91dGUuaWQsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbGF6eSgpIHJvdXRlIGhhcyBubyBsb2FkZXIgdG8gcnVuLiAgU2hvcnQgY2lyY3VpdCBoZXJlIHNvIHdlIGRvbid0XG4gICAgICAgICAgLy8gaGl0IHRoZSBpbnZhcmlhbnQgYmVsb3cgdGhhdCBlcnJvcnMgb24gcmV0dXJuaW5nIHVuZGVmaW5lZC5cbiAgICAgICAgICByZXR1cm4geyB0eXBlOiBSZXN1bHRUeXBlLmRhdGEsIGRhdGE6IHVuZGVmaW5lZCB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaGFuZGxlcikge1xuICAgICAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgICAgbGV0IHBhdGhuYW1lID0gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaDtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7XG4gICAgICAgIHBhdGhuYW1lLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGF3YWl0IHJ1bkhhbmRsZXIoaGFuZGxlcik7XG4gICAgfVxuXG4gICAgaW52YXJpYW50KFxuICAgICAgcmVzdWx0ICE9PSB1bmRlZmluZWQsXG4gICAgICBgWW91IGRlZmluZWQgJHt0eXBlID09PSBcImFjdGlvblwiID8gXCJhbiBhY3Rpb25cIiA6IFwiYSBsb2FkZXJcIn0gZm9yIHJvdXRlIGAgK1xuICAgICAgICBgXCIke21hdGNoLnJvdXRlLmlkfVwiIGJ1dCBkaWRuJ3QgcmV0dXJuIGFueXRoaW5nIGZyb20geW91ciBcXGAke3R5cGV9XFxgIGAgK1xuICAgICAgICBgZnVuY3Rpb24uIFBsZWFzZSByZXR1cm4gYSB2YWx1ZSBvciBcXGBudWxsXFxgLmBcbiAgICApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmVzdWx0VHlwZSA9IFJlc3VsdFR5cGUuZXJyb3I7XG4gICAgcmVzdWx0ID0gZTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAob25SZWplY3QpIHtcbiAgICAgIHJlcXVlc3Quc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvblJlamVjdCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzUmVzcG9uc2UocmVzdWx0KSkge1xuICAgIGxldCBzdGF0dXMgPSByZXN1bHQuc3RhdHVzO1xuXG4gICAgLy8gUHJvY2VzcyByZWRpcmVjdHNcbiAgICBpZiAocmVkaXJlY3RTdGF0dXNDb2Rlcy5oYXMoc3RhdHVzKSkge1xuICAgICAgbGV0IGxvY2F0aW9uID0gcmVzdWx0LmhlYWRlcnMuZ2V0KFwiTG9jYXRpb25cIik7XG4gICAgICBpbnZhcmlhbnQoXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBcIlJlZGlyZWN0cyByZXR1cm5lZC90aHJvd24gZnJvbSBsb2FkZXJzL2FjdGlvbnMgbXVzdCBoYXZlIGEgTG9jYXRpb24gaGVhZGVyXCJcbiAgICAgICk7XG5cbiAgICAgIC8vIFN1cHBvcnQgcmVsYXRpdmUgcm91dGluZyBpbiBpbnRlcm5hbCByZWRpcmVjdHNcbiAgICAgIGlmICghQUJTT0xVVEVfVVJMX1JFR0VYLnRlc3QobG9jYXRpb24pKSB7XG4gICAgICAgIGxvY2F0aW9uID0gbm9ybWFsaXplVG8oXG4gICAgICAgICAgbmV3IFVSTChyZXF1ZXN0LnVybCksXG4gICAgICAgICAgbWF0Y2hlcy5zbGljZSgwLCBtYXRjaGVzLmluZGV4T2YobWF0Y2gpICsgMSksXG4gICAgICAgICAgYmFzZW5hbWUsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICBsb2NhdGlvblxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmICghb3B0cy5pc1N0YXRpY1JlcXVlc3QpIHtcbiAgICAgICAgLy8gU3RyaXAgb2ZmIHRoZSBwcm90b2NvbCtvcmlnaW4gZm9yIHNhbWUtb3JpZ2luICsgc2FtZS1iYXNlbmFtZSBhYnNvbHV0ZVxuICAgICAgICAvLyByZWRpcmVjdHMuIElmIHRoaXMgaXMgYSBzdGF0aWMgcmVxdWVzdCwgd2UgY2FuIGxldCBpdCBnbyBiYWNrIHRvIHRoZVxuICAgICAgICAvLyBicm93c2VyIGFzLWlzXG4gICAgICAgIGxldCBjdXJyZW50VXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgICAgIGxldCB1cmwgPSBsb2NhdGlvbi5zdGFydHNXaXRoKFwiLy9cIilcbiAgICAgICAgICA/IG5ldyBVUkwoY3VycmVudFVybC5wcm90b2NvbCArIGxvY2F0aW9uKVxuICAgICAgICAgIDogbmV3IFVSTChsb2NhdGlvbik7XG4gICAgICAgIGxldCBpc1NhbWVCYXNlbmFtZSA9IHN0cmlwQmFzZW5hbWUodXJsLnBhdGhuYW1lLCBiYXNlbmFtZSkgIT0gbnVsbDtcbiAgICAgICAgaWYgKHVybC5vcmlnaW4gPT09IGN1cnJlbnRVcmwub3JpZ2luICYmIGlzU2FtZUJhc2VuYW1lKSB7XG4gICAgICAgICAgbG9jYXRpb24gPSB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoICsgdXJsLmhhc2g7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRG9uJ3QgcHJvY2VzcyByZWRpcmVjdHMgaW4gdGhlIHJvdXRlciBkdXJpbmcgc3RhdGljIHJlcXVlc3RzIHJlcXVlc3RzLlxuICAgICAgLy8gSW5zdGVhZCwgdGhyb3cgdGhlIFJlc3BvbnNlIGFuZCBsZXQgdGhlIHNlcnZlciBoYW5kbGUgaXQgd2l0aCBhbiBIVFRQXG4gICAgICAvLyByZWRpcmVjdC4gIFdlIGFsc28gdXBkYXRlIHRoZSBMb2NhdGlvbiBoZWFkZXIgaW4gcGxhY2UgaW4gdGhpcyBmbG93IHNvXG4gICAgICAvLyBiYXNlbmFtZSBhbmQgcmVsYXRpdmUgcm91dGluZyBpcyB0YWtlbiBpbnRvIGFjY291bnRcbiAgICAgIGlmIChvcHRzLmlzU3RhdGljUmVxdWVzdCkge1xuICAgICAgICByZXN1bHQuaGVhZGVycy5zZXQoXCJMb2NhdGlvblwiLCBsb2NhdGlvbik7XG4gICAgICAgIHRocm93IHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogUmVzdWx0VHlwZS5yZWRpcmVjdCxcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgcmV2YWxpZGF0ZTogcmVzdWx0LmhlYWRlcnMuZ2V0KFwiWC1SZW1peC1SZXZhbGlkYXRlXCIpICE9PSBudWxsLFxuICAgICAgICByZWxvYWREb2N1bWVudDogcmVzdWx0LmhlYWRlcnMuZ2V0KFwiWC1SZW1peC1SZWxvYWQtRG9jdW1lbnRcIikgIT09IG51bGwsXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEZvciBTU1Igc2luZ2xlLXJvdXRlIHJlcXVlc3RzLCB3ZSB3YW50IHRvIGhhbmQgUmVzcG9uc2VzIGJhY2sgZGlyZWN0bHlcbiAgICAvLyB3aXRob3V0IHVud3JhcHBpbmcuICBXZSBkbyB0aGlzIHdpdGggdGhlIFF1ZXJ5Um91dGVSZXNwb25zZSB3cmFwcGVyXG4gICAgLy8gaW50ZXJmYWNlIHNvIHdlIGNhbiBrbm93IHdoZXRoZXIgaXQgd2FzIHJldHVybmVkIG9yIHRocm93blxuICAgIGlmIChvcHRzLmlzUm91dGVSZXF1ZXN0KSB7XG4gICAgICBsZXQgcXVlcnlSb3V0ZVJlc3BvbnNlOiBRdWVyeVJvdXRlUmVzcG9uc2UgPSB7XG4gICAgICAgIHR5cGU6XG4gICAgICAgICAgcmVzdWx0VHlwZSA9PT0gUmVzdWx0VHlwZS5lcnJvciA/IFJlc3VsdFR5cGUuZXJyb3IgOiBSZXN1bHRUeXBlLmRhdGEsXG4gICAgICAgIHJlc3BvbnNlOiByZXN1bHQsXG4gICAgICB9O1xuICAgICAgdGhyb3cgcXVlcnlSb3V0ZVJlc3BvbnNlO1xuICAgIH1cblxuICAgIGxldCBkYXRhOiBhbnk7XG4gICAgbGV0IGNvbnRlbnRUeXBlID0gcmVzdWx0LmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpO1xuICAgIC8vIENoZWNrIGJldHdlZW4gd29yZCBib3VuZGFyaWVzIGluc3RlYWQgb2Ygc3RhcnRzV2l0aCgpIGR1ZSB0byB0aGUgbGFzdFxuICAgIC8vIHBhcmFncmFwaCBvZiBodHRwczovL2h0dHB3Zy5vcmcvc3BlY3MvcmZjOTExMC5odG1sI2ZpZWxkLmNvbnRlbnQtdHlwZVxuICAgIGlmIChjb250ZW50VHlwZSAmJiAvXFxiYXBwbGljYXRpb25cXC9qc29uXFxiLy50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgICAgZGF0YSA9IGF3YWl0IHJlc3VsdC5qc29uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSBhd2FpdCByZXN1bHQudGV4dCgpO1xuICAgIH1cblxuICAgIGlmIChyZXN1bHRUeXBlID09PSBSZXN1bHRUeXBlLmVycm9yKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiByZXN1bHRUeXBlLFxuICAgICAgICBlcnJvcjogbmV3IEVycm9yUmVzcG9uc2VJbXBsKHN0YXR1cywgcmVzdWx0LnN0YXR1c1RleHQsIGRhdGEpLFxuICAgICAgICBoZWFkZXJzOiByZXN1bHQuaGVhZGVycyxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZGF0YSxcbiAgICAgIGRhdGEsXG4gICAgICBzdGF0dXNDb2RlOiByZXN1bHQuc3RhdHVzLFxuICAgICAgaGVhZGVyczogcmVzdWx0LmhlYWRlcnMsXG4gICAgfTtcbiAgfVxuXG4gIGlmIChyZXN1bHRUeXBlID09PSBSZXN1bHRUeXBlLmVycm9yKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogcmVzdWx0VHlwZSwgZXJyb3I6IHJlc3VsdCB9O1xuICB9XG5cbiAgaWYgKGlzRGVmZXJyZWREYXRhKHJlc3VsdCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogUmVzdWx0VHlwZS5kZWZlcnJlZCxcbiAgICAgIGRlZmVycmVkRGF0YTogcmVzdWx0LFxuICAgICAgc3RhdHVzQ29kZTogcmVzdWx0LmluaXQ/LnN0YXR1cyxcbiAgICAgIGhlYWRlcnM6IHJlc3VsdC5pbml0Py5oZWFkZXJzICYmIG5ldyBIZWFkZXJzKHJlc3VsdC5pbml0LmhlYWRlcnMpLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4geyB0eXBlOiBSZXN1bHRUeXBlLmRhdGEsIGRhdGE6IHJlc3VsdCB9O1xufVxuXG4vLyBVdGlsaXR5IG1ldGhvZCBmb3IgY3JlYXRpbmcgdGhlIFJlcXVlc3QgaW5zdGFuY2VzIGZvciBsb2FkZXJzL2FjdGlvbnMgZHVyaW5nXG4vLyBjbGllbnQtc2lkZSBuYXZpZ2F0aW9ucyBhbmQgZmV0Y2hlcy4gIER1cmluZyBTU1Igd2Ugd2lsbCBhbHdheXMgaGF2ZSBhXG4vLyBSZXF1ZXN0IGluc3RhbmNlIGZyb20gdGhlIHN0YXRpYyBoYW5kbGVyIChxdWVyeS9xdWVyeVJvdXRlKVxuZnVuY3Rpb24gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoXG4gIGhpc3Rvcnk6IEhpc3RvcnksXG4gIGxvY2F0aW9uOiBzdHJpbmcgfCBMb2NhdGlvbixcbiAgc2lnbmFsOiBBYm9ydFNpZ25hbCxcbiAgc3VibWlzc2lvbj86IFN1Ym1pc3Npb25cbik6IFJlcXVlc3Qge1xuICBsZXQgdXJsID0gaGlzdG9yeS5jcmVhdGVVUkwoc3RyaXBIYXNoRnJvbVBhdGgobG9jYXRpb24pKS50b1N0cmluZygpO1xuICBsZXQgaW5pdDogUmVxdWVzdEluaXQgPSB7IHNpZ25hbCB9O1xuXG4gIGlmIChzdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2Qoc3VibWlzc2lvbi5mb3JtTWV0aG9kKSkge1xuICAgIGxldCB7IGZvcm1NZXRob2QsIGZvcm1FbmNUeXBlIH0gPSBzdWJtaXNzaW9uO1xuICAgIC8vIERpZG4ndCB0aGluayB3ZSBuZWVkZWQgdGhpcyBidXQgaXQgdHVybnMgb3V0IHVubGlrZSBvdGhlciBtZXRob2RzLCBwYXRjaFxuICAgIC8vIHdvbid0IGJlIHByb3Blcmx5IG5vcm1hbGl6ZWQgdG8gdXBwZXJjYXNlIGFuZCByZXN1bHRzIGluIGEgNDA1IGVycm9yLlxuICAgIC8vIFNlZTogaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtbWV0aG9kXG4gICAgaW5pdC5tZXRob2QgPSBmb3JtTWV0aG9kLnRvVXBwZXJDYXNlKCk7XG5cbiAgICBpZiAoZm9ybUVuY1R5cGUgPT09IFwiYXBwbGljYXRpb24vanNvblwiKSB7XG4gICAgICBpbml0LmhlYWRlcnMgPSBuZXcgSGVhZGVycyh7IFwiQ29udGVudC1UeXBlXCI6IGZvcm1FbmNUeXBlIH0pO1xuICAgICAgaW5pdC5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoc3VibWlzc2lvbi5qc29uKTtcbiAgICB9IGVsc2UgaWYgKGZvcm1FbmNUeXBlID09PSBcInRleHQvcGxhaW5cIikge1xuICAgICAgLy8gQ29udGVudC1UeXBlIGlzIGluZmVycmVkIChodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLXJlcXVlc3QpXG4gICAgICBpbml0LmJvZHkgPSBzdWJtaXNzaW9uLnRleHQ7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGZvcm1FbmNUeXBlID09PSBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICYmXG4gICAgICBzdWJtaXNzaW9uLmZvcm1EYXRhXG4gICAgKSB7XG4gICAgICAvLyBDb250ZW50LVR5cGUgaXMgaW5mZXJyZWQgKGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tcmVxdWVzdClcbiAgICAgIGluaXQuYm9keSA9IGNvbnZlcnRGb3JtRGF0YVRvU2VhcmNoUGFyYW1zKHN1Ym1pc3Npb24uZm9ybURhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDb250ZW50LVR5cGUgaXMgaW5mZXJyZWQgKGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tcmVxdWVzdClcbiAgICAgIGluaXQuYm9keSA9IHN1Ym1pc3Npb24uZm9ybURhdGE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KHVybCwgaW5pdCk7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRGb3JtRGF0YVRvU2VhcmNoUGFyYW1zKGZvcm1EYXRhOiBGb3JtRGF0YSk6IFVSTFNlYXJjaFBhcmFtcyB7XG4gIGxldCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG5cbiAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIGZvcm1EYXRhLmVudHJpZXMoKSkge1xuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm0tY29udHJvbC1pbmZyYXN0cnVjdHVyZS5odG1sI2NvbnZlcnRpbmctYW4tZW50cnktbGlzdC10by1hLWxpc3Qtb2YtbmFtZS12YWx1ZS1wYWlyc1xuICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZSA6IHZhbHVlLm5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIHNlYXJjaFBhcmFtcztcbn1cblxuZnVuY3Rpb24gY29udmVydFNlYXJjaFBhcmFtc1RvRm9ybURhdGEoXG4gIHNlYXJjaFBhcmFtczogVVJMU2VhcmNoUGFyYW1zXG4pOiBGb3JtRGF0YSB7XG4gIGxldCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2Ygc2VhcmNoUGFyYW1zLmVudHJpZXMoKSkge1xuICAgIGZvcm1EYXRhLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZm9ybURhdGE7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSb3V0ZUxvYWRlckRhdGEoXG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgbWF0Y2hlc1RvTG9hZDogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICByZXN1bHRzOiBEYXRhUmVzdWx0W10sXG4gIHBlbmRpbmdFcnJvcjogUm91dGVEYXRhIHwgdW5kZWZpbmVkLFxuICBhY3RpdmVEZWZlcnJlZHM6IE1hcDxzdHJpbmcsIERlZmVycmVkRGF0YT5cbik6IHtcbiAgbG9hZGVyRGF0YTogUm91dGVyU3RhdGVbXCJsb2FkZXJEYXRhXCJdO1xuICBlcnJvcnM6IFJvdXRlclN0YXRlW1wiZXJyb3JzXCJdIHwgbnVsbDtcbiAgc3RhdHVzQ29kZTogbnVtYmVyO1xuICBsb2FkZXJIZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBIZWFkZXJzPjtcbn0ge1xuICAvLyBGaWxsIGluIGxvYWRlckRhdGEvZXJyb3JzIGZyb20gb3VyIGxvYWRlcnNcbiAgbGV0IGxvYWRlckRhdGE6IFJvdXRlclN0YXRlW1wibG9hZGVyRGF0YVwiXSA9IHt9O1xuICBsZXQgZXJyb3JzOiBSb3V0ZXJTdGF0ZVtcImVycm9yc1wiXSB8IG51bGwgPSBudWxsO1xuICBsZXQgc3RhdHVzQ29kZTogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICBsZXQgZm91bmRFcnJvciA9IGZhbHNlO1xuICBsZXQgbG9hZGVySGVhZGVyczogUmVjb3JkPHN0cmluZywgSGVhZGVycz4gPSB7fTtcblxuICAvLyBQcm9jZXNzIGxvYWRlciByZXN1bHRzIGludG8gc3RhdGUubG9hZGVyRGF0YS9zdGF0ZS5lcnJvcnNcbiAgcmVzdWx0cy5mb3JFYWNoKChyZXN1bHQsIGluZGV4KSA9PiB7XG4gICAgbGV0IGlkID0gbWF0Y2hlc1RvTG9hZFtpbmRleF0ucm91dGUuaWQ7XG4gICAgaW52YXJpYW50KFxuICAgICAgIWlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSxcbiAgICAgIFwiQ2Fubm90IGhhbmRsZSByZWRpcmVjdCByZXN1bHRzIGluIHByb2Nlc3NMb2FkZXJEYXRhXCJcbiAgICApO1xuICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIExvb2sgdXB3YXJkcyBmcm9tIHRoZSBtYXRjaGVkIHJvdXRlIGZvciB0aGUgY2xvc2VzdCBhbmNlc3RvclxuICAgICAgLy8gZXJyb3IgYm91bmRhcnksIGRlZmF1bHRpbmcgdG8gdGhlIHJvb3QgbWF0Y2hcbiAgICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCBpZCk7XG4gICAgICBsZXQgZXJyb3IgPSByZXN1bHQuZXJyb3I7XG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgcGVuZGluZyBhY3Rpb24gZXJyb3IsIHdlIHJlcG9ydCBpdCBhdCB0aGUgaGlnaGVzdC1yb3V0ZVxuICAgICAgLy8gdGhhdCB0aHJvd3MgYSBsb2FkZXIgZXJyb3IsIGFuZCB0aGVuIGNsZWFyIGl0IG91dCB0byBpbmRpY2F0ZSB0aGF0XG4gICAgICAvLyBpdCB3YXMgY29uc3VtZWRcbiAgICAgIGlmIChwZW5kaW5nRXJyb3IpIHtcbiAgICAgICAgZXJyb3IgPSBPYmplY3QudmFsdWVzKHBlbmRpbmdFcnJvcilbMF07XG4gICAgICAgIHBlbmRpbmdFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgZXJyb3JzID0gZXJyb3JzIHx8IHt9O1xuXG4gICAgICAvLyBQcmVmZXIgaGlnaGVyIGVycm9yIHZhbHVlcyBpZiBsb3dlciBlcnJvcnMgYnViYmxlIHRvIHRoZSBzYW1lIGJvdW5kYXJ5XG4gICAgICBpZiAoZXJyb3JzW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdID09IG51bGwpIHtcbiAgICAgICAgZXJyb3JzW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdID0gZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIC8vIENsZWFyIG91ciBhbnkgcHJpb3IgbG9hZGVyRGF0YSBmb3IgdGhlIHRocm93aW5nIHJvdXRlXG4gICAgICBsb2FkZXJEYXRhW2lkXSA9IHVuZGVmaW5lZDtcblxuICAgICAgLy8gT25jZSB3ZSBmaW5kIG91ciBmaXJzdCAoaGlnaGVzdCkgZXJyb3IsIHdlIHNldCB0aGUgc3RhdHVzIGNvZGUgYW5kXG4gICAgICAvLyBwcmV2ZW50IGRlZXBlciBzdGF0dXMgY29kZXMgZnJvbSBvdmVycmlkaW5nXG4gICAgICBpZiAoIWZvdW5kRXJyb3IpIHtcbiAgICAgICAgZm91bmRFcnJvciA9IHRydWU7XG4gICAgICAgIHN0YXR1c0NvZGUgPSBpc1JvdXRlRXJyb3JSZXNwb25zZShyZXN1bHQuZXJyb3IpXG4gICAgICAgICAgPyByZXN1bHQuZXJyb3Iuc3RhdHVzXG4gICAgICAgICAgOiA1MDA7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0LmhlYWRlcnMpIHtcbiAgICAgICAgbG9hZGVySGVhZGVyc1tpZF0gPSByZXN1bHQuaGVhZGVycztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzRGVmZXJyZWRSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICBhY3RpdmVEZWZlcnJlZHMuc2V0KGlkLCByZXN1bHQuZGVmZXJyZWREYXRhKTtcbiAgICAgICAgbG9hZGVyRGF0YVtpZF0gPSByZXN1bHQuZGVmZXJyZWREYXRhLmRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2FkZXJEYXRhW2lkXSA9IHJlc3VsdC5kYXRhO1xuICAgICAgfVxuXG4gICAgICAvLyBFcnJvciBzdGF0dXMgY29kZXMgYWx3YXlzIG92ZXJyaWRlIHN1Y2Nlc3Mgc3RhdHVzIGNvZGVzLCBidXQgaWYgYWxsXG4gICAgICAvLyBsb2FkZXJzIGFyZSBzdWNjZXNzZnVsIHdlIHRha2UgdGhlIGRlZXBlc3Qgc3RhdHVzIGNvZGUuXG4gICAgICBpZiAoXG4gICAgICAgIHJlc3VsdC5zdGF0dXNDb2RlICE9IG51bGwgJiZcbiAgICAgICAgcmVzdWx0LnN0YXR1c0NvZGUgIT09IDIwMCAmJlxuICAgICAgICAhZm91bmRFcnJvclxuICAgICAgKSB7XG4gICAgICAgIHN0YXR1c0NvZGUgPSByZXN1bHQuc3RhdHVzQ29kZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQuaGVhZGVycykge1xuICAgICAgICBsb2FkZXJIZWFkZXJzW2lkXSA9IHJlc3VsdC5oZWFkZXJzO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gSWYgd2UgZGlkbid0IGNvbnN1bWUgdGhlIHBlbmRpbmcgYWN0aW9uIGVycm9yIChpLmUuLCBhbGwgbG9hZGVyc1xuICAvLyByZXNvbHZlZCksIHRoZW4gY29uc3VtZSBpdCBoZXJlLiAgQWxzbyBjbGVhciBvdXQgYW55IGxvYWRlckRhdGEgZm9yIHRoZVxuICAvLyB0aHJvd2luZyByb3V0ZVxuICBpZiAocGVuZGluZ0Vycm9yKSB7XG4gICAgZXJyb3JzID0gcGVuZGluZ0Vycm9yO1xuICAgIGxvYWRlckRhdGFbT2JqZWN0LmtleXMocGVuZGluZ0Vycm9yKVswXV0gPSB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxvYWRlckRhdGEsXG4gICAgZXJyb3JzLFxuICAgIHN0YXR1c0NvZGU6IHN0YXR1c0NvZGUgfHwgMjAwLFxuICAgIGxvYWRlckhlYWRlcnMsXG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NMb2FkZXJEYXRhKFxuICBzdGF0ZTogUm91dGVyU3RhdGUsXG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgbWF0Y2hlc1RvTG9hZDogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICByZXN1bHRzOiBEYXRhUmVzdWx0W10sXG4gIHBlbmRpbmdFcnJvcjogUm91dGVEYXRhIHwgdW5kZWZpbmVkLFxuICByZXZhbGlkYXRpbmdGZXRjaGVyczogUmV2YWxpZGF0aW5nRmV0Y2hlcltdLFxuICBmZXRjaGVyUmVzdWx0czogRGF0YVJlc3VsdFtdLFxuICBhY3RpdmVEZWZlcnJlZHM6IE1hcDxzdHJpbmcsIERlZmVycmVkRGF0YT5cbik6IHtcbiAgbG9hZGVyRGF0YTogUm91dGVyU3RhdGVbXCJsb2FkZXJEYXRhXCJdO1xuICBlcnJvcnM/OiBSb3V0ZXJTdGF0ZVtcImVycm9yc1wiXTtcbn0ge1xuICBsZXQgeyBsb2FkZXJEYXRhLCBlcnJvcnMgfSA9IHByb2Nlc3NSb3V0ZUxvYWRlckRhdGEoXG4gICAgbWF0Y2hlcyxcbiAgICBtYXRjaGVzVG9Mb2FkLFxuICAgIHJlc3VsdHMsXG4gICAgcGVuZGluZ0Vycm9yLFxuICAgIGFjdGl2ZURlZmVycmVkc1xuICApO1xuXG4gIC8vIFByb2Nlc3MgcmVzdWx0cyBmcm9tIG91ciByZXZhbGlkYXRpbmcgZmV0Y2hlcnNcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHJldmFsaWRhdGluZ0ZldGNoZXJzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGxldCB7IGtleSwgbWF0Y2gsIGNvbnRyb2xsZXIgfSA9IHJldmFsaWRhdGluZ0ZldGNoZXJzW2luZGV4XTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICBmZXRjaGVyUmVzdWx0cyAhPT0gdW5kZWZpbmVkICYmIGZldGNoZXJSZXN1bHRzW2luZGV4XSAhPT0gdW5kZWZpbmVkLFxuICAgICAgXCJEaWQgbm90IGZpbmQgY29ycmVzcG9uZGluZyBmZXRjaGVyIHJlc3VsdFwiXG4gICAgKTtcbiAgICBsZXQgcmVzdWx0ID0gZmV0Y2hlclJlc3VsdHNbaW5kZXhdO1xuXG4gICAgLy8gUHJvY2VzcyBmZXRjaGVyIG5vbi1yZWRpcmVjdCBlcnJvcnNcbiAgICBpZiAoY29udHJvbGxlciAmJiBjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAvLyBOb3RoaW5nIHRvIGRvIGZvciBhYm9ydGVkIGZldGNoZXJzXG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KHN0YXRlLm1hdGNoZXMsIG1hdGNoPy5yb3V0ZS5pZCk7XG4gICAgICBpZiAoIShlcnJvcnMgJiYgZXJyb3JzW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdKSkge1xuICAgICAgICBlcnJvcnMgPSB7XG4gICAgICAgICAgLi4uZXJyb3JzLFxuICAgICAgICAgIFtib3VuZGFyeU1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmVycm9yLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgc3RhdGUuZmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gICAgfSBlbHNlIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIFNob3VsZCBuZXZlciBnZXQgaGVyZSwgcmVkaXJlY3RzIHNob3VsZCBnZXQgcHJvY2Vzc2VkIGFib3ZlLCBidXQgd2VcbiAgICAgIC8vIGtlZXAgdGhpcyB0byB0eXBlIG5hcnJvdyB0byBhIHN1Y2Nlc3MgcmVzdWx0IGluIHRoZSBlbHNlXG4gICAgICBpbnZhcmlhbnQoZmFsc2UsIFwiVW5oYW5kbGVkIGZldGNoZXIgcmV2YWxpZGF0aW9uIHJlZGlyZWN0XCIpO1xuICAgIH0gZWxzZSBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAvLyBTaG91bGQgbmV2ZXIgZ2V0IGhlcmUsIGRlZmVycmVkIGRhdGEgc2hvdWxkIGJlIGF3YWl0ZWQgZm9yIGZldGNoZXJzXG4gICAgICAvLyBpbiByZXNvbHZlRGVmZXJyZWRSZXN1bHRzXG4gICAgICBpbnZhcmlhbnQoZmFsc2UsIFwiVW5oYW5kbGVkIGZldGNoZXIgZGVmZXJyZWQgZGF0YVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRvbmVGZXRjaGVyID0gZ2V0RG9uZUZldGNoZXIocmVzdWx0LmRhdGEpO1xuICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZG9uZUZldGNoZXIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IGxvYWRlckRhdGEsIGVycm9ycyB9O1xufVxuXG5mdW5jdGlvbiBtZXJnZUxvYWRlckRhdGEoXG4gIGxvYWRlckRhdGE6IFJvdXRlRGF0YSxcbiAgbmV3TG9hZGVyRGF0YTogUm91dGVEYXRhLFxuICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gIGVycm9yczogUm91dGVEYXRhIHwgbnVsbCB8IHVuZGVmaW5lZFxuKTogUm91dGVEYXRhIHtcbiAgbGV0IG1lcmdlZExvYWRlckRhdGEgPSB7IC4uLm5ld0xvYWRlckRhdGEgfTtcbiAgZm9yIChsZXQgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgIGxldCBpZCA9IG1hdGNoLnJvdXRlLmlkO1xuICAgIGlmIChuZXdMb2FkZXJEYXRhLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgaWYgKG5ld0xvYWRlckRhdGFbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbWVyZ2VkTG9hZGVyRGF0YVtpZF0gPSBuZXdMb2FkZXJEYXRhW2lkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vLW9wIC0gdGhpcyBpcyBzbyB3ZSBpZ25vcmUgZXhpc3RpbmcgZGF0YSBpZiB3ZSBoYXZlIGEga2V5IGluIHRoZVxuICAgICAgICAvLyBpbmNvbWluZyBvYmplY3Qgd2l0aCBhbiB1bmRlZmluZWQgdmFsdWUsIHdoaWNoIGlzIGhvdyB3ZSB1bnNldCBhIHByaW9yXG4gICAgICAgIC8vIGxvYWRlckRhdGEgaWYgd2UgZW5jb3VudGVyIGEgbG9hZGVyIGVycm9yXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb2FkZXJEYXRhW2lkXSAhPT0gdW5kZWZpbmVkICYmIG1hdGNoLnJvdXRlLmxvYWRlcikge1xuICAgICAgLy8gUHJlc2VydmUgZXhpc3Rpbmcga2V5cyBub3QgaW5jbHVkZWQgaW4gbmV3TG9hZGVyRGF0YSBhbmQgd2hlcmUgYSBsb2FkZXJcbiAgICAgIC8vIHdhc24ndCByZW1vdmVkIGJ5IEhNUlxuICAgICAgbWVyZ2VkTG9hZGVyRGF0YVtpZF0gPSBsb2FkZXJEYXRhW2lkXTtcbiAgICB9XG5cbiAgICBpZiAoZXJyb3JzICYmIGVycm9ycy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgIC8vIERvbid0IGtlZXAgYW55IGxvYWRlciBkYXRhIGJlbG93IHRoZSBib3VuZGFyeVxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBtZXJnZWRMb2FkZXJEYXRhO1xufVxuXG4vLyBGaW5kIHRoZSBuZWFyZXN0IGVycm9yIGJvdW5kYXJ5LCBsb29raW5nIHVwd2FyZHMgZnJvbSB0aGUgbGVhZiByb3V0ZSAob3IgdGhlXG4vLyByb3V0ZSBzcGVjaWZpZWQgYnkgcm91dGVJZCkgZm9yIHRoZSBjbG9zZXN0IGFuY2VzdG9yIGVycm9yIGJvdW5kYXJ5LFxuLy8gZGVmYXVsdGluZyB0byB0aGUgcm9vdCBtYXRjaFxuZnVuY3Rpb24gZmluZE5lYXJlc3RCb3VuZGFyeShcbiAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICByb3V0ZUlkPzogc3RyaW5nXG4pOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoIHtcbiAgbGV0IGVsaWdpYmxlTWF0Y2hlcyA9IHJvdXRlSWRcbiAgICA/IG1hdGNoZXMuc2xpY2UoMCwgbWF0Y2hlcy5maW5kSW5kZXgoKG0pID0+IG0ucm91dGUuaWQgPT09IHJvdXRlSWQpICsgMSlcbiAgICA6IFsuLi5tYXRjaGVzXTtcbiAgcmV0dXJuIChcbiAgICBlbGlnaWJsZU1hdGNoZXMucmV2ZXJzZSgpLmZpbmQoKG0pID0+IG0ucm91dGUuaGFzRXJyb3JCb3VuZGFyeSA9PT0gdHJ1ZSkgfHxcbiAgICBtYXRjaGVzWzBdXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdldFNob3J0Q2lyY3VpdE1hdGNoZXMocm91dGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdFtdKToge1xuICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW107XG4gIHJvdXRlOiBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdDtcbn0ge1xuICAvLyBQcmVmZXIgYSByb290IGxheW91dCByb3V0ZSBpZiBwcmVzZW50LCBvdGhlcndpc2Ugc2hpbSBpbiBhIHJvdXRlIG9iamVjdFxuICBsZXQgcm91dGUgPVxuICAgIHJvdXRlcy5sZW5ndGggPT09IDFcbiAgICAgID8gcm91dGVzWzBdXG4gICAgICA6IHJvdXRlcy5maW5kKChyKSA9PiByLmluZGV4IHx8ICFyLnBhdGggfHwgci5wYXRoID09PSBcIi9cIikgfHwge1xuICAgICAgICAgIGlkOiBgX19zaGltLWVycm9yLXJvdXRlX19gLFxuICAgICAgICB9O1xuXG4gIHJldHVybiB7XG4gICAgbWF0Y2hlczogW1xuICAgICAge1xuICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICBwYXRobmFtZTogXCJcIixcbiAgICAgICAgcGF0aG5hbWVCYXNlOiBcIlwiLFxuICAgICAgICByb3V0ZSxcbiAgICAgIH0sXG4gICAgXSxcbiAgICByb3V0ZSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcihcbiAgc3RhdHVzOiBudW1iZXIsXG4gIHtcbiAgICBwYXRobmFtZSxcbiAgICByb3V0ZUlkLFxuICAgIG1ldGhvZCxcbiAgICB0eXBlLFxuICB9OiB7XG4gICAgcGF0aG5hbWU/OiBzdHJpbmc7XG4gICAgcm91dGVJZD86IHN0cmluZztcbiAgICBtZXRob2Q/OiBzdHJpbmc7XG4gICAgdHlwZT86IFwiZGVmZXItYWN0aW9uXCIgfCBcImludmFsaWQtYm9keVwiO1xuICB9ID0ge31cbikge1xuICBsZXQgc3RhdHVzVGV4dCA9IFwiVW5rbm93biBTZXJ2ZXIgRXJyb3JcIjtcbiAgbGV0IGVycm9yTWVzc2FnZSA9IFwiVW5rbm93biBAcmVtaXgtcnVuL3JvdXRlciBlcnJvclwiO1xuXG4gIGlmIChzdGF0dXMgPT09IDQwMCkge1xuICAgIHN0YXR1c1RleHQgPSBcIkJhZCBSZXF1ZXN0XCI7XG4gICAgaWYgKG1ldGhvZCAmJiBwYXRobmFtZSAmJiByb3V0ZUlkKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPVxuICAgICAgICBgWW91IG1hZGUgYSAke21ldGhvZH0gcmVxdWVzdCB0byBcIiR7cGF0aG5hbWV9XCIgYnV0IGAgK1xuICAgICAgICBgZGlkIG5vdCBwcm92aWRlIGEgXFxgbG9hZGVyXFxgIGZvciByb3V0ZSBcIiR7cm91dGVJZH1cIiwgYCArXG4gICAgICAgIGBzbyB0aGVyZSBpcyBubyB3YXkgdG8gaGFuZGxlIHRoZSByZXF1ZXN0LmA7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcImRlZmVyLWFjdGlvblwiKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBcImRlZmVyKCkgaXMgbm90IHN1cHBvcnRlZCBpbiBhY3Rpb25zXCI7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcImludmFsaWQtYm9keVwiKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBcIlVuYWJsZSB0byBlbmNvZGUgc3VibWlzc2lvbiBib2R5XCI7XG4gICAgfVxuICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gNDAzKSB7XG4gICAgc3RhdHVzVGV4dCA9IFwiRm9yYmlkZGVuXCI7XG4gICAgZXJyb3JNZXNzYWdlID0gYFJvdXRlIFwiJHtyb3V0ZUlkfVwiIGRvZXMgbm90IG1hdGNoIFVSTCBcIiR7cGF0aG5hbWV9XCJgO1xuICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gNDA0KSB7XG4gICAgc3RhdHVzVGV4dCA9IFwiTm90IEZvdW5kXCI7XG4gICAgZXJyb3JNZXNzYWdlID0gYE5vIHJvdXRlIG1hdGNoZXMgVVJMIFwiJHtwYXRobmFtZX1cImA7XG4gIH0gZWxzZSBpZiAoc3RhdHVzID09PSA0MDUpIHtcbiAgICBzdGF0dXNUZXh0ID0gXCJNZXRob2QgTm90IEFsbG93ZWRcIjtcbiAgICBpZiAobWV0aG9kICYmIHBhdGhuYW1lICYmIHJvdXRlSWQpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9XG4gICAgICAgIGBZb3UgbWFkZSBhICR7bWV0aG9kLnRvVXBwZXJDYXNlKCl9IHJlcXVlc3QgdG8gXCIke3BhdGhuYW1lfVwiIGJ1dCBgICtcbiAgICAgICAgYGRpZCBub3QgcHJvdmlkZSBhbiBcXGBhY3Rpb25cXGAgZm9yIHJvdXRlIFwiJHtyb3V0ZUlkfVwiLCBgICtcbiAgICAgICAgYHNvIHRoZXJlIGlzIG5vIHdheSB0byBoYW5kbGUgdGhlIHJlcXVlc3QuYDtcbiAgICB9IGVsc2UgaWYgKG1ldGhvZCkge1xuICAgICAgZXJyb3JNZXNzYWdlID0gYEludmFsaWQgcmVxdWVzdCBtZXRob2QgXCIke21ldGhvZC50b1VwcGVyQ2FzZSgpfVwiYDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IEVycm9yUmVzcG9uc2VJbXBsKFxuICAgIHN0YXR1cyB8fCA1MDAsXG4gICAgc3RhdHVzVGV4dCxcbiAgICBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKSxcbiAgICB0cnVlXG4gICk7XG59XG5cbi8vIEZpbmQgYW55IHJldHVybmVkIHJlZGlyZWN0IGVycm9ycywgc3RhcnRpbmcgZnJvbSB0aGUgbG93ZXN0IG1hdGNoXG5mdW5jdGlvbiBmaW5kUmVkaXJlY3QoXG4gIHJlc3VsdHM6IERhdGFSZXN1bHRbXVxuKTogeyByZXN1bHQ6IFJlZGlyZWN0UmVzdWx0OyBpZHg6IG51bWJlciB9IHwgdW5kZWZpbmVkIHtcbiAgZm9yIChsZXQgaSA9IHJlc3VsdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBsZXQgcmVzdWx0ID0gcmVzdWx0c1tpXTtcbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICByZXR1cm4geyByZXN1bHQsIGlkeDogaSB9O1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdHJpcEhhc2hGcm9tUGF0aChwYXRoOiBUbykge1xuICBsZXQgcGFyc2VkUGF0aCA9IHR5cGVvZiBwYXRoID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHBhdGgpIDogcGF0aDtcbiAgcmV0dXJuIGNyZWF0ZVBhdGgoeyAuLi5wYXJzZWRQYXRoLCBoYXNoOiBcIlwiIH0pO1xufVxuXG5mdW5jdGlvbiBpc0hhc2hDaGFuZ2VPbmx5KGE6IExvY2F0aW9uLCBiOiBMb2NhdGlvbik6IGJvb2xlYW4ge1xuICBpZiAoYS5wYXRobmFtZSAhPT0gYi5wYXRobmFtZSB8fCBhLnNlYXJjaCAhPT0gYi5zZWFyY2gpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoYS5oYXNoID09PSBcIlwiKSB7XG4gICAgLy8gL3BhZ2UgLT4gL3BhZ2UjaGFzaFxuICAgIHJldHVybiBiLmhhc2ggIT09IFwiXCI7XG4gIH0gZWxzZSBpZiAoYS5oYXNoID09PSBiLmhhc2gpIHtcbiAgICAvLyAvcGFnZSNoYXNoIC0+IC9wYWdlI2hhc2hcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChiLmhhc2ggIT09IFwiXCIpIHtcbiAgICAvLyAvcGFnZSNoYXNoIC0+IC9wYWdlI290aGVyXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBJZiB0aGUgaGFzaCBpcyByZW1vdmVkIHRoZSBicm93c2VyIHdpbGwgcmUtcGVyZm9ybSBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlclxuICAvLyAvcGFnZSNoYXNoIC0+IC9wYWdlXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQ6IERhdGFSZXN1bHQpOiByZXN1bHQgaXMgRGVmZXJyZWRSZXN1bHQge1xuICByZXR1cm4gcmVzdWx0LnR5cGUgPT09IFJlc3VsdFR5cGUuZGVmZXJyZWQ7XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3JSZXN1bHQocmVzdWx0OiBEYXRhUmVzdWx0KTogcmVzdWx0IGlzIEVycm9yUmVzdWx0IHtcbiAgcmV0dXJuIHJlc3VsdC50eXBlID09PSBSZXN1bHRUeXBlLmVycm9yO1xufVxuXG5mdW5jdGlvbiBpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdD86IERhdGFSZXN1bHQpOiByZXN1bHQgaXMgUmVkaXJlY3RSZXN1bHQge1xuICByZXR1cm4gKHJlc3VsdCAmJiByZXN1bHQudHlwZSkgPT09IFJlc3VsdFR5cGUucmVkaXJlY3Q7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0RlZmVycmVkRGF0YSh2YWx1ZTogYW55KTogdmFsdWUgaXMgRGVmZXJyZWREYXRhIHtcbiAgbGV0IGRlZmVycmVkOiBEZWZlcnJlZERhdGEgPSB2YWx1ZTtcbiAgcmV0dXJuIChcbiAgICBkZWZlcnJlZCAmJlxuICAgIHR5cGVvZiBkZWZlcnJlZCA9PT0gXCJvYmplY3RcIiAmJlxuICAgIHR5cGVvZiBkZWZlcnJlZC5kYXRhID09PSBcIm9iamVjdFwiICYmXG4gICAgdHlwZW9mIGRlZmVycmVkLnN1YnNjcmliZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgdHlwZW9mIGRlZmVycmVkLmNhbmNlbCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgdHlwZW9mIGRlZmVycmVkLnJlc29sdmVEYXRhID09PSBcImZ1bmN0aW9uXCJcbiAgKTtcbn1cblxuZnVuY3Rpb24gaXNSZXNwb25zZSh2YWx1ZTogYW55KTogdmFsdWUgaXMgUmVzcG9uc2Uge1xuICByZXR1cm4gKFxuICAgIHZhbHVlICE9IG51bGwgJiZcbiAgICB0eXBlb2YgdmFsdWUuc3RhdHVzID09PSBcIm51bWJlclwiICYmXG4gICAgdHlwZW9mIHZhbHVlLnN0YXR1c1RleHQgPT09IFwic3RyaW5nXCIgJiZcbiAgICB0eXBlb2YgdmFsdWUuaGVhZGVycyA9PT0gXCJvYmplY3RcIiAmJlxuICAgIHR5cGVvZiB2YWx1ZS5ib2R5ICE9PSBcInVuZGVmaW5lZFwiXG4gICk7XG59XG5cbmZ1bmN0aW9uIGlzUmVkaXJlY3RSZXNwb25zZShyZXN1bHQ6IGFueSk6IHJlc3VsdCBpcyBSZXNwb25zZSB7XG4gIGlmICghaXNSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbGV0IHN0YXR1cyA9IHJlc3VsdC5zdGF0dXM7XG4gIGxldCBsb2NhdGlvbiA9IHJlc3VsdC5oZWFkZXJzLmdldChcIkxvY2F0aW9uXCIpO1xuICByZXR1cm4gc3RhdHVzID49IDMwMCAmJiBzdGF0dXMgPD0gMzk5ICYmIGxvY2F0aW9uICE9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzUXVlcnlSb3V0ZVJlc3BvbnNlKG9iajogYW55KTogb2JqIGlzIFF1ZXJ5Um91dGVSZXNwb25zZSB7XG4gIHJldHVybiAoXG4gICAgb2JqICYmXG4gICAgaXNSZXNwb25zZShvYmoucmVzcG9uc2UpICYmXG4gICAgKG9iai50eXBlID09PSBSZXN1bHRUeXBlLmRhdGEgfHwgb2JqLnR5cGUgPT09IFJlc3VsdFR5cGUuZXJyb3IpXG4gICk7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRNZXRob2QobWV0aG9kOiBzdHJpbmcpOiBtZXRob2QgaXMgRm9ybU1ldGhvZCB8IFY3X0Zvcm1NZXRob2Qge1xuICByZXR1cm4gdmFsaWRSZXF1ZXN0TWV0aG9kcy5oYXMobWV0aG9kLnRvTG93ZXJDYXNlKCkgYXMgRm9ybU1ldGhvZCk7XG59XG5cbmZ1bmN0aW9uIGlzTXV0YXRpb25NZXRob2QoXG4gIG1ldGhvZDogc3RyaW5nXG4pOiBtZXRob2QgaXMgTXV0YXRpb25Gb3JtTWV0aG9kIHwgVjdfTXV0YXRpb25Gb3JtTWV0aG9kIHtcbiAgcmV0dXJuIHZhbGlkTXV0YXRpb25NZXRob2RzLmhhcyhtZXRob2QudG9Mb3dlckNhc2UoKSBhcyBNdXRhdGlvbkZvcm1NZXRob2QpO1xufVxuXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlRGVmZXJyZWRSZXN1bHRzKFxuICBjdXJyZW50TWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICBtYXRjaGVzVG9Mb2FkOiAoQWdub3N0aWNEYXRhUm91dGVNYXRjaCB8IG51bGwpW10sXG4gIHJlc3VsdHM6IERhdGFSZXN1bHRbXSxcbiAgc2lnbmFsczogKEFib3J0U2lnbmFsIHwgbnVsbClbXSxcbiAgaXNGZXRjaGVyOiBib29sZWFuLFxuICBjdXJyZW50TG9hZGVyRGF0YT86IFJvdXRlRGF0YVxuKSB7XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCByZXN1bHRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGxldCByZXN1bHQgPSByZXN1bHRzW2luZGV4XTtcbiAgICBsZXQgbWF0Y2ggPSBtYXRjaGVzVG9Mb2FkW2luZGV4XTtcbiAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgbWF0Y2gsIHRoZW4gd2UgY2FuIGhhdmUgYSBkZWZlcnJlZCByZXN1bHQgdG8gZG9cbiAgICAvLyBhbnl0aGluZyB3aXRoLiAgVGhpcyBpcyBmb3IgcmV2YWxpZGF0aW5nIGZldGNoZXJzIHdoZXJlIHRoZSByb3V0ZSB3YXNcbiAgICAvLyByZW1vdmVkIGR1cmluZyBITVJcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBsZXQgY3VycmVudE1hdGNoID0gY3VycmVudE1hdGNoZXMuZmluZChcbiAgICAgIChtKSA9PiBtLnJvdXRlLmlkID09PSBtYXRjaCEucm91dGUuaWRcbiAgICApO1xuICAgIGxldCBpc1JldmFsaWRhdGluZ0xvYWRlciA9XG4gICAgICBjdXJyZW50TWF0Y2ggIT0gbnVsbCAmJlxuICAgICAgIWlzTmV3Um91dGVJbnN0YW5jZShjdXJyZW50TWF0Y2gsIG1hdGNoKSAmJlxuICAgICAgKGN1cnJlbnRMb2FkZXJEYXRhICYmIGN1cnJlbnRMb2FkZXJEYXRhW21hdGNoLnJvdXRlLmlkXSkgIT09IHVuZGVmaW5lZDtcblxuICAgIGlmIChpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkgJiYgKGlzRmV0Y2hlciB8fCBpc1JldmFsaWRhdGluZ0xvYWRlcikpIHtcbiAgICAgIC8vIE5vdGU6IHdlIGRvIG5vdCBoYXZlIHRvIHRvdWNoIGFjdGl2ZURlZmVycmVkcyBoZXJlIHNpbmNlIHdlIHJhY2UgdGhlbVxuICAgICAgLy8gYWdhaW5zdCB0aGUgc2lnbmFsIGluIHJlc29sdmVEZWZlcnJlZERhdGEgYW5kIHRoZXknbGwgZ2V0IGFib3J0ZWRcbiAgICAgIC8vIHRoZXJlIGlmIG5lZWRlZFxuICAgICAgbGV0IHNpZ25hbCA9IHNpZ25hbHNbaW5kZXhdO1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICBzaWduYWwsXG4gICAgICAgIFwiRXhwZWN0ZWQgYW4gQWJvcnRTaWduYWwgZm9yIHJldmFsaWRhdGluZyBmZXRjaGVyIGRlZmVycmVkIHJlc3VsdFwiXG4gICAgICApO1xuICAgICAgYXdhaXQgcmVzb2x2ZURlZmVycmVkRGF0YShyZXN1bHQsIHNpZ25hbCwgaXNGZXRjaGVyKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdHNbaW5kZXhdID0gcmVzdWx0IHx8IHJlc3VsdHNbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZURlZmVycmVkRGF0YShcbiAgcmVzdWx0OiBEZWZlcnJlZFJlc3VsdCxcbiAgc2lnbmFsOiBBYm9ydFNpZ25hbCxcbiAgdW53cmFwID0gZmFsc2Vcbik6IFByb21pc2U8U3VjY2Vzc1Jlc3VsdCB8IEVycm9yUmVzdWx0IHwgdW5kZWZpbmVkPiB7XG4gIGxldCBhYm9ydGVkID0gYXdhaXQgcmVzdWx0LmRlZmVycmVkRGF0YS5yZXNvbHZlRGF0YShzaWduYWwpO1xuICBpZiAoYWJvcnRlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh1bndyYXApIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogUmVzdWx0VHlwZS5kYXRhLFxuICAgICAgICBkYXRhOiByZXN1bHQuZGVmZXJyZWREYXRhLnVud3JhcHBlZERhdGEsXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIEhhbmRsZSBhbnkgVHJhY2tlZFByb21pc2UuX2Vycm9yIHZhbHVlcyBlbmNvdW50ZXJlZCB3aGlsZSB1bndyYXBwaW5nXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmVycm9yLFxuICAgICAgICBlcnJvcjogZSxcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSZXN1bHRUeXBlLmRhdGEsXG4gICAgZGF0YTogcmVzdWx0LmRlZmVycmVkRGF0YS5kYXRhLFxuICB9O1xufVxuXG5mdW5jdGlvbiBoYXNOYWtlZEluZGV4UXVlcnkoc2VhcmNoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXMoc2VhcmNoKS5nZXRBbGwoXCJpbmRleFwiKS5zb21lKCh2KSA9PiB2ID09PSBcIlwiKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0TWF0Y2goXG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgbG9jYXRpb246IExvY2F0aW9uIHwgc3RyaW5nXG4pIHtcbiAgbGV0IHNlYXJjaCA9XG4gICAgdHlwZW9mIGxvY2F0aW9uID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKGxvY2F0aW9uKS5zZWFyY2ggOiBsb2NhdGlvbi5zZWFyY2g7XG4gIGlmIChcbiAgICBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUuaW5kZXggJiZcbiAgICBoYXNOYWtlZEluZGV4UXVlcnkoc2VhcmNoIHx8IFwiXCIpXG4gICkge1xuICAgIC8vIFJldHVybiB0aGUgbGVhZiBpbmRleCByb3V0ZSB3aGVuIGluZGV4IGlzIHByZXNlbnRcbiAgICByZXR1cm4gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdO1xuICB9XG4gIC8vIE90aGVyd2lzZSBncmFiIHRoZSBkZWVwZXN0IFwicGF0aCBjb250cmlidXRpbmdcIiBtYXRjaCAoaWdub3JpbmcgaW5kZXggYW5kXG4gIC8vIHBhdGhsZXNzIGxheW91dCByb3V0ZXMpXG4gIGxldCBwYXRoTWF0Y2hlcyA9IGdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzKG1hdGNoZXMpO1xuICByZXR1cm4gcGF0aE1hdGNoZXNbcGF0aE1hdGNoZXMubGVuZ3RoIC0gMV07XG59XG5cbmZ1bmN0aW9uIGdldFN1Ym1pc3Npb25Gcm9tTmF2aWdhdGlvbihcbiAgbmF2aWdhdGlvbjogTmF2aWdhdGlvblxuKTogU3VibWlzc2lvbiB8IHVuZGVmaW5lZCB7XG4gIGxldCB7IGZvcm1NZXRob2QsIGZvcm1BY3Rpb24sIGZvcm1FbmNUeXBlLCB0ZXh0LCBmb3JtRGF0YSwganNvbiB9ID1cbiAgICBuYXZpZ2F0aW9uO1xuICBpZiAoIWZvcm1NZXRob2QgfHwgIWZvcm1BY3Rpb24gfHwgIWZvcm1FbmNUeXBlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHRleHQgIT0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICBmb3JtTWV0aG9kLFxuICAgICAgZm9ybUFjdGlvbixcbiAgICAgIGZvcm1FbmNUeXBlLFxuICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgIGpzb246IHVuZGVmaW5lZCxcbiAgICAgIHRleHQsXG4gICAgfTtcbiAgfSBlbHNlIGlmIChmb3JtRGF0YSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvcm1NZXRob2QsXG4gICAgICBmb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGUsXG4gICAgICBmb3JtRGF0YSxcbiAgICAgIGpzb246IHVuZGVmaW5lZCxcbiAgICAgIHRleHQ6IHVuZGVmaW5lZCxcbiAgICB9O1xuICB9IGVsc2UgaWYgKGpzb24gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB7XG4gICAgICBmb3JtTWV0aG9kLFxuICAgICAgZm9ybUFjdGlvbixcbiAgICAgIGZvcm1FbmNUeXBlLFxuICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgIGpzb24sXG4gICAgICB0ZXh0OiB1bmRlZmluZWQsXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRMb2FkaW5nTmF2aWdhdGlvbihcbiAgbG9jYXRpb246IExvY2F0aW9uLFxuICBzdWJtaXNzaW9uPzogU3VibWlzc2lvblxuKTogTmF2aWdhdGlvblN0YXRlc1tcIkxvYWRpbmdcIl0ge1xuICBpZiAoc3VibWlzc2lvbikge1xuICAgIGxldCBuYXZpZ2F0aW9uOiBOYXZpZ2F0aW9uU3RhdGVzW1wiTG9hZGluZ1wiXSA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgZm9ybU1ldGhvZDogc3VibWlzc2lvbi5mb3JtTWV0aG9kLFxuICAgICAgZm9ybUFjdGlvbjogc3VibWlzc2lvbi5mb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGU6IHN1Ym1pc3Npb24uZm9ybUVuY1R5cGUsXG4gICAgICBmb3JtRGF0YTogc3VibWlzc2lvbi5mb3JtRGF0YSxcbiAgICAgIGpzb246IHN1Ym1pc3Npb24uanNvbixcbiAgICAgIHRleHQ6IHN1Ym1pc3Npb24udGV4dCxcbiAgICB9O1xuICAgIHJldHVybiBuYXZpZ2F0aW9uO1xuICB9IGVsc2Uge1xuICAgIGxldCBuYXZpZ2F0aW9uOiBOYXZpZ2F0aW9uU3RhdGVzW1wiTG9hZGluZ1wiXSA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgZm9ybU1ldGhvZDogdW5kZWZpbmVkLFxuICAgICAgZm9ybUFjdGlvbjogdW5kZWZpbmVkLFxuICAgICAgZm9ybUVuY1R5cGU6IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gICAgICBqc29uOiB1bmRlZmluZWQsXG4gICAgICB0ZXh0OiB1bmRlZmluZWQsXG4gICAgfTtcbiAgICByZXR1cm4gbmF2aWdhdGlvbjtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTdWJtaXR0aW5nTmF2aWdhdGlvbihcbiAgbG9jYXRpb246IExvY2F0aW9uLFxuICBzdWJtaXNzaW9uOiBTdWJtaXNzaW9uXG4pOiBOYXZpZ2F0aW9uU3RhdGVzW1wiU3VibWl0dGluZ1wiXSB7XG4gIGxldCBuYXZpZ2F0aW9uOiBOYXZpZ2F0aW9uU3RhdGVzW1wiU3VibWl0dGluZ1wiXSA9IHtcbiAgICBzdGF0ZTogXCJzdWJtaXR0aW5nXCIsXG4gICAgbG9jYXRpb24sXG4gICAgZm9ybU1ldGhvZDogc3VibWlzc2lvbi5mb3JtTWV0aG9kLFxuICAgIGZvcm1BY3Rpb246IHN1Ym1pc3Npb24uZm9ybUFjdGlvbixcbiAgICBmb3JtRW5jVHlwZTogc3VibWlzc2lvbi5mb3JtRW5jVHlwZSxcbiAgICBmb3JtRGF0YTogc3VibWlzc2lvbi5mb3JtRGF0YSxcbiAgICBqc29uOiBzdWJtaXNzaW9uLmpzb24sXG4gICAgdGV4dDogc3VibWlzc2lvbi50ZXh0LFxuICB9O1xuICByZXR1cm4gbmF2aWdhdGlvbjtcbn1cblxuZnVuY3Rpb24gZ2V0TG9hZGluZ0ZldGNoZXIoXG4gIHN1Ym1pc3Npb24/OiBTdWJtaXNzaW9uLFxuICBkYXRhPzogRmV0Y2hlcltcImRhdGFcIl1cbik6IEZldGNoZXJTdGF0ZXNbXCJMb2FkaW5nXCJdIHtcbiAgaWYgKHN1Ym1pc3Npb24pIHtcbiAgICBsZXQgZmV0Y2hlcjogRmV0Y2hlclN0YXRlc1tcIkxvYWRpbmdcIl0gPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICBmb3JtTWV0aG9kOiBzdWJtaXNzaW9uLmZvcm1NZXRob2QsXG4gICAgICBmb3JtQWN0aW9uOiBzdWJtaXNzaW9uLmZvcm1BY3Rpb24sXG4gICAgICBmb3JtRW5jVHlwZTogc3VibWlzc2lvbi5mb3JtRW5jVHlwZSxcbiAgICAgIGZvcm1EYXRhOiBzdWJtaXNzaW9uLmZvcm1EYXRhLFxuICAgICAganNvbjogc3VibWlzc2lvbi5qc29uLFxuICAgICAgdGV4dDogc3VibWlzc2lvbi50ZXh0LFxuICAgICAgZGF0YSxcbiAgICB9O1xuICAgIHJldHVybiBmZXRjaGVyO1xuICB9IGVsc2Uge1xuICAgIGxldCBmZXRjaGVyOiBGZXRjaGVyU3RhdGVzW1wiTG9hZGluZ1wiXSA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIGZvcm1NZXRob2Q6IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXG4gICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgICAganNvbjogdW5kZWZpbmVkLFxuICAgICAgdGV4dDogdW5kZWZpbmVkLFxuICAgICAgZGF0YSxcbiAgICB9O1xuICAgIHJldHVybiBmZXRjaGVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFN1Ym1pdHRpbmdGZXRjaGVyKFxuICBzdWJtaXNzaW9uOiBTdWJtaXNzaW9uLFxuICBleGlzdGluZ0ZldGNoZXI/OiBGZXRjaGVyXG4pOiBGZXRjaGVyU3RhdGVzW1wiU3VibWl0dGluZ1wiXSB7XG4gIGxldCBmZXRjaGVyOiBGZXRjaGVyU3RhdGVzW1wiU3VibWl0dGluZ1wiXSA9IHtcbiAgICBzdGF0ZTogXCJzdWJtaXR0aW5nXCIsXG4gICAgZm9ybU1ldGhvZDogc3VibWlzc2lvbi5mb3JtTWV0aG9kLFxuICAgIGZvcm1BY3Rpb246IHN1Ym1pc3Npb24uZm9ybUFjdGlvbixcbiAgICBmb3JtRW5jVHlwZTogc3VibWlzc2lvbi5mb3JtRW5jVHlwZSxcbiAgICBmb3JtRGF0YTogc3VibWlzc2lvbi5mb3JtRGF0YSxcbiAgICBqc29uOiBzdWJtaXNzaW9uLmpzb24sXG4gICAgdGV4dDogc3VibWlzc2lvbi50ZXh0LFxuICAgIGRhdGE6IGV4aXN0aW5nRmV0Y2hlciA/IGV4aXN0aW5nRmV0Y2hlci5kYXRhIDogdW5kZWZpbmVkLFxuICB9O1xuICByZXR1cm4gZmV0Y2hlcjtcbn1cblxuZnVuY3Rpb24gZ2V0RG9uZUZldGNoZXIoZGF0YTogRmV0Y2hlcltcImRhdGFcIl0pOiBGZXRjaGVyU3RhdGVzW1wiSWRsZVwiXSB7XG4gIGxldCBmZXRjaGVyOiBGZXRjaGVyU3RhdGVzW1wiSWRsZVwiXSA9IHtcbiAgICBzdGF0ZTogXCJpZGxlXCIsXG4gICAgZm9ybU1ldGhvZDogdW5kZWZpbmVkLFxuICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkLFxuICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gICAganNvbjogdW5kZWZpbmVkLFxuICAgIHRleHQ6IHVuZGVmaW5lZCxcbiAgICBkYXRhLFxuICB9O1xuICByZXR1cm4gZmV0Y2hlcjtcbn1cblxuZnVuY3Rpb24gcmVzdG9yZUFwcGxpZWRUcmFuc2l0aW9ucyhcbiAgX3dpbmRvdzogV2luZG93LFxuICB0cmFuc2l0aW9uczogTWFwPHN0cmluZywgU2V0PHN0cmluZz4+XG4pIHtcbiAgdHJ5IHtcbiAgICBsZXQgc2Vzc2lvblBvc2l0aW9ucyA9IF93aW5kb3cuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShcbiAgICAgIFRSQU5TSVRJT05TX1NUT1JBR0VfS0VZXG4gICAgKTtcbiAgICBpZiAoc2Vzc2lvblBvc2l0aW9ucykge1xuICAgICAgbGV0IGpzb24gPSBKU09OLnBhcnNlKHNlc3Npb25Qb3NpdGlvbnMpO1xuICAgICAgZm9yIChsZXQgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKGpzb24gfHwge30pKSB7XG4gICAgICAgIGlmICh2ICYmIEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgICB0cmFuc2l0aW9ucy5zZXQoaywgbmV3IFNldCh2IHx8IFtdKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBuby1vcCwgdXNlIGRlZmF1bHQgZW1wdHkgb2JqZWN0XG4gIH1cbn1cblxuZnVuY3Rpb24gcGVyc2lzdEFwcGxpZWRUcmFuc2l0aW9ucyhcbiAgX3dpbmRvdzogV2luZG93LFxuICB0cmFuc2l0aW9uczogTWFwPHN0cmluZywgU2V0PHN0cmluZz4+XG4pIHtcbiAgaWYgKHRyYW5zaXRpb25zLnNpemUgPiAwKSB7XG4gICAgbGV0IGpzb246IFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPiA9IHt9O1xuICAgIGZvciAobGV0IFtrLCB2XSBvZiB0cmFuc2l0aW9ucykge1xuICAgICAganNvbltrXSA9IFsuLi52XTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIF93aW5kb3cuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcbiAgICAgICAgVFJBTlNJVElPTlNfU1RPUkFHRV9LRVksXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KGpzb24pXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgYEZhaWxlZCB0byBzYXZlIGFwcGxpZWQgdmlldyB0cmFuc2l0aW9ucyBpbiBzZXNzaW9uU3RvcmFnZSAoJHtlcnJvcn0pLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbi8vI2VuZHJlZ2lvblxuIl0sIm5hbWVzIjpbIkFjdGlvbiIsIlBvcFN0YXRlRXZlbnRUeXBlIiwiY3JlYXRlTWVtb3J5SGlzdG9yeSIsIm9wdGlvbnMiLCJfb3B0aW9ucyIsIl9vcHRpb25zJGluaXRpYWxFbnRyaSIsImluaXRpYWxFbnRyaWVzIiwiaW5pdGlhbEluZGV4IiwiX29wdGlvbnMkdjVDb21wYXQiLCJ2NUNvbXBhdCIsImVudHJpZXMiLCJtYXAiLCJlbnRyeSIsImluZGV4IiwiY3JlYXRlTWVtb3J5TG9jYXRpb24iLCJzdGF0ZSIsInVuZGVmaW5lZCIsImNsYW1wSW5kZXgiLCJsZW5ndGgiLCJhY3Rpb24iLCJQb3AiLCJsaXN0ZW5lciIsIm4iLCJNYXRoIiwibWluIiwibWF4IiwiZ2V0Q3VycmVudExvY2F0aW9uIiwidG8iLCJrZXkiLCJsb2NhdGlvbiIsImNyZWF0ZUxvY2F0aW9uIiwicGF0aG5hbWUiLCJ3YXJuaW5nIiwiY2hhckF0IiwiSlNPTiIsInN0cmluZ2lmeSIsImNyZWF0ZUhyZWYiLCJjcmVhdGVQYXRoIiwiaGlzdG9yeSIsImNyZWF0ZVVSTCIsIlVSTCIsImVuY29kZUxvY2F0aW9uIiwicGF0aCIsInBhcnNlUGF0aCIsInNlYXJjaCIsImhhc2giLCJwdXNoIiwiUHVzaCIsIm5leHRMb2NhdGlvbiIsInNwbGljZSIsImRlbHRhIiwicmVwbGFjZSIsIlJlcGxhY2UiLCJnbyIsIm5leHRJbmRleCIsImxpc3RlbiIsImZuIiwiY3JlYXRlQnJvd3Nlckhpc3RvcnkiLCJjcmVhdGVCcm93c2VyTG9jYXRpb24iLCJ3aW5kb3ciLCJnbG9iYWxIaXN0b3J5IiwiX3dpbmRvdyRsb2NhdGlvbiIsInVzciIsImNyZWF0ZUJyb3dzZXJIcmVmIiwiZ2V0VXJsQmFzZWRIaXN0b3J5IiwiY3JlYXRlSGFzaEhpc3RvcnkiLCJjcmVhdGVIYXNoTG9jYXRpb24iLCJfcGFyc2VQYXRoIiwic3Vic3RyIiwiX3BhcnNlUGF0aCRwYXRobmFtZSIsIl9wYXJzZVBhdGgkc2VhcmNoIiwiX3BhcnNlUGF0aCRoYXNoIiwic3RhcnRzV2l0aCIsImNyZWF0ZUhhc2hIcmVmIiwiYmFzZSIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImhyZWYiLCJnZXRBdHRyaWJ1dGUiLCJ1cmwiLCJoYXNoSW5kZXgiLCJpbmRleE9mIiwic2xpY2UiLCJ2YWxpZGF0ZUhhc2hMb2NhdGlvbiIsImludmFyaWFudCIsInZhbHVlIiwibWVzc2FnZSIsIkVycm9yIiwiY29uZCIsImNvbnNvbGUiLCJ3YXJuIiwiZSIsImNyZWF0ZUtleSIsInJhbmRvbSIsInRvU3RyaW5nIiwiZ2V0SGlzdG9yeVN0YXRlIiwiaWR4IiwiY3VycmVudCIsIl9leHRlbmRzIiwiX3JlZiIsIl9yZWYkcGF0aG5hbWUiLCJfcmVmJHNlYXJjaCIsIl9yZWYkaGFzaCIsInBhcnNlZFBhdGgiLCJzZWFyY2hJbmRleCIsImdldExvY2F0aW9uIiwidmFsaWRhdGVMb2NhdGlvbiIsIl9vcHRpb25zMiIsIl9vcHRpb25zMiR3aW5kb3ciLCJkZWZhdWx0VmlldyIsIl9vcHRpb25zMiR2NUNvbXBhdCIsImdldEluZGV4IiwicmVwbGFjZVN0YXRlIiwiaGFuZGxlUG9wIiwiaGlzdG9yeVN0YXRlIiwicHVzaFN0YXRlIiwiZXJyb3IiLCJET01FeGNlcHRpb24iLCJuYW1lIiwiYXNzaWduIiwib3JpZ2luIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJSZXN1bHRUeXBlIiwiaW1tdXRhYmxlUm91dGVLZXlzIiwiU2V0IiwiaXNJbmRleFJvdXRlIiwicm91dGUiLCJjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzIiwicm91dGVzIiwibWFwUm91dGVQcm9wZXJ0aWVzIiwicGFyZW50UGF0aCIsIm1hbmlmZXN0IiwidHJlZVBhdGgiLCJjb25jYXQiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJpZCIsImpvaW4iLCJjaGlsZHJlbiIsImluZGV4Um91dGUiLCJwYXRoT3JMYXlvdXRSb3V0ZSIsIm1hdGNoUm91dGVzIiwibG9jYXRpb25BcmciLCJiYXNlbmFtZSIsInN0cmlwQmFzZW5hbWUiLCJicmFuY2hlcyIsImZsYXR0ZW5Sb3V0ZXMiLCJyYW5rUm91dGVCcmFuY2hlcyIsIm1hdGNoZXMiLCJpIiwibWF0Y2hSb3V0ZUJyYW5jaCIsInNhZmVseURlY29kZVVSSSIsImNvbnZlcnRSb3V0ZU1hdGNoVG9VaU1hdGNoIiwibWF0Y2giLCJsb2FkZXJEYXRhIiwicGFyYW1zIiwiZGF0YSIsImhhbmRsZSIsInBhcmVudHNNZXRhIiwiZmxhdHRlblJvdXRlIiwicmVsYXRpdmVQYXRoIiwibWV0YSIsImNhc2VTZW5zaXRpdmUiLCJjaGlsZHJlbkluZGV4Iiwiam9pblBhdGhzIiwicm91dGVzTWV0YSIsInNjb3JlIiwiY29tcHV0ZVNjb3JlIiwiZm9yRWFjaCIsIl9yb3V0ZSRwYXRoIiwiaW5jbHVkZXMiLCJfaXRlcmF0b3IiLCJfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciIsImV4cGxvZGVPcHRpb25hbFNlZ21lbnRzIiwiX3N0ZXAiLCJzIiwiZG9uZSIsImV4cGxvZGVkIiwiZXJyIiwiZiIsInNlZ21lbnRzIiwic3BsaXQiLCJfc2VnbWVudHMiLCJfdG9BcnJheSIsImZpcnN0IiwicmVzdCIsImlzT3B0aW9uYWwiLCJlbmRzV2l0aCIsInJlcXVpcmVkIiwicmVzdEV4cGxvZGVkIiwicmVzdWx0IiwiYXBwbHkiLCJzdWJwYXRoIiwic29ydCIsImEiLCJiIiwiY29tcGFyZUluZGV4ZXMiLCJwYXJhbVJlIiwiZHluYW1pY1NlZ21lbnRWYWx1ZSIsImluZGV4Um91dGVWYWx1ZSIsImVtcHR5U2VnbWVudFZhbHVlIiwic3RhdGljU2VnbWVudFZhbHVlIiwic3BsYXRQZW5hbHR5IiwiaXNTcGxhdCIsImluaXRpYWxTY29yZSIsInNvbWUiLCJmaWx0ZXIiLCJyZWR1Y2UiLCJzZWdtZW50IiwidGVzdCIsInNpYmxpbmdzIiwiZXZlcnkiLCJicmFuY2giLCJtYXRjaGVkUGFyYW1zIiwibWF0Y2hlZFBhdGhuYW1lIiwiZW5kIiwicmVtYWluaW5nUGF0aG5hbWUiLCJtYXRjaFBhdGgiLCJPYmplY3QiLCJwYXRobmFtZUJhc2UiLCJub3JtYWxpemVQYXRobmFtZSIsImdlbmVyYXRlUGF0aCIsIm9yaWdpbmFsUGF0aCIsInByZWZpeCIsInAiLCJTdHJpbmciLCJhcnJheSIsImlzTGFzdFNlZ21lbnQiLCJzdGFyIiwia2V5TWF0Y2giLCJfa2V5TWF0Y2giLCJfc2xpY2VkVG9BcnJheSIsIm9wdGlvbmFsIiwicGFyYW0iLCJwYXR0ZXJuIiwiX2NvbXBpbGVQYXRoIiwiY29tcGlsZVBhdGgiLCJfY29tcGlsZVBhdGgyIiwibWF0Y2hlciIsImNvbXBpbGVkUGFyYW1zIiwiY2FwdHVyZUdyb3VwcyIsIm1lbW8iLCJwYXJhbU5hbWUiLCJzcGxhdFZhbHVlIiwic2FmZWx5RGVjb2RlVVJJQ29tcG9uZW50IiwicmVnZXhwU291cmNlIiwiXyIsIlJlZ0V4cCIsImRlY29kZVVSSSIsImRlY29kZVVSSUNvbXBvbmVudCIsInRvTG93ZXJDYXNlIiwic3RhcnRJbmRleCIsIm5leHRDaGFyIiwicmVzb2x2ZVBhdGgiLCJmcm9tUGF0aG5hbWUiLCJfcmVmNCIsInRvUGF0aG5hbWUiLCJfcmVmNCRzZWFyY2giLCJfcmVmNCRoYXNoIiwicmVzb2x2ZVBhdGhuYW1lIiwibm9ybWFsaXplU2VhcmNoIiwibm9ybWFsaXplSGFzaCIsInJlbGF0aXZlU2VnbWVudHMiLCJwb3AiLCJnZXRJbnZhbGlkUGF0aEVycm9yIiwiY2hhciIsImZpZWxkIiwiZGVzdCIsImdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzIiwicmVzb2x2ZVRvIiwidG9BcmciLCJyb3V0ZVBhdGhuYW1lcyIsImxvY2F0aW9uUGF0aG5hbWUiLCJpc1BhdGhSZWxhdGl2ZSIsImlzRW1wdHlQYXRoIiwiZnJvbSIsImZyb21TZWdtZW50cyIsInRvU2VnbWVudHMiLCJzaGlmdCIsInJvdXRlUGF0aG5hbWVJbmRleCIsImhhc0V4cGxpY2l0VHJhaWxpbmdTbGFzaCIsImhhc0N1cnJlbnRUcmFpbGluZ1NsYXNoIiwiZ2V0VG9QYXRobmFtZSIsInBhdGhzIiwianNvbiIsImluaXQiLCJyZXNwb25zZUluaXQiLCJzdGF0dXMiLCJoZWFkZXJzIiwiSGVhZGVycyIsImhhcyIsInNldCIsIlJlc3BvbnNlIiwiQWJvcnRlZERlZmVycmVkRXJyb3IiLCJfRXJyb3IiLCJfaW5oZXJpdHMiLCJfc3VwZXIiLCJfY3JlYXRlU3VwZXIiLCJfY2xhc3NDYWxsQ2hlY2siLCJhcmd1bWVudHMiLCJfY3JlYXRlQ2xhc3MiLCJfd3JhcE5hdGl2ZVN1cGVyIiwiRGVmZXJyZWREYXRhIiwiX3RoaXMiLCJwZW5kaW5nS2V5c1NldCIsInN1YnNjcmliZXJzIiwiZGVmZXJyZWRLZXlzIiwiX3R5cGVvZiIsIkFycmF5IiwiaXNBcnJheSIsInJlamVjdCIsImFib3J0UHJvbWlzZSIsIlByb21pc2UiLCJyIiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsIm9uQWJvcnQiLCJ1bmxpc3RlbkFib3J0U2lnbmFsIiwic2lnbmFsIiwiYWNjIiwiX3JlZjIiLCJfcmVmNSIsIl9kZWZpbmVQcm9wZXJ0eSIsInRyYWNrUHJvbWlzZSIsIl90aGlzMiIsImFkZCIsInByb21pc2UiLCJyYWNlIiwidGhlbiIsIm9uU2V0dGxlIiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJhYm9ydGVkIiwidW5kZWZpbmVkRXJyb3IiLCJlbWl0Iiwic2V0dGxlZEtleSIsInN1YnNjcmliZXIiLCJzdWJzY3JpYmUiLCJfdGhpczMiLCJjYW5jZWwiLCJfdGhpczQiLCJhYm9ydCIsInYiLCJrIiwiX3Jlc29sdmVEYXRhIiwiX2FzeW5jVG9HZW5lcmF0b3IiLCJfcmVnZW5lcmF0b3JSdW50aW1lIiwibWFyayIsIl9jYWxsZWUiLCJfdGhpczUiLCJ3cmFwIiwiX2NhbGxlZSQiLCJfY29udGV4dCIsInByZXYiLCJuZXh0IiwicmVzb2x2ZSIsInNlbnQiLCJhYnJ1cHQiLCJzdG9wIiwicmVzb2x2ZURhdGEiLCJfeCIsInNpemUiLCJfcmVmMyIsIl9yZWY2IiwidW53cmFwVHJhY2tlZFByb21pc2UiLCJpc1RyYWNrZWRQcm9taXNlIiwiX3RyYWNrZWQiLCJfZXJyb3IiLCJfZGF0YSIsImRlZmVyIiwicmVkaXJlY3QiLCJyZWRpcmVjdERvY3VtZW50IiwicmVzcG9uc2UiLCJFcnJvclJlc3BvbnNlSW1wbCIsInN0YXR1c1RleHQiLCJpbnRlcm5hbCIsImlzUm91dGVFcnJvclJlc3BvbnNlIiwidmFsaWRNdXRhdGlvbk1ldGhvZHNBcnIiLCJ2YWxpZE11dGF0aW9uTWV0aG9kcyIsInZhbGlkUmVxdWVzdE1ldGhvZHNBcnIiLCJ2YWxpZFJlcXVlc3RNZXRob2RzIiwicmVkaXJlY3RTdGF0dXNDb2RlcyIsInJlZGlyZWN0UHJlc2VydmVNZXRob2RTdGF0dXNDb2RlcyIsIklETEVfTkFWSUdBVElPTiIsImZvcm1NZXRob2QiLCJmb3JtQWN0aW9uIiwiZm9ybUVuY1R5cGUiLCJmb3JtRGF0YSIsInRleHQiLCJJRExFX0ZFVENIRVIiLCJJRExFX0JMT0NLRVIiLCJwcm9jZWVkIiwicmVzZXQiLCJBQlNPTFVURV9VUkxfUkVHRVgiLCJkZWZhdWx0TWFwUm91dGVQcm9wZXJ0aWVzIiwiaGFzRXJyb3JCb3VuZGFyeSIsIkJvb2xlYW4iLCJUUkFOU0lUSU9OU19TVE9SQUdFX0tFWSIsImNyZWF0ZVJvdXRlciIsInJvdXRlcldpbmRvdyIsImlzQnJvd3NlciIsImNyZWF0ZUVsZW1lbnQiLCJpc1NlcnZlciIsImRldGVjdEVycm9yQm91bmRhcnkiLCJkYXRhUm91dGVzIiwiaW5GbGlnaHREYXRhUm91dGVzIiwiZnV0dXJlIiwidjdfZmV0Y2hlclBlcnNpc3QiLCJ2N19ub3JtYWxpemVGb3JtTWV0aG9kIiwidjdfcHJlcGVuZEJhc2VuYW1lIiwidW5saXN0ZW5IaXN0b3J5Iiwic2F2ZWRTY3JvbGxQb3NpdGlvbnMiLCJnZXRTY3JvbGxSZXN0b3JhdGlvbktleSIsImdldFNjcm9sbFBvc2l0aW9uIiwiaW5pdGlhbFNjcm9sbFJlc3RvcmVkIiwiaHlkcmF0aW9uRGF0YSIsImluaXRpYWxNYXRjaGVzIiwiaW5pdGlhbEVycm9ycyIsImdldEludGVybmFsUm91dGVyRXJyb3IiLCJfZ2V0U2hvcnRDaXJjdWl0TWF0Y2giLCJnZXRTaG9ydENpcmN1aXRNYXRjaGVzIiwiaW5pdGlhbGl6ZWQiLCJtIiwibGF6eSIsImxvYWRlciIsInJvdXRlciIsImhpc3RvcnlBY3Rpb24iLCJuYXZpZ2F0aW9uIiwicmVzdG9yZVNjcm9sbFBvc2l0aW9uIiwicHJldmVudFNjcm9sbFJlc2V0IiwicmV2YWxpZGF0aW9uIiwiYWN0aW9uRGF0YSIsImVycm9ycyIsImZldGNoZXJzIiwiTWFwIiwiYmxvY2tlcnMiLCJwZW5kaW5nQWN0aW9uIiwicGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCIsInBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciIsInBlbmRpbmdWaWV3VHJhbnNpdGlvbkVuYWJsZWQiLCJhcHBsaWVkVmlld1RyYW5zaXRpb25zIiwicmVtb3ZlUGFnZUhpZGVFdmVudExpc3RlbmVyIiwiaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uIiwiaXNSZXZhbGlkYXRpb25SZXF1aXJlZCIsImNhbmNlbGxlZERlZmVycmVkUm91dGVzIiwiY2FuY2VsbGVkRmV0Y2hlckxvYWRzIiwiZmV0Y2hDb250cm9sbGVycyIsImluY3JlbWVudGluZ0xvYWRJZCIsInBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkIiwiZmV0Y2hSZWxvYWRJZHMiLCJmZXRjaFJlZGlyZWN0SWRzIiwiZmV0Y2hMb2FkTWF0Y2hlcyIsImFjdGl2ZUZldGNoZXJzIiwiZGVsZXRlZEZldGNoZXJzIiwiYWN0aXZlRGVmZXJyZWRzIiwiYmxvY2tlckZ1bmN0aW9ucyIsImlnbm9yZU5leHRIaXN0b3J5VXBkYXRlIiwiaW5pdGlhbGl6ZSIsImJsb2NrZXJLZXkiLCJzaG91bGRCbG9ja05hdmlnYXRpb24iLCJjdXJyZW50TG9jYXRpb24iLCJ1cGRhdGVCbG9ja2VyIiwidXBkYXRlU3RhdGUiLCJzdGFydE5hdmlnYXRpb24iLCJyZXN0b3JlQXBwbGllZFRyYW5zaXRpb25zIiwiX3NhdmVBcHBsaWVkVHJhbnNpdGlvbnMiLCJwZXJzaXN0QXBwbGllZFRyYW5zaXRpb25zIiwiZGlzcG9zZSIsImNsZWFyIiwiZGVsZXRlRmV0Y2hlciIsImRlbGV0ZUJsb2NrZXIiLCJuZXdTdGF0ZSIsIm9wdHMiLCJjb21wbGV0ZWRGZXRjaGVycyIsImRlbGV0ZWRGZXRjaGVyc0tleXMiLCJmZXRjaGVyIiwidW5zdGFibGVfdmlld1RyYW5zaXRpb25PcHRzIiwidmlld1RyYW5zaXRpb25PcHRzIiwidW5zdGFibGVfZmx1c2hTeW5jIiwiZmx1c2hTeW5jIiwiY29tcGxldGVOYXZpZ2F0aW9uIiwiX3RlbXAiLCJfbG9jYXRpb24kc3RhdGUiLCJfbG9jYXRpb24kc3RhdGUyIiwiX3JlZjciLCJpc0FjdGlvblJlbG9hZCIsImlzTXV0YXRpb25NZXRob2QiLCJfaXNSZWRpcmVjdCIsImtleXMiLCJtZXJnZUxvYWRlckRhdGEiLCJwcmlvclBhdGhzIiwidG9QYXRocyIsImdldFNhdmVkU2Nyb2xsUG9zaXRpb24iLCJuYXZpZ2F0ZSIsIl94MiIsIl94MyIsIl9uYXZpZ2F0ZSIsIl9jYWxsZWUyIiwibm9ybWFsaXplZFBhdGgiLCJfbm9ybWFsaXplTmF2aWdhdGVPcHQyIiwic3VibWlzc2lvbiIsInVzZXJSZXBsYWNlIiwiX2NhbGxlZTIkIiwiX2NvbnRleHQyIiwibm9ybWFsaXplVG8iLCJmcm9tUm91dGVJZCIsInJlbGF0aXZlIiwibm9ybWFsaXplTmF2aWdhdGVPcHRpb25zIiwicGVuZGluZ0Vycm9yIiwiZW5hYmxlVmlld1RyYW5zaXRpb24iLCJ1bnN0YWJsZV92aWV3VHJhbnNpdGlvbiIsInJldmFsaWRhdGUiLCJpbnRlcnJ1cHRBY3RpdmVMb2FkcyIsInN0YXJ0VW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiIsIm92ZXJyaWRlTmF2aWdhdGlvbiIsIl94NCIsIl94NSIsIl94NiIsIl9zdGFydE5hdmlnYXRpb24iLCJfY2FsbGVlMyIsInJvdXRlc1RvVXNlIiwibG9hZGluZ05hdmlnYXRpb24iLCJfZ2V0U2hvcnRDaXJjdWl0TWF0Y2gyIiwibm90Rm91bmRNYXRjaGVzIiwiX3JvdXRlIiwicmVxdWVzdCIsInBlbmRpbmdBY3Rpb25EYXRhIiwiYWN0aW9uT3V0cHV0IiwiX3lpZWxkJGhhbmRsZUxvYWRlcnMiLCJzaG9ydENpcmN1aXRlZCIsIl9jYWxsZWUzJCIsIl9jb250ZXh0MyIsInNhdmVTY3JvbGxQb3NpdGlvbiIsImNhbmNlbEFjdGl2ZURlZmVycmVkcyIsImlzSGFzaENoYW5nZU9ubHkiLCJjcmVhdGVDbGllbnRTaWRlUmVxdWVzdCIsImZpbmROZWFyZXN0Qm91bmRhcnkiLCJoYW5kbGVBY3Rpb24iLCJwZW5kaW5nQWN0aW9uRXJyb3IiLCJnZXRMb2FkaW5nTmF2aWdhdGlvbiIsIlJlcXVlc3QiLCJoYW5kbGVMb2FkZXJzIiwiZmV0Y2hlclN1Ym1pc3Npb24iLCJfeDciLCJfeDgiLCJfeDkiLCJfeDEwIiwiX3gxMSIsIl9oYW5kbGVBY3Rpb24iLCJfY2FsbGVlNCIsImFjdGlvbk1hdGNoIiwiYm91bmRhcnlNYXRjaCIsIl9jYWxsZWU0JCIsIl9jb250ZXh0NCIsImdldFN1Ym1pdHRpbmdOYXZpZ2F0aW9uIiwiZ2V0VGFyZ2V0TWF0Y2giLCJ0eXBlIiwibWV0aG9kIiwicm91dGVJZCIsImNhbGxMb2FkZXJPckFjdGlvbiIsImlzUmVkaXJlY3RSZXN1bHQiLCJzdGFydFJlZGlyZWN0TmF2aWdhdGlvbiIsImlzRXJyb3JSZXN1bHQiLCJpc0RlZmVycmVkUmVzdWx0IiwiX3gxMiIsIl94MTMiLCJfeDE0IiwiX3gxNSIsIl94MTYiLCJfeDE3IiwiX3gxOCIsIl94MTkiLCJfeDIwIiwiX3gyMSIsIl9oYW5kbGVMb2FkZXJzIiwiX2NhbGxlZTUiLCJhY3RpdmVTdWJtaXNzaW9uIiwiX2dldE1hdGNoZXNUb0xvYWQiLCJfZ2V0TWF0Y2hlc1RvTG9hZDIiLCJtYXRjaGVzVG9Mb2FkIiwicmV2YWxpZGF0aW5nRmV0Y2hlcnMiLCJfdXBkYXRlZEZldGNoZXJzIiwiYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zIiwiX3lpZWxkJGNhbGxMb2FkZXJzQW5kIiwicmVzdWx0cyIsImxvYWRlclJlc3VsdHMiLCJmZXRjaGVyUmVzdWx0cyIsImZldGNoZXJLZXkiLCJfcHJvY2Vzc0xvYWRlckRhdGEiLCJ1cGRhdGVkRmV0Y2hlcnMiLCJkaWRBYm9ydEZldGNoTG9hZHMiLCJzaG91bGRVcGRhdGVGZXRjaGVycyIsIl9jYWxsZWU1JCIsIl9jb250ZXh0NSIsImdldFN1Ym1pc3Npb25Gcm9tTmF2aWdhdGlvbiIsImdldE1hdGNoZXNUb0xvYWQiLCJtYXJrRmV0Y2hSZWRpcmVjdHNEb25lIiwicmYiLCJyZXZhbGlkYXRpbmdGZXRjaGVyIiwiZ2V0TG9hZGluZ0ZldGNoZXIiLCJhYm9ydEZldGNoZXIiLCJjYWxsTG9hZGVyc0FuZE1heWJlUmVzb2x2ZURhdGEiLCJmaW5kUmVkaXJlY3QiLCJwcm9jZXNzTG9hZGVyRGF0YSIsImRlZmVycmVkRGF0YSIsImFib3J0U3RhbGVGZXRjaExvYWRzIiwiZmV0Y2giLCJzZXRGZXRjaGVyRXJyb3IiLCJfbm9ybWFsaXplTmF2aWdhdGVPcHQiLCJoYW5kbGVGZXRjaGVyQWN0aW9uIiwiaGFuZGxlRmV0Y2hlckxvYWRlciIsIl94MjIiLCJfeDIzIiwiX3gyNCIsIl94MjUiLCJfeDI2IiwiX3gyNyIsIl94MjgiLCJfaGFuZGxlRmV0Y2hlckFjdGlvbiIsIl9jYWxsZWU2IiwicmVxdWVzdE1hdGNoZXMiLCJfZXJyb3IyIiwiZXhpc3RpbmdGZXRjaGVyIiwiYWJvcnRDb250cm9sbGVyIiwiZmV0Y2hSZXF1ZXN0Iiwib3JpZ2luYXRpbmdMb2FkSWQiLCJhY3Rpb25SZXN1bHQiLCJyZXZhbGlkYXRpb25SZXF1ZXN0IiwibG9hZElkIiwibG9hZEZldGNoZXIiLCJfZ2V0TWF0Y2hlc1RvTG9hZDMiLCJfZ2V0TWF0Y2hlc1RvTG9hZDQiLCJfeWllbGQkY2FsbExvYWRlcnNBbmQyIiwiX3Byb2Nlc3NMb2FkZXJEYXRhMiIsImRvbmVGZXRjaGVyIiwiX2NhbGxlZTYkIiwiX2NvbnRleHQ2IiwidXBkYXRlRmV0Y2hlclN0YXRlIiwiZ2V0U3VibWl0dGluZ0ZldGNoZXIiLCJnZXREb25lRmV0Y2hlciIsInN0YWxlS2V5IiwiX3gyOSIsIl94MzAiLCJfeDMxIiwiX3gzMiIsIl94MzMiLCJfeDM0IiwiX3gzNSIsIl9oYW5kbGVGZXRjaGVyTG9hZGVyIiwiX2NhbGxlZTciLCJfY2FsbGVlNyQiLCJfY29udGV4dDciLCJyZXNvbHZlRGVmZXJyZWREYXRhIiwidDAiLCJfeDM2IiwiX3gzNyIsIl94MzgiLCJfc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24iLCJfY2FsbGVlOCIsIl90ZW1wMiIsIl9yZWY4IiwicmVkaXJlY3RMb2NhdGlvbiIsImlzRG9jdW1lbnRSZWxvYWQiLCJyZWRpcmVjdEhpc3RvcnlBY3Rpb24iLCJfc3RhdGUkbmF2aWdhdGlvbiIsIl9jYWxsZWU4JCIsIl9jb250ZXh0OCIsInJlbG9hZERvY3VtZW50IiwiX3gzOSIsIl94NDAiLCJfeDQxIiwiX3g0MiIsIl94NDMiLCJfY2FsbExvYWRlcnNBbmRNYXliZVJlc29sdmVEYXRhIiwiX2NhbGxlZTkiLCJjdXJyZW50TWF0Y2hlcyIsImZldGNoZXJzVG9Mb2FkIiwiX2NhbGxlZTkkIiwiX2NvbnRleHQ5IiwiYWxsIiwicmVzb2x2ZURlZmVycmVkUmVzdWx0cyIsIl9jYW5jZWxsZWREZWZlcnJlZFJvdSIsImdldEZldGNoZXIiLCJkZWxldGVGZXRjaGVyQW5kVXBkYXRlU3RhdGUiLCJjb3VudCIsIm1hcmtGZXRjaGVyc0RvbmUiLCJfaXRlcmF0b3IyIiwiX3N0ZXAyIiwiZG9uZUtleXMiLCJfaXRlcmF0b3IzIiwiX3N0ZXAzIiwibGFuZGVkSWQiLCJ5ZWV0ZWRLZXlzIiwiX2l0ZXJhdG9yNCIsIl9zdGVwNCIsIl9zdGVwNCR2YWx1ZSIsImdldEJsb2NrZXIiLCJibG9ja2VyIiwibmV3QmxvY2tlciIsIl9lbnRyaWVzIiwiYmxvY2tlckZ1bmN0aW9uIiwicHJlZGljYXRlIiwiY2FuY2VsbGVkUm91dGVJZHMiLCJkZmQiLCJlbmFibGVTY3JvbGxSZXN0b3JhdGlvbiIsInBvc2l0aW9ucyIsImdldFBvc2l0aW9uIiwiZ2V0S2V5IiwieSIsImdldFNjcm9sbEtleSIsIl9pbnRlcm5hbFNldFJvdXRlcyIsIm5ld1JvdXRlcyIsIl9pbnRlcm5hbEZldGNoQ29udHJvbGxlcnMiLCJfaW50ZXJuYWxBY3RpdmVEZWZlcnJlZHMiLCJVTlNBRkVfREVGRVJSRURfU1lNQk9MIiwiU3ltYm9sIiwiY3JlYXRlU3RhdGljSGFuZGxlciIsInF1ZXJ5IiwiX3g0NCIsIl94NDUiLCJfcXVlcnkiLCJfY2FsbGVlMTAiLCJfdGVtcDMiLCJfcmVmOSIsInJlcXVlc3RDb250ZXh0IiwiX2dldFNob3J0Q2lyY3VpdE1hdGNoMyIsIm1ldGhvZE5vdEFsbG93ZWRNYXRjaGVzIiwiX2Vycm9yNCIsIl9nZXRTaG9ydENpcmN1aXRNYXRjaDQiLCJfcm91dGUyIiwiX2NhbGxlZTEwJCIsIl9jb250ZXh0MTAiLCJpc1ZhbGlkTWV0aG9kIiwic3RhdHVzQ29kZSIsImxvYWRlckhlYWRlcnMiLCJhY3Rpb25IZWFkZXJzIiwicXVlcnlJbXBsIiwiaXNSZXNwb25zZSIsInF1ZXJ5Um91dGUiLCJfeDQ2IiwiX3g0NyIsIl9xdWVyeVJvdXRlIiwiX2NhbGxlZTExIiwiX3RlbXA0IiwiX3JlZjEwIiwiX3Jlc3VsdCRhY3RpdmVEZWZlcnJlIiwiX2NhbGxlZTExJCIsIl9jb250ZXh0MTEiLCJmaW5kIiwidmFsdWVzIiwiX3g0OCIsIl94NDkiLCJfeDUwIiwiX3g1MSIsIl94NTIiLCJfcXVlcnlJbXBsIiwiX2NhbGxlZTEyIiwicm91dGVNYXRjaCIsIl9yZXN1bHQiLCJfY2FsbGVlMTIkIiwiX2NvbnRleHQxMiIsInN1Ym1pdCIsImxvYWRSb3V0ZURhdGEiLCJpc1F1ZXJ5Um91dGVSZXNwb25zZSIsImlzUmVkaXJlY3RSZXNwb25zZSIsIl94NTMiLCJfeDU0IiwiX3g1NSIsIl94NTYiLCJfeDU3IiwiX3N1Ym1pdCIsIl9jYWxsZWUxMyIsImlzUm91dGVSZXF1ZXN0IiwiX2Vycm9yNSIsIl9jb250ZXh0MTMiLCJsb2FkZXJSZXF1ZXN0IiwiY29udGV4dCIsIl9jYWxsZWUxMyQiLCJfY29udGV4dDE0IiwiaXNTdGF0aWNSZXF1ZXN0IiwiTG9jYXRpb24iLCJfeDU4IiwiX3g1OSIsIl94NjAiLCJfeDYxIiwiX3g2MiIsIl9sb2FkUm91dGVEYXRhIiwiX2NhbGxlZTE0IiwiZXhlY3V0ZWRMb2FkZXJzIiwiX2NhbGxlZTE0JCIsIl9jb250ZXh0MTUiLCJnZXRMb2FkZXJNYXRjaGVzVW50aWxCb3VuZGFyeSIsInByb2Nlc3NSb3V0ZUxvYWRlckRhdGEiLCJmcm9tRW50cmllcyIsImdldFN0YXRpY0NvbnRleHRGcm9tRXJyb3IiLCJuZXdDb250ZXh0IiwiX2RlZXBlc3RSZW5kZXJlZEJvdW5kYXJ5SWQiLCJpc1N1Ym1pc3Npb25OYXZpZ2F0aW9uIiwiYm9keSIsInByZXBlbmRCYXNlbmFtZSIsImNvbnRleHR1YWxNYXRjaGVzIiwiYWN0aXZlUm91dGVNYXRjaCIsIl9pdGVyYXRvcjUiLCJfc3RlcDUiLCJoYXNOYWtlZEluZGV4UXVlcnkiLCJub3JtYWxpemVGb3JtTWV0aG9kIiwiaXNGZXRjaGVyIiwiZ2V0SW52YWxpZEJvZHlFcnJvciIsInJhd0Zvcm1NZXRob2QiLCJ0b1VwcGVyQ2FzZSIsInN0cmlwSGFzaEZyb21QYXRoIiwiRm9ybURhdGEiLCJVUkxTZWFyY2hQYXJhbXMiLCJfcmVmMTMiLCJwYXJzZSIsInNlYXJjaFBhcmFtcyIsImNvbnZlcnRGb3JtRGF0YVRvU2VhcmNoUGFyYW1zIiwiY29udmVydFNlYXJjaFBhcmFtc1RvRm9ybURhdGEiLCJhcHBlbmQiLCJib3VuZGFyeUlkIiwiYm91bmRhcnlNYXRjaGVzIiwiZmluZEluZGV4IiwiY3VycmVudFVybCIsIm5leHRVcmwiLCJuYXZpZ2F0aW9uTWF0Y2hlcyIsImlzTmV3TG9hZGVyIiwiY3VycmVudFJvdXRlTWF0Y2giLCJuZXh0Um91dGVNYXRjaCIsInNob3VsZFJldmFsaWRhdGVMb2FkZXIiLCJjdXJyZW50UGFyYW1zIiwibmV4dFBhcmFtcyIsImRlZmF1bHRTaG91bGRSZXZhbGlkYXRlIiwiaXNOZXdSb3V0ZUluc3RhbmNlIiwiZmV0Y2hlck1hdGNoZXMiLCJmZXRjaGVyTWF0Y2giLCJzaG91bGRSZXZhbGlkYXRlIiwiY3VycmVudExvYWRlckRhdGEiLCJjdXJyZW50TWF0Y2giLCJpc05ldyIsImlzTWlzc2luZ0RhdGEiLCJjdXJyZW50UGF0aCIsImxvYWRlck1hdGNoIiwiYXJnIiwicm91dGVDaG9pY2UiLCJsb2FkTGF6eVJvdXRlTW9kdWxlIiwiX3g2MyIsIl94NjQiLCJfeDY1IiwiX2xvYWRMYXp5Um91dGVNb2R1bGUiLCJfY2FsbGVlMTUiLCJsYXp5Um91dGUiLCJyb3V0ZVRvVXBkYXRlIiwicm91dGVVcGRhdGVzIiwibGF6eVJvdXRlUHJvcGVydHkiLCJzdGF0aWNSb3V0ZVZhbHVlIiwiaXNQcm9wZXJ0eVN0YXRpY2FsbHlEZWZpbmVkIiwiX2NhbGxlZTE1JCIsIl9jb250ZXh0MTYiLCJfeDY2IiwiX3g2NyIsIl94NjgiLCJfeDY5IiwiX3g3MCIsIl94NzEiLCJfeDcyIiwiX3g3MyIsIl9jYWxsTG9hZGVyT3JBY3Rpb24iLCJfY2FsbGVlMTYiLCJyZXN1bHRUeXBlIiwib25SZWplY3QiLCJydW5IYW5kbGVyIiwiaGFuZGxlciIsImhhbmRsZXJFcnJvciIsIl91cmwiLCJfcGF0aG5hbWUiLCJfdXJsMiIsImlzU2FtZUJhc2VuYW1lIiwicXVlcnlSb3V0ZVJlc3BvbnNlIiwiY29udGVudFR5cGUiLCJfcmVzdWx0JGluaXQiLCJfcmVzdWx0JGluaXQyIiwiX2NhbGxlZTE2JCIsIl9jb250ZXh0MTciLCJmaW5pc2giLCJwcm90b2NvbCIsImlzRGVmZXJyZWREYXRhIiwiZGVmZXJyZWQiLCJfaXRlcmF0b3I2IiwiX3N0ZXA2IiwiX3N0ZXA2JHZhbHVlIiwiX2l0ZXJhdG9yNyIsIl9zdGVwNyIsIl9zdGVwNyR2YWx1ZSIsImZvdW5kRXJyb3IiLCJfcHJvY2Vzc1JvdXRlTG9hZGVyRGEiLCJfcmV2YWxpZGF0aW5nRmV0Y2hlcnMiLCJuZXdMb2FkZXJEYXRhIiwibWVyZ2VkTG9hZGVyRGF0YSIsIl9pdGVyYXRvcjgiLCJfc3RlcDgiLCJoYXNPd25Qcm9wZXJ0eSIsImVsaWdpYmxlTWF0Y2hlcyIsInJldmVyc2UiLCJfdGVtcDUiLCJfcmVmMTQiLCJlcnJvck1lc3NhZ2UiLCJvYmoiLCJfeDc0IiwiX3g3NSIsIl94NzYiLCJfeDc3IiwiX3g3OCIsIl94NzkiLCJfcmVzb2x2ZURlZmVycmVkUmVzdWx0cyIsIl9jYWxsZWUxNyIsInNpZ25hbHMiLCJfbG9vcCIsIl9jYWxsZWUxNyQiLCJfY29udGV4dDE5IiwiaXNSZXZhbGlkYXRpbmdMb2FkZXIiLCJfbG9vcCQiLCJfY29udGV4dDE4IiwiZGVsZWdhdGVZaWVsZCIsIl94ODAiLCJfeDgxIiwiX3g4MiIsIl9yZXNvbHZlRGVmZXJyZWREYXRhIiwiX2NhbGxlZTE4IiwidW53cmFwIiwiX2NhbGxlZTE4JCIsIl9jb250ZXh0MjAiLCJ1bndyYXBwZWREYXRhIiwiZ2V0QWxsIiwicGF0aE1hdGNoZXMiLCJfd2luZG93IiwidHJhbnNpdGlvbnMiLCJzZXNzaW9uUG9zaXRpb25zIiwic2Vzc2lvblN0b3JhZ2UiLCJnZXRJdGVtIiwiX2kiLCJfT2JqZWN0JGVudHJpZXMiLCJfT2JqZWN0JGVudHJpZXMkX2kiLCJfaXRlcmF0b3I5IiwiX3N0ZXA5IiwiX3N0ZXA5JHZhbHVlIiwic2V0SXRlbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///194\n')}}]);