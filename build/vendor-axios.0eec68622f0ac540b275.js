"use strict";(self.webpackChunkquil=self.webpackChunkquil||[]).push([[323],{708:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  Z: () => (/* binding */ lib_axios)\n});\n\n// NAMESPACE OBJECT: ./node_modules/axios/lib/platform/common/utils.js\nvar common_utils_namespaceObject = {};\n__webpack_require__.r(common_utils_namespaceObject);\n__webpack_require__.d(common_utils_namespaceObject, {\n  hasBrowserEnv: () => (hasBrowserEnv),\n  hasStandardBrowserEnv: () => (hasStandardBrowserEnv),\n  hasStandardBrowserWebWorkerEnv: () => (hasStandardBrowserWebWorkerEnv)\n});\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/bind.js\n\n\nfunction bind(fn, thisArg) {\n  return function wrap() {\n    return fn.apply(thisArg, arguments);\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/utils.js\n\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar utils_toString = Object.prototype.toString;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar kindOf = function (cache) {\n  return function (thing) {\n    var str = utils_toString.call(thing);\n    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());\n  };\n}(Object.create(null));\nvar kindOfTest = function kindOfTest(type) {\n  type = type.toLowerCase();\n  return function (thing) {\n    return kindOf(thing) === type;\n  };\n};\nvar typeOfTest = function typeOfTest(type) {\n  return function (thing) {\n    return _typeof(thing) === type;\n  };\n};\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n *\n * @returns {boolean} True if value is an Array, otherwise false\n */\nvar isArray = Array.isArray;\n\n/**\n * Determine if a value is undefined\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nvar isUndefined = typeOfTest('undefined');\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nvar isArrayBuffer = kindOfTest('ArrayBuffer');\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = val && val.buffer && isArrayBuffer(val.buffer);\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a String, otherwise false\n */\nvar isString = typeOfTest('string');\n\n/**\n * Determine if a value is a Function\n *\n * @param {*} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nvar isFunction = typeOfTest('function');\n\n/**\n * Determine if a value is a Number\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Number, otherwise false\n */\nvar isNumber = typeOfTest('number');\n\n/**\n * Determine if a value is an Object\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an Object, otherwise false\n */\nvar isObject = function isObject(thing) {\n  return thing !== null && _typeof(thing) === 'object';\n};\n\n/**\n * Determine if a value is a Boolean\n *\n * @param {*} thing The value to test\n * @returns {boolean} True if value is a Boolean, otherwise false\n */\nvar isBoolean = function isBoolean(thing) {\n  return thing === true || thing === false;\n};\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a plain Object, otherwise false\n */\nvar isPlainObject = function isPlainObject(val) {\n  if (kindOf(val) !== 'object') {\n    return false;\n  }\n  var prototype = getPrototypeOf(val);\n  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);\n};\n\n/**\n * Determine if a value is a Date\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Date, otherwise false\n */\nvar isDate = kindOfTest('Date');\n\n/**\n * Determine if a value is a File\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\nvar isFile = kindOfTest('File');\n\n/**\n * Determine if a value is a Blob\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nvar isBlob = kindOfTest('Blob');\n\n/**\n * Determine if a value is a FileList\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\nvar isFileList = kindOfTest('FileList');\n\n/**\n * Determine if a value is a Stream\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nvar isStream = function isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n};\n\n/**\n * Determine if a value is a FormData\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nvar isFormData = function isFormData(thing) {\n  var kind;\n  return thing && (typeof FormData === 'function' && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === 'formdata' ||\n  // detect form-data instance\n  kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]'));\n};\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nvar isURLSearchParams = kindOfTest('URLSearchParams');\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n *\n * @returns {String} The String freed of excess whitespace\n */\nvar trim = function trim(str) {\n  return str.trim ? str.trim() : str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n};\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n *\n * @param {Boolean} [allOwnKeys = false]\n * @returns {any}\n */\nfunction forEach(obj, fn) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n    _ref$allOwnKeys = _ref.allOwnKeys,\n    allOwnKeys = _ref$allOwnKeys === void 0 ? false : _ref$allOwnKeys;\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n  var i;\n  var l;\n\n  // Force an array if not already something iterable\n  if (_typeof(obj) !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    var keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);\n    var len = keys.length;\n    var key;\n    for (i = 0; i < len; i++) {\n      key = keys[i];\n      fn.call(null, obj[key], key, obj);\n    }\n  }\n}\nfunction findKey(obj, key) {\n  key = key.toLowerCase();\n  var keys = Object.keys(obj);\n  var i = keys.length;\n  var _key;\n  while (i-- > 0) {\n    _key = keys[i];\n    if (key === _key.toLowerCase()) {\n      return _key;\n    }\n  }\n  return null;\n}\nvar _global = function () {\n  /*eslint no-undef:0*/\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  return typeof self !== \"undefined\" ? self : typeof window !== 'undefined' ? window : global;\n}();\nvar isContextDefined = function isContextDefined(context) {\n  return !isUndefined(context) && context !== _global;\n};\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n *\n * @returns {Object} Result of all merge properties\n */\nfunction merge( /* obj1, obj2, obj3, ... */\n) {\n  var _ref2 = isContextDefined(this) && this || {},\n    caseless = _ref2.caseless;\n  var result = {};\n  var assignValue = function assignValue(val, key) {\n    var targetKey = caseless && findKey(result, key) || key;\n    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {\n      result[targetKey] = merge(result[targetKey], val);\n    } else if (isPlainObject(val)) {\n      result[targetKey] = merge({}, val);\n    } else if (isArray(val)) {\n      result[targetKey] = val.slice();\n    } else {\n      result[targetKey] = val;\n    }\n  };\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    arguments[i] && forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n *\n * @param {Boolean} [allOwnKeys]\n * @returns {Object} The resulting value of object a\n */\nvar extend = function extend(a, b, thisArg) {\n  var _ref3 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n    allOwnKeys = _ref3.allOwnKeys;\n  forEach(b, function (val, key) {\n    if (thisArg && isFunction(val)) {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  }, {\n    allOwnKeys: allOwnKeys\n  });\n  return a;\n};\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n *\n * @returns {string} content value without BOM\n */\nvar stripBOM = function stripBOM(content) {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n};\n\n/**\n * Inherit the prototype methods from one constructor into another\n * @param {function} constructor\n * @param {function} superConstructor\n * @param {object} [props]\n * @param {object} [descriptors]\n *\n * @returns {void}\n */\nvar inherits = function inherits(constructor, superConstructor, props, descriptors) {\n  constructor.prototype = Object.create(superConstructor.prototype, descriptors);\n  constructor.prototype.constructor = constructor;\n  Object.defineProperty(constructor, 'super', {\n    value: superConstructor.prototype\n  });\n  props && Object.assign(constructor.prototype, props);\n};\n\n/**\n * Resolve object with deep prototype chain to a flat object\n * @param {Object} sourceObj source object\n * @param {Object} [destObj]\n * @param {Function|Boolean} [filter]\n * @param {Function} [propFilter]\n *\n * @returns {Object}\n */\nvar toFlatObject = function toFlatObject(sourceObj, destObj, filter, propFilter) {\n  var props;\n  var i;\n  var prop;\n  var merged = {};\n  destObj = destObj || {};\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  if (sourceObj == null) return destObj;\n  do {\n    props = Object.getOwnPropertyNames(sourceObj);\n    i = props.length;\n    while (i-- > 0) {\n      prop = props[i];\n      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {\n        destObj[prop] = sourceObj[prop];\n        merged[prop] = true;\n      }\n    }\n    sourceObj = filter !== false && getPrototypeOf(sourceObj);\n  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);\n  return destObj;\n};\n\n/**\n * Determines whether a string ends with the characters of a specified string\n *\n * @param {String} str\n * @param {String} searchString\n * @param {Number} [position= 0]\n *\n * @returns {boolean}\n */\nvar endsWith = function endsWith(str, searchString, position) {\n  str = String(str);\n  if (position === undefined || position > str.length) {\n    position = str.length;\n  }\n  position -= searchString.length;\n  var lastIndex = str.indexOf(searchString, position);\n  return lastIndex !== -1 && lastIndex === position;\n};\n\n/**\n * Returns new array from array like object or null if failed\n *\n * @param {*} [thing]\n *\n * @returns {?Array}\n */\nvar toArray = function toArray(thing) {\n  if (!thing) return null;\n  if (isArray(thing)) return thing;\n  var i = thing.length;\n  if (!isNumber(i)) return null;\n  var arr = new Array(i);\n  while (i-- > 0) {\n    arr[i] = thing[i];\n  }\n  return arr;\n};\n\n/**\n * Checking if the Uint8Array exists and if it does, it returns a function that checks if the\n * thing passed in is an instance of Uint8Array\n *\n * @param {TypedArray}\n *\n * @returns {Array}\n */\n// eslint-disable-next-line func-names\nvar isTypedArray = function (TypedArray) {\n  // eslint-disable-next-line func-names\n  return function (thing) {\n    return TypedArray && thing instanceof TypedArray;\n  };\n}(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));\n\n/**\n * For each entry in the object, call the function with the key and value.\n *\n * @param {Object<any, any>} obj - The object to iterate over.\n * @param {Function} fn - The function to call for each entry.\n *\n * @returns {void}\n */\nvar forEachEntry = function forEachEntry(obj, fn) {\n  var generator = obj && obj[Symbol.iterator];\n  var iterator = generator.call(obj);\n  var result;\n  while ((result = iterator.next()) && !result.done) {\n    var pair = result.value;\n    fn.call(obj, pair[0], pair[1]);\n  }\n};\n\n/**\n * It takes a regular expression and a string, and returns an array of all the matches\n *\n * @param {string} regExp - The regular expression to match against.\n * @param {string} str - The string to search.\n *\n * @returns {Array<boolean>}\n */\nvar matchAll = function matchAll(regExp, str) {\n  var matches;\n  var arr = [];\n  while ((matches = regExp.exec(str)) !== null) {\n    arr.push(matches);\n  }\n  return arr;\n};\n\n/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */\nvar isHTMLForm = kindOfTest('HTMLFormElement');\nvar toCamelCase = function toCamelCase(str) {\n  return str.toLowerCase().replace(/[-_\\s]([a-z\\d])(\\w*)/g, function replacer(m, p1, p2) {\n    return p1.toUpperCase() + p2;\n  });\n};\n\n/* Creating a function that will check if an object has a property. */\nvar utils_hasOwnProperty = function (_ref4) {\n  var hasOwnProperty = _ref4.hasOwnProperty;\n  return function (obj, prop) {\n    return hasOwnProperty.call(obj, prop);\n  };\n}(Object.prototype);\n\n/**\n * Determine if a value is a RegExp object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a RegExp object, otherwise false\n */\nvar isRegExp = kindOfTest('RegExp');\nvar reduceDescriptors = function reduceDescriptors(obj, reducer) {\n  var descriptors = Object.getOwnPropertyDescriptors(obj);\n  var reducedDescriptors = {};\n  forEach(descriptors, function (descriptor, name) {\n    var ret;\n    if ((ret = reducer(descriptor, name, obj)) !== false) {\n      reducedDescriptors[name] = ret || descriptor;\n    }\n  });\n  Object.defineProperties(obj, reducedDescriptors);\n};\n\n/**\n * Makes all methods read-only\n * @param {Object} obj\n */\n\nvar freezeMethods = function freezeMethods(obj) {\n  reduceDescriptors(obj, function (descriptor, name) {\n    // skip restricted props in strict mode\n    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {\n      return false;\n    }\n    var value = obj[name];\n    if (!isFunction(value)) return;\n    descriptor.enumerable = false;\n    if ('writable' in descriptor) {\n      descriptor.writable = false;\n      return;\n    }\n    if (!descriptor.set) {\n      descriptor.set = function () {\n        throw Error('Can not rewrite read-only method \\'' + name + '\\'');\n      };\n    }\n  });\n};\nvar toObjectSet = function toObjectSet(arrayOrString, delimiter) {\n  var obj = {};\n  var define = function define(arr) {\n    arr.forEach(function (value) {\n      obj[value] = true;\n    });\n  };\n  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));\n  return obj;\n};\nvar noop = function noop() {};\nvar toFiniteNumber = function toFiniteNumber(value, defaultValue) {\n  value = +value;\n  return Number.isFinite(value) ? value : defaultValue;\n};\nvar ALPHA = 'abcdefghijklmnopqrstuvwxyz';\nvar DIGIT = '0123456789';\nvar ALPHABET = {\n  DIGIT: DIGIT,\n  ALPHA: ALPHA,\n  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT\n};\nvar generateString = function generateString() {\n  var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16;\n  var alphabet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ALPHABET.ALPHA_DIGIT;\n  var str = '';\n  var length = alphabet.length;\n  while (size--) {\n    str += alphabet[Math.random() * length | 0];\n  }\n  return str;\n};\n\n/**\n * If the thing is a FormData object, return true, otherwise return false.\n *\n * @param {unknown} thing - The thing to check.\n *\n * @returns {boolean}\n */\nfunction isSpecCompliantForm(thing) {\n  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);\n}\nvar toJSONObject = function toJSONObject(obj) {\n  var stack = new Array(10);\n  var visit = function visit(source, i) {\n    if (isObject(source)) {\n      if (stack.indexOf(source) >= 0) {\n        return;\n      }\n      if (!('toJSON' in source)) {\n        stack[i] = source;\n        var target = isArray(source) ? [] : {};\n        forEach(source, function (value, key) {\n          var reducedValue = visit(value, i + 1);\n          !isUndefined(reducedValue) && (target[key] = reducedValue);\n        });\n        stack[i] = undefined;\n        return target;\n      }\n    }\n    return source;\n  };\n  return visit(obj, 0);\n};\nvar isAsyncFn = kindOfTest('AsyncFunction');\nvar isThenable = function isThenable(thing) {\n  return thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing[\"catch\"]);\n};\n/* harmony default export */ const utils = ({\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isBoolean: isBoolean,\n  isObject: isObject,\n  isPlainObject: isPlainObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isRegExp: isRegExp,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isTypedArray: isTypedArray,\n  isFileList: isFileList,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim,\n  stripBOM: stripBOM,\n  inherits: inherits,\n  toFlatObject: toFlatObject,\n  kindOf: kindOf,\n  kindOfTest: kindOfTest,\n  endsWith: endsWith,\n  toArray: toArray,\n  forEachEntry: forEachEntry,\n  matchAll: matchAll,\n  isHTMLForm: isHTMLForm,\n  hasOwnProperty: utils_hasOwnProperty,\n  hasOwnProp: utils_hasOwnProperty,\n  // an alias to avoid ESLint no-prototype-builtins detection\n  reduceDescriptors: reduceDescriptors,\n  freezeMethods: freezeMethods,\n  toObjectSet: toObjectSet,\n  toCamelCase: toCamelCase,\n  noop: noop,\n  toFiniteNumber: toFiniteNumber,\n  findKey: findKey,\n  global: _global,\n  isContextDefined: isContextDefined,\n  ALPHABET: ALPHABET,\n  generateString: generateString,\n  isSpecCompliantForm: isSpecCompliantForm,\n  toJSONObject: toJSONObject,\n  isAsyncFn: isAsyncFn,\n  isThenable: isThenable\n});\n;// CONCATENATED MODULE: ./node_modules/axios/lib/core/AxiosError.js\n\n\n\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [config] The config.\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n *\n * @returns {Error} The created error.\n */\nfunction AxiosError(message, code, config, request, response) {\n  Error.call(this);\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    this.stack = new Error().stack;\n  }\n  this.message = message;\n  this.name = 'AxiosError';\n  code && (this.code = code);\n  config && (this.config = config);\n  request && (this.request = request);\n  response && (this.response = response);\n}\nutils.inherits(AxiosError, Error, {\n  toJSON: function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: utils.toJSONObject(this.config),\n      code: this.code,\n      status: this.response && this.response.status ? this.response.status : null\n    };\n  }\n});\nvar AxiosError_prototype = AxiosError.prototype;\nvar descriptors = {};\n['ERR_BAD_OPTION_VALUE', 'ERR_BAD_OPTION', 'ECONNABORTED', 'ETIMEDOUT', 'ERR_NETWORK', 'ERR_FR_TOO_MANY_REDIRECTS', 'ERR_DEPRECATED', 'ERR_BAD_RESPONSE', 'ERR_BAD_REQUEST', 'ERR_CANCELED', 'ERR_NOT_SUPPORT', 'ERR_INVALID_URL'\n// eslint-disable-next-line func-names\n].forEach(function (code) {\n  descriptors[code] = {\n    value: code\n  };\n});\nObject.defineProperties(AxiosError, descriptors);\nObject.defineProperty(AxiosError_prototype, 'isAxiosError', {\n  value: true\n});\n\n// eslint-disable-next-line func-names\nAxiosError.from = function (error, code, config, request, response, customProps) {\n  var axiosError = Object.create(AxiosError_prototype);\n  utils.toFlatObject(error, axiosError, function filter(obj) {\n    return obj !== Error.prototype;\n  }, function (prop) {\n    return prop !== 'isAxiosError';\n  });\n  AxiosError.call(axiosError, error.message, code, config, request, response);\n  axiosError.cause = error;\n  axiosError.name = error.name;\n  customProps && Object.assign(axiosError, customProps);\n  return axiosError;\n};\n/* harmony default export */ const core_AxiosError = (AxiosError);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/null.js\n// eslint-disable-next-line strict\n/* harmony default export */ const helpers_null = (null);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/toFormData.js\n\n\nfunction toFormData_typeof(o) { \"@babel/helpers - typeof\"; return toFormData_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, toFormData_typeof(o); }\n\n\n// temporary hotfix to avoid circular references until AxiosURLSearchParams is refactored\n\n\n/**\n * Determines if the given thing is a array or js object.\n *\n * @param {string} thing - The object or array to be visited.\n *\n * @returns {boolean}\n */\nfunction isVisitable(thing) {\n  return utils.isPlainObject(thing) || utils.isArray(thing);\n}\n\n/**\n * It removes the brackets from the end of a string\n *\n * @param {string} key - The key of the parameter.\n *\n * @returns {string} the key without the brackets.\n */\nfunction removeBrackets(key) {\n  return utils.endsWith(key, '[]') ? key.slice(0, -2) : key;\n}\n\n/**\n * It takes a path, a key, and a boolean, and returns a string\n *\n * @param {string} path - The path to the current key.\n * @param {string} key - The key of the current object being iterated over.\n * @param {string} dots - If true, the key will be rendered with dots instead of brackets.\n *\n * @returns {string} The path to the current key.\n */\nfunction renderKey(path, key, dots) {\n  if (!path) return key;\n  return path.concat(key).map(function each(token, i) {\n    // eslint-disable-next-line no-param-reassign\n    token = removeBrackets(token);\n    return !dots && i ? '[' + token + ']' : token;\n  }).join(dots ? '.' : '');\n}\n\n/**\n * If the array is an array and none of its elements are visitable, then it's a flat array.\n *\n * @param {Array<any>} arr - The array to check\n *\n * @returns {boolean}\n */\nfunction isFlatArray(arr) {\n  return utils.isArray(arr) && !arr.some(isVisitable);\n}\nvar predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {\n  return /^is[A-Z]/.test(prop);\n});\n\n/**\n * Convert a data object to FormData\n *\n * @param {Object} obj\n * @param {?Object} [formData]\n * @param {?Object} [options]\n * @param {Function} [options.visitor]\n * @param {Boolean} [options.metaTokens = true]\n * @param {Boolean} [options.dots = false]\n * @param {?Boolean} [options.indexes = false]\n *\n * @returns {Object}\n **/\n\n/**\n * It converts an object into a FormData object\n *\n * @param {Object<any, any>} obj - The object to convert to form data.\n * @param {string} formData - The FormData object to append to.\n * @param {Object<string, any>} options\n *\n * @returns\n */\nfunction toFormData(obj, formData, options) {\n  if (!utils.isObject(obj)) {\n    throw new TypeError('target must be an object');\n  }\n\n  // eslint-disable-next-line no-param-reassign\n  formData = formData || new (helpers_null || FormData)();\n\n  // eslint-disable-next-line no-param-reassign\n  options = utils.toFlatObject(options, {\n    metaTokens: true,\n    dots: false,\n    indexes: false\n  }, false, function defined(option, source) {\n    // eslint-disable-next-line no-eq-null,eqeqeq\n    return !utils.isUndefined(source[option]);\n  });\n  var metaTokens = options.metaTokens;\n  // eslint-disable-next-line no-use-before-define\n  var visitor = options.visitor || defaultVisitor;\n  var dots = options.dots;\n  var indexes = options.indexes;\n  var _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;\n  var useBlob = _Blob && utils.isSpecCompliantForm(formData);\n  if (!utils.isFunction(visitor)) {\n    throw new TypeError('visitor must be a function');\n  }\n  function convertValue(value) {\n    if (value === null) return '';\n    if (utils.isDate(value)) {\n      return value.toISOString();\n    }\n    if (!useBlob && utils.isBlob(value)) {\n      throw new core_AxiosError('Blob is not supported. Use a Buffer instead.');\n    }\n    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {\n      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);\n    }\n    return value;\n  }\n\n  /**\n   * Default visitor.\n   *\n   * @param {*} value\n   * @param {String|Number} key\n   * @param {Array<String|Number>} path\n   * @this {FormData}\n   *\n   * @returns {boolean} return true to visit the each prop of the value recursively\n   */\n  function defaultVisitor(value, key, path) {\n    var arr = value;\n    if (value && !path && toFormData_typeof(value) === 'object') {\n      if (utils.endsWith(key, '{}')) {\n        // eslint-disable-next-line no-param-reassign\n        key = metaTokens ? key : key.slice(0, -2);\n        // eslint-disable-next-line no-param-reassign\n        value = JSON.stringify(value);\n      } else if (utils.isArray(value) && isFlatArray(value) || (utils.isFileList(value) || utils.endsWith(key, '[]')) && (arr = utils.toArray(value))) {\n        // eslint-disable-next-line no-param-reassign\n        key = removeBrackets(key);\n        arr.forEach(function each(el, index) {\n          !(utils.isUndefined(el) || el === null) && formData.append(\n          // eslint-disable-next-line no-nested-ternary\n          indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + '[]', convertValue(el));\n        });\n        return false;\n      }\n    }\n    if (isVisitable(value)) {\n      return true;\n    }\n    formData.append(renderKey(path, key, dots), convertValue(value));\n    return false;\n  }\n  var stack = [];\n  var exposedHelpers = Object.assign(predicates, {\n    defaultVisitor: defaultVisitor,\n    convertValue: convertValue,\n    isVisitable: isVisitable\n  });\n  function build(value, path) {\n    if (utils.isUndefined(value)) return;\n    if (stack.indexOf(value) !== -1) {\n      throw Error('Circular reference detected in ' + path.join('.'));\n    }\n    stack.push(value);\n    utils.forEach(value, function each(el, key) {\n      var result = !(utils.isUndefined(el) || el === null) && visitor.call(formData, el, utils.isString(key) ? key.trim() : key, path, exposedHelpers);\n      if (result === true) {\n        build(el, path ? path.concat(key) : [key]);\n      }\n    });\n    stack.pop();\n  }\n  if (!utils.isObject(obj)) {\n    throw new TypeError('data must be an object');\n  }\n  build(obj);\n  return formData;\n}\n/* harmony default export */ const helpers_toFormData = (toFormData);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/AxiosURLSearchParams.js\n\n\n\n\n/**\n * It encodes a string by replacing all characters that are not in the unreserved set with\n * their percent-encoded equivalents\n *\n * @param {string} str - The string to encode.\n *\n * @returns {string} The encoded string.\n */\nfunction encode(str) {\n  var charMap = {\n    '!': '%21',\n    \"'\": '%27',\n    '(': '%28',\n    ')': '%29',\n    '~': '%7E',\n    '%20': '+',\n    '%00': '\\x00'\n  };\n  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {\n    return charMap[match];\n  });\n}\n\n/**\n * It takes a params object and converts it to a FormData object\n *\n * @param {Object<string, any>} params - The parameters to be converted to a FormData object.\n * @param {Object<string, any>} options - The options object passed to the Axios constructor.\n *\n * @returns {void}\n */\nfunction AxiosURLSearchParams(params, options) {\n  this._pairs = [];\n  params && helpers_toFormData(params, this, options);\n}\nvar AxiosURLSearchParams_prototype = AxiosURLSearchParams.prototype;\nAxiosURLSearchParams_prototype.append = function append(name, value) {\n  this._pairs.push([name, value]);\n};\nAxiosURLSearchParams_prototype.toString = function toString(encoder) {\n  var _encode = encoder ? function (value) {\n    return encoder.call(this, value, encode);\n  } : encode;\n  return this._pairs.map(function each(pair) {\n    return _encode(pair[0]) + '=' + _encode(pair[1]);\n  }, '').join('&');\n};\n/* harmony default export */ const helpers_AxiosURLSearchParams = (AxiosURLSearchParams);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/buildURL.js\n\n\n\n\n\n/**\n * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their\n * URI encoded counterparts\n *\n * @param {string} val The value to be encoded.\n *\n * @returns {string} The encoded value.\n */\nfunction buildURL_encode(val) {\n  return encodeURIComponent(val).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @param {?object} options\n *\n * @returns {string} The formatted url\n */\nfunction buildURL(url, params, options) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n  var _encode = options && options.encode || buildURL_encode;\n  var serializeFn = options && options.serialize;\n  var serializedParams;\n  if (serializeFn) {\n    serializedParams = serializeFn(params, options);\n  } else {\n    serializedParams = utils.isURLSearchParams(params) ? params.toString() : new helpers_AxiosURLSearchParams(params, options).toString(_encode);\n  }\n  if (serializedParams) {\n    var hashmarkIndex = url.indexOf(\"#\");\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n  return url;\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/core/InterceptorManager.js\n\n\nfunction InterceptorManager_typeof(o) { \"@babel/helpers - typeof\"; return InterceptorManager_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, InterceptorManager_typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return InterceptorManager_typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (InterceptorManager_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (InterceptorManager_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nvar InterceptorManager = /*#__PURE__*/function () {\n  function InterceptorManager() {\n    _classCallCheck(this, InterceptorManager);\n    this.handlers = [];\n  }\n\n  /**\n   * Add a new interceptor to the stack\n   *\n   * @param {Function} fulfilled The function to handle `then` for a `Promise`\n   * @param {Function} rejected The function to handle `reject` for a `Promise`\n   *\n   * @return {Number} An ID used to remove interceptor later\n   */\n  _createClass(InterceptorManager, [{\n    key: \"use\",\n    value: function use(fulfilled, rejected, options) {\n      this.handlers.push({\n        fulfilled: fulfilled,\n        rejected: rejected,\n        synchronous: options ? options.synchronous : false,\n        runWhen: options ? options.runWhen : null\n      });\n      return this.handlers.length - 1;\n    }\n\n    /**\n     * Remove an interceptor from the stack\n     *\n     * @param {Number} id The ID that was returned by `use`\n     *\n     * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise\n     */\n  }, {\n    key: \"eject\",\n    value: function eject(id) {\n      if (this.handlers[id]) {\n        this.handlers[id] = null;\n      }\n    }\n\n    /**\n     * Clear all interceptors from the stack\n     *\n     * @returns {void}\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      if (this.handlers) {\n        this.handlers = [];\n      }\n    }\n\n    /**\n     * Iterate over all the registered interceptors\n     *\n     * This method is particularly useful for skipping over any\n     * interceptors that may have become `null` calling `eject`.\n     *\n     * @param {Function} fn The function to call for each interceptor\n     *\n     * @returns {void}\n     */\n  }, {\n    key: \"forEach\",\n    value: function forEach(fn) {\n      utils.forEach(this.handlers, function forEachHandler(h) {\n        if (h !== null) {\n          fn(h);\n        }\n      });\n    }\n  }]);\n  return InterceptorManager;\n}();\n/* harmony default export */ const core_InterceptorManager = (InterceptorManager);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/defaults/transitional.js\n\n\n/* harmony default export */ const defaults_transitional = ({\n  silentJSONParsing: true,\n  forcedJSONParsing: true,\n  clarifyTimeoutError: false\n});\n;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/browser/classes/URLSearchParams.js\n\n\n\n/* harmony default export */ const classes_URLSearchParams = (typeof URLSearchParams !== 'undefined' ? URLSearchParams : helpers_AxiosURLSearchParams);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/browser/classes/FormData.js\n\n\n/* harmony default export */ const classes_FormData = (typeof FormData !== 'undefined' ? FormData : null);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/browser/classes/Blob.js\n\n\n/* harmony default export */ const classes_Blob = (typeof Blob !== 'undefined' ? Blob : null);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/browser/index.js\n\n\n\n/* harmony default export */ const browser = ({\n  isBrowser: true,\n  classes: {\n    URLSearchParams: classes_URLSearchParams,\n    FormData: classes_FormData,\n    Blob: classes_Blob\n  },\n  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']\n});\n;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/common/utils.js\nvar hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n *\n * @returns {boolean}\n */\nvar hasStandardBrowserEnv = function (product) {\n  return hasBrowserEnv && ['ReactNative', 'NativeScript', 'NS'].indexOf(product) < 0;\n}(typeof navigator !== 'undefined' && navigator.product);\n\n/**\n * Determine if we're running in a standard browser webWorker environment\n *\n * Although the `isStandardBrowserEnv` method indicates that\n * `allows axios to run in a web worker`, the WebWorker will still be\n * filtered out due to its judgment standard\n * `typeof window !== 'undefined' && typeof document !== 'undefined'`.\n * This leads to a problem when axios post `FormData` in webWorker\n */\nvar hasStandardBrowserWebWorkerEnv = function () {\n  return typeof WorkerGlobalScope !== 'undefined' &&\n  // eslint-disable-next-line no-undef\n  self instanceof WorkerGlobalScope && typeof self.importScripts === 'function';\n}();\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/index.js\nfunction platform_typeof(o) { \"@babel/helpers - typeof\"; return platform_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, platform_typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = platform_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction platform_toPropertyKey(arg) { var key = platform_toPrimitive(arg, \"string\"); return platform_typeof(key) === \"symbol\" ? key : String(key); }\nfunction platform_toPrimitive(input, hint) { if (platform_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (platform_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n/* harmony default export */ const platform = (_objectSpread(_objectSpread({}, common_utils_namespaceObject), browser));\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/toURLEncodedForm.js\n\n\n\n\n\nfunction toURLEncodedForm(data, options) {\n  return helpers_toFormData(data, new platform.classes.URLSearchParams(), Object.assign({\n    visitor: function visitor(value, key, path, helpers) {\n      if (platform.isNode && utils.isBuffer(value)) {\n        this.append(key, value.toString('base64'));\n        return false;\n      }\n      return helpers.defaultVisitor.apply(this, arguments);\n    }\n  }, options));\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/formDataToJSON.js\n\n\n\n\n/**\n * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']\n *\n * @param {string} name - The name of the property to get.\n *\n * @returns An array of strings.\n */\nfunction parsePropPath(name) {\n  // foo[x][y][z]\n  // foo.x.y.z\n  // foo-x-y-z\n  // foo x y z\n  return utils.matchAll(/\\w+|\\[(\\w*)]/g, name).map(function (match) {\n    return match[0] === '[]' ? '' : match[1] || match[0];\n  });\n}\n\n/**\n * Convert an array to an object.\n *\n * @param {Array<any>} arr - The array to convert to an object.\n *\n * @returns An object with the same keys and values as the array.\n */\nfunction arrayToObject(arr) {\n  var obj = {};\n  var keys = Object.keys(arr);\n  var i;\n  var len = keys.length;\n  var key;\n  for (i = 0; i < len; i++) {\n    key = keys[i];\n    obj[key] = arr[key];\n  }\n  return obj;\n}\n\n/**\n * It takes a FormData object and returns a JavaScript object\n *\n * @param {string} formData The FormData object to convert to JSON.\n *\n * @returns {Object<string, any> | null} The converted object.\n */\nfunction formDataToJSON(formData) {\n  function buildPath(path, value, target, index) {\n    var name = path[index++];\n    var isNumericKey = Number.isFinite(+name);\n    var isLast = index >= path.length;\n    name = !name && utils.isArray(target) ? target.length : name;\n    if (isLast) {\n      if (utils.hasOwnProp(target, name)) {\n        target[name] = [target[name], value];\n      } else {\n        target[name] = value;\n      }\n      return !isNumericKey;\n    }\n    if (!target[name] || !utils.isObject(target[name])) {\n      target[name] = [];\n    }\n    var result = buildPath(path, value, target[name], index);\n    if (result && utils.isArray(target[name])) {\n      target[name] = arrayToObject(target[name]);\n    }\n    return !isNumericKey;\n  }\n  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {\n    var obj = {};\n    utils.forEachEntry(formData, function (name, value) {\n      buildPath(parsePropPath(name), value, obj, 0);\n    });\n    return obj;\n  }\n  return null;\n}\n/* harmony default export */ const helpers_formDataToJSON = (formDataToJSON);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/defaults/index.js\n\n\n\n\n\n\n\n\n\n\n/**\n * It takes a string, tries to parse it, and if it fails, it returns the stringified version\n * of the input\n *\n * @param {any} rawValue - The value to be stringified.\n * @param {Function} parser - A function that parses a string into a JavaScript object.\n * @param {Function} encoder - A function that takes a value and returns a string.\n *\n * @returns {string} A stringified version of the rawValue.\n */\nfunction stringifySafely(rawValue, parser, encoder) {\n  if (utils.isString(rawValue)) {\n    try {\n      (parser || JSON.parse)(rawValue);\n      return utils.trim(rawValue);\n    } catch (e) {\n      if (e.name !== 'SyntaxError') {\n        throw e;\n      }\n    }\n  }\n  return (encoder || JSON.stringify)(rawValue);\n}\nvar defaults = {\n  transitional: defaults_transitional,\n  adapter: ['xhr', 'http'],\n  transformRequest: [function transformRequest(data, headers) {\n    var contentType = headers.getContentType() || '';\n    var hasJSONContentType = contentType.indexOf('application/json') > -1;\n    var isObjectPayload = utils.isObject(data);\n    if (isObjectPayload && utils.isHTMLForm(data)) {\n      data = new FormData(data);\n    }\n    var isFormData = utils.isFormData(data);\n    if (isFormData) {\n      if (!hasJSONContentType) {\n        return data;\n      }\n      return hasJSONContentType ? JSON.stringify(helpers_formDataToJSON(data)) : data;\n    }\n    if (utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);\n      return data.toString();\n    }\n    var isFileList;\n    if (isObjectPayload) {\n      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {\n        return toURLEncodedForm(data, this.formSerializer).toString();\n      }\n      if ((isFileList = utils.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {\n        var _FormData = this.env && this.env.FormData;\n        return helpers_toFormData(isFileList ? {\n          'files[]': data\n        } : data, _FormData && new _FormData(), this.formSerializer);\n      }\n    }\n    if (isObjectPayload || hasJSONContentType) {\n      headers.setContentType('application/json', false);\n      return stringifySafely(data);\n    }\n    return data;\n  }],\n  transformResponse: [function transformResponse(data) {\n    var transitional = this.transitional || defaults.transitional;\n    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n    var JSONRequested = this.responseType === 'json';\n    if (data && utils.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {\n      var silentJSONParsing = transitional && transitional.silentJSONParsing;\n      var strictJSONParsing = !silentJSONParsing && JSONRequested;\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        if (strictJSONParsing) {\n          if (e.name === 'SyntaxError') {\n            throw core_AxiosError.from(e, core_AxiosError.ERR_BAD_RESPONSE, this, null, this.response);\n          }\n          throw e;\n        }\n      }\n    }\n    return data;\n  }],\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n  maxContentLength: -1,\n  maxBodyLength: -1,\n  env: {\n    FormData: platform.classes.FormData,\n    Blob: platform.classes.Blob\n  },\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  },\n  headers: {\n    common: {\n      'Accept': 'application/json, text/plain, */*',\n      'Content-Type': undefined\n    }\n  }\n};\nutils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], function (method) {\n  defaults.headers[method] = {};\n});\n/* harmony default export */ const lib_defaults = (defaults);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/parseHeaders.js\n\n\n\n\n// RawAxiosHeaders whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nvar ignoreDuplicateOf = utils.toObjectSet(['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent']);\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} rawHeaders Headers needing to be parsed\n *\n * @returns {Object} Headers parsed into an object\n */\n/* harmony default export */ const parseHeaders = (function (rawHeaders) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n  rawHeaders && rawHeaders.split('\\n').forEach(function parser(line) {\n    i = line.indexOf(':');\n    key = line.substring(0, i).trim().toLowerCase();\n    val = line.substring(i + 1).trim();\n    if (!key || parsed[key] && ignoreDuplicateOf[key]) {\n      return;\n    }\n    if (key === 'set-cookie') {\n      if (parsed[key]) {\n        parsed[key].push(val);\n      } else {\n        parsed[key] = [val];\n      }\n    } else {\n      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n    }\n  });\n  return parsed;\n});\n;// CONCATENATED MODULE: ./node_modules/axios/lib/core/AxiosHeaders.js\n\n\nfunction AxiosHeaders_typeof(o) { \"@babel/helpers - typeof\"; return AxiosHeaders_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, AxiosHeaders_typeof(o); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction AxiosHeaders_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction AxiosHeaders_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, AxiosHeaders_toPropertyKey(descriptor.key), descriptor); } }\nfunction AxiosHeaders_createClass(Constructor, protoProps, staticProps) { if (protoProps) AxiosHeaders_defineProperties(Constructor.prototype, protoProps); if (staticProps) AxiosHeaders_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction AxiosHeaders_toPropertyKey(arg) { var key = AxiosHeaders_toPrimitive(arg, \"string\"); return AxiosHeaders_typeof(key) === \"symbol\" ? key : String(key); }\nfunction AxiosHeaders_toPrimitive(input, hint) { if (AxiosHeaders_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (AxiosHeaders_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\nvar $internals = Symbol('internals');\nfunction normalizeHeader(header) {\n  return header && String(header).trim().toLowerCase();\n}\nfunction normalizeValue(value) {\n  if (value === false || value == null) {\n    return value;\n  }\n  return utils.isArray(value) ? value.map(normalizeValue) : String(value);\n}\nfunction parseTokens(str) {\n  var tokens = Object.create(null);\n  var tokensRE = /([^\\s,;=]+)\\s*(?:=\\s*([^,;]+))?/g;\n  var match;\n  while (match = tokensRE.exec(str)) {\n    tokens[match[1]] = match[2];\n  }\n  return tokens;\n}\nvar isValidHeaderName = function isValidHeaderName(str) {\n  return /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());\n};\nfunction matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {\n  if (utils.isFunction(filter)) {\n    return filter.call(this, value, header);\n  }\n  if (isHeaderNameFilter) {\n    value = header;\n  }\n  if (!utils.isString(value)) return;\n  if (utils.isString(filter)) {\n    return value.indexOf(filter) !== -1;\n  }\n  if (utils.isRegExp(filter)) {\n    return filter.test(value);\n  }\n}\nfunction formatHeader(header) {\n  return header.trim().toLowerCase().replace(/([a-z\\d])(\\w*)/g, function (w, _char, str) {\n    return _char.toUpperCase() + str;\n  });\n}\nfunction buildAccessors(obj, header) {\n  var accessorName = utils.toCamelCase(' ' + header);\n  ['get', 'set', 'has'].forEach(function (methodName) {\n    Object.defineProperty(obj, methodName + accessorName, {\n      value: function value(arg1, arg2, arg3) {\n        return this[methodName].call(this, header, arg1, arg2, arg3);\n      },\n      configurable: true\n    });\n  });\n}\nvar AxiosHeaders = /*#__PURE__*/function (_Symbol$iterator, _Symbol$toStringTag) {\n  function AxiosHeaders(headers) {\n    AxiosHeaders_classCallCheck(this, AxiosHeaders);\n    headers && this.set(headers);\n  }\n  AxiosHeaders_createClass(AxiosHeaders, [{\n    key: \"set\",\n    value: function set(header, valueOrRewrite, rewrite) {\n      var self = this;\n      function setHeader(_value, _header, _rewrite) {\n        var lHeader = normalizeHeader(_header);\n        if (!lHeader) {\n          throw new Error('header name must be a non-empty string');\n        }\n        var key = utils.findKey(self, lHeader);\n        if (!key || self[key] === undefined || _rewrite === true || _rewrite === undefined && self[key] !== false) {\n          self[key || _header] = normalizeValue(_value);\n        }\n      }\n      var setHeaders = function setHeaders(headers, _rewrite) {\n        return utils.forEach(headers, function (_value, _header) {\n          return setHeader(_value, _header, _rewrite);\n        });\n      };\n      if (utils.isPlainObject(header) || header instanceof this.constructor) {\n        setHeaders(header, valueOrRewrite);\n      } else if (utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {\n        setHeaders(parseHeaders(header), valueOrRewrite);\n      } else {\n        header != null && setHeader(valueOrRewrite, header, rewrite);\n      }\n      return this;\n    }\n  }, {\n    key: \"get\",\n    value: function get(header, parser) {\n      header = normalizeHeader(header);\n      if (header) {\n        var key = utils.findKey(this, header);\n        if (key) {\n          var value = this[key];\n          if (!parser) {\n            return value;\n          }\n          if (parser === true) {\n            return parseTokens(value);\n          }\n          if (utils.isFunction(parser)) {\n            return parser.call(this, value, key);\n          }\n          if (utils.isRegExp(parser)) {\n            return parser.exec(value);\n          }\n          throw new TypeError('parser must be boolean|regexp|function');\n        }\n      }\n    }\n  }, {\n    key: \"has\",\n    value: function has(header, matcher) {\n      header = normalizeHeader(header);\n      if (header) {\n        var key = utils.findKey(this, header);\n        return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));\n      }\n      return false;\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(header, matcher) {\n      var self = this;\n      var deleted = false;\n      function deleteHeader(_header) {\n        _header = normalizeHeader(_header);\n        if (_header) {\n          var key = utils.findKey(self, _header);\n          if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {\n            delete self[key];\n            deleted = true;\n          }\n        }\n      }\n      if (utils.isArray(header)) {\n        header.forEach(deleteHeader);\n      } else {\n        deleteHeader(header);\n      }\n      return deleted;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear(matcher) {\n      var keys = Object.keys(this);\n      var i = keys.length;\n      var deleted = false;\n      while (i--) {\n        var key = keys[i];\n        if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {\n          delete this[key];\n          deleted = true;\n        }\n      }\n      return deleted;\n    }\n  }, {\n    key: \"normalize\",\n    value: function normalize(format) {\n      var self = this;\n      var headers = {};\n      utils.forEach(this, function (value, header) {\n        var key = utils.findKey(headers, header);\n        if (key) {\n          self[key] = normalizeValue(value);\n          delete self[header];\n          return;\n        }\n        var normalized = format ? formatHeader(header) : String(header).trim();\n        if (normalized !== header) {\n          delete self[header];\n        }\n        self[normalized] = normalizeValue(value);\n        headers[normalized] = true;\n      });\n      return this;\n    }\n  }, {\n    key: \"concat\",\n    value: function concat() {\n      var _this$constructor;\n      for (var _len = arguments.length, targets = new Array(_len), _key = 0; _key < _len; _key++) {\n        targets[_key] = arguments[_key];\n      }\n      return (_this$constructor = this.constructor).concat.apply(_this$constructor, [this].concat(targets));\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(asStrings) {\n      var obj = Object.create(null);\n      utils.forEach(this, function (value, header) {\n        value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(', ') : value);\n      });\n      return obj;\n    }\n  }, {\n    key: _Symbol$iterator,\n    value: function value() {\n      return Object.entries(this.toJSON())[Symbol.iterator]();\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return Object.entries(this.toJSON()).map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          header = _ref2[0],\n          value = _ref2[1];\n        return header + ': ' + value;\n      }).join('\\n');\n    }\n  }, {\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return 'AxiosHeaders';\n    }\n  }], [{\n    key: \"from\",\n    value: function from(thing) {\n      return thing instanceof this ? thing : new this(thing);\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(first) {\n      var computed = new this(first);\n      for (var _len2 = arguments.length, targets = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        targets[_key2 - 1] = arguments[_key2];\n      }\n      targets.forEach(function (target) {\n        return computed.set(target);\n      });\n      return computed;\n    }\n  }, {\n    key: \"accessor\",\n    value: function accessor(header) {\n      var internals = this[$internals] = this[$internals] = {\n        accessors: {}\n      };\n      var accessors = internals.accessors;\n      var prototype = this.prototype;\n      function defineAccessor(_header) {\n        var lHeader = normalizeHeader(_header);\n        if (!accessors[lHeader]) {\n          buildAccessors(prototype, _header);\n          accessors[lHeader] = true;\n        }\n      }\n      utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);\n      return this;\n    }\n  }]);\n  return AxiosHeaders;\n}(Symbol.iterator, Symbol.toStringTag);\nAxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);\n\n// reserved names hotfix\nutils.reduceDescriptors(AxiosHeaders.prototype, function (_ref3, key) {\n  var value = _ref3.value;\n  var mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`\n  return {\n    get: function get() {\n      return value;\n    },\n    set: function set(headerValue) {\n      this[mapped] = headerValue;\n    }\n  };\n});\nutils.freezeMethods(AxiosHeaders);\n/* harmony default export */ const core_AxiosHeaders = (AxiosHeaders);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/core/transformData.js\n\n\n\n\n\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Array|Function} fns A single function or Array of functions\n * @param {?Object} response The response object\n *\n * @returns {*} The resulting transformed data\n */\nfunction transformData(fns, response) {\n  var config = this || lib_defaults;\n  var context = response || config;\n  var headers = core_AxiosHeaders.from(context.headers);\n  var data = context.data;\n  utils.forEach(fns, function transform(fn) {\n    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);\n  });\n  headers.normalize();\n  return data;\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/cancel/isCancel.js\n\n\nfunction isCancel(value) {\n  return !!(value && value.__CANCEL__);\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/cancel/CanceledError.js\n\n\n\n\n\n/**\n * A `CanceledError` is an object that is thrown when an operation is canceled.\n *\n * @param {string=} message The message.\n * @param {Object=} config The config.\n * @param {Object=} request The request.\n *\n * @returns {CanceledError} The created error.\n */\nfunction CanceledError(message, config, request) {\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  core_AxiosError.call(this, message == null ? 'canceled' : message, core_AxiosError.ERR_CANCELED, config, request);\n  this.name = 'CanceledError';\n}\nutils.inherits(CanceledError, core_AxiosError, {\n  __CANCEL__: true\n});\n/* harmony default export */ const cancel_CanceledError = (CanceledError);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/core/settle.js\n\n\n\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n *\n * @returns {object} The response.\n */\nfunction settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(new core_AxiosError('Request failed with status code ' + response.status, [core_AxiosError.ERR_BAD_REQUEST, core_AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/cookies.js\n\n\n/* harmony default export */ const cookies = (platform.hasStandardBrowserEnv ?\n// Standard browser envs support document.cookie\n{\n  write: function write(name, value, expires, path, domain, secure) {\n    var cookie = [name + '=' + encodeURIComponent(value)];\n    utils.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());\n    utils.isString(path) && cookie.push('path=' + path);\n    utils.isString(domain) && cookie.push('domain=' + domain);\n    secure === true && cookie.push('secure');\n    document.cookie = cookie.join('; ');\n  },\n  read: function read(name) {\n    var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n    return match ? decodeURIComponent(match[3]) : null;\n  },\n  remove: function remove(name) {\n    this.write(name, '', Date.now() - 86400000);\n  }\n} :\n// Non-standard browser env (web workers, react-native) lack needed support.\n{\n  write: function write() {},\n  read: function read() {\n    return null;\n  },\n  remove: function remove() {}\n});\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/isAbsoluteURL.js\n\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n *\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nfunction isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/combineURLs.js\n\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n *\n * @returns {string} The combined URL\n */\nfunction combineURLs(baseURL, relativeURL) {\n  return relativeURL ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '') : baseURL;\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/core/buildFullPath.js\n\n\n\n\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n *\n * @returns {string} The combined full path\n */\nfunction buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/isURLSameOrigin.js\n\n\n\n\n/* harmony default export */ const isURLSameOrigin = (platform.hasStandardBrowserEnv ?\n// Standard browser envs have full support of the APIs needed to test\n// whether the request URL is of the same origin as current location.\nfunction standardBrowserEnv() {\n  var msie = /(msie|trident)/i.test(navigator.userAgent);\n  var urlParsingNode = document.createElement('a');\n  var originURL;\n\n  /**\n  * Parse a URL to discover its components\n  *\n  * @param {String} url The URL to be parsed\n  * @returns {Object}\n  */\n  function resolveURL(url) {\n    var href = url;\n    if (msie) {\n      // IE needs attribute set twice to normalize properties\n      urlParsingNode.setAttribute('href', href);\n      href = urlParsingNode.href;\n    }\n    urlParsingNode.setAttribute('href', href);\n\n    // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n    return {\n      href: urlParsingNode.href,\n      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n      host: urlParsingNode.host,\n      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n      hostname: urlParsingNode.hostname,\n      port: urlParsingNode.port,\n      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname\n    };\n  }\n  originURL = resolveURL(window.location.href);\n\n  /**\n  * Determine if a URL shares the same origin as the current location\n  *\n  * @param {String} requestURL The URL to test\n  * @returns {boolean} True if URL shares the same origin, otherwise false\n  */\n  return function isURLSameOrigin(requestURL) {\n    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;\n    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;\n  };\n}() :\n// Non standard browser envs (web workers, react-native) lack needed support.\nfunction nonStandardBrowserEnv() {\n  return function isURLSameOrigin() {\n    return true;\n  };\n}());\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/parseProtocol.js\n\n\nfunction parseProtocol(url) {\n  var match = /^([-+\\w]{1,25})(:?\\/\\/|:)/.exec(url);\n  return match && match[1] || '';\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/speedometer.js\n\n\n/**\n * Calculate data maxRate\n * @param {Number} [samplesCount= 10]\n * @param {Number} [min= 1000]\n * @returns {Function}\n */\nfunction speedometer(samplesCount, min) {\n  samplesCount = samplesCount || 10;\n  var bytes = new Array(samplesCount);\n  var timestamps = new Array(samplesCount);\n  var head = 0;\n  var tail = 0;\n  var firstSampleTS;\n  min = min !== undefined ? min : 1000;\n  return function push(chunkLength) {\n    var now = Date.now();\n    var startedAt = timestamps[tail];\n    if (!firstSampleTS) {\n      firstSampleTS = now;\n    }\n    bytes[head] = chunkLength;\n    timestamps[head] = now;\n    var i = tail;\n    var bytesCount = 0;\n    while (i !== head) {\n      bytesCount += bytes[i++];\n      i = i % samplesCount;\n    }\n    head = (head + 1) % samplesCount;\n    if (head === tail) {\n      tail = (tail + 1) % samplesCount;\n    }\n    if (now - firstSampleTS < min) {\n      return;\n    }\n    var passed = startedAt && now - startedAt;\n    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;\n  };\n}\n/* harmony default export */ const helpers_speedometer = (speedometer);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/adapters/xhr.js\n\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || xhr_unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return xhr_arrayLikeToArray(arr); }\nfunction _toArray(arr) { return xhr_arrayWithHoles(arr) || _iterableToArray(arr) || xhr_unsupportedIterableToArray(arr) || xhr_nonIterableRest(); }\nfunction xhr_nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction xhr_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return xhr_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return xhr_arrayLikeToArray(o, minLen); }\nfunction xhr_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction xhr_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction progressEventReducer(listener, isDownloadStream) {\n  var bytesNotified = 0;\n  var _speedometer = helpers_speedometer(50, 250);\n  return function (e) {\n    var loaded = e.loaded;\n    var total = e.lengthComputable ? e.total : undefined;\n    var progressBytes = loaded - bytesNotified;\n    var rate = _speedometer(progressBytes);\n    var inRange = loaded <= total;\n    bytesNotified = loaded;\n    var data = {\n      loaded: loaded,\n      total: total,\n      progress: total ? loaded / total : undefined,\n      bytes: progressBytes,\n      rate: rate ? rate : undefined,\n      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,\n      event: e\n    };\n    data[isDownloadStream ? 'download' : 'upload'] = true;\n    listener(data);\n  };\n}\nvar isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';\n/* harmony default export */ const xhr = (isXHRAdapterSupported && function (config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = core_AxiosHeaders.from(config.headers).normalize();\n    var responseType = config.responseType,\n      withXSRFToken = config.withXSRFToken;\n    var onCanceled;\n    function done() {\n      if (config.cancelToken) {\n        config.cancelToken.unsubscribe(onCanceled);\n      }\n      if (config.signal) {\n        config.signal.removeEventListener('abort', onCanceled);\n      }\n    }\n    var contentType;\n    if (utils.isFormData(requestData)) {\n      if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {\n        requestHeaders.setContentType(false); // Let the browser set it\n      } else if ((contentType = requestHeaders.getContentType()) !== false) {\n        // fix semicolon duplication issue for ReactNative FormData implementation\n        var _ref = contentType ? contentType.split(';').map(function (token) {\n            return token.trim();\n          }).filter(Boolean) : [],\n          _ref2 = _toArray(_ref),\n          type = _ref2[0],\n          tokens = _ref2.slice(1);\n        requestHeaders.setContentType([type || 'multipart/form-data'].concat(_toConsumableArray(tokens)).join('; '));\n      }\n    }\n    var request = new XMLHttpRequest();\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';\n      requestHeaders.set('Authorization', 'Basic ' + btoa(username + ':' + password));\n    }\n    var fullPath = buildFullPath(config.baseURL, config.url);\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n    function onloadend() {\n      if (!request) {\n        return;\n      }\n      // Prepare the response\n      var responseHeaders = core_AxiosHeaders.from('getAllResponseHeaders' in request && request.getAllResponseHeaders());\n      var responseData = !responseType || responseType === 'text' || responseType === 'json' ? request.responseText : request.response;\n      var response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n      settle(function _resolve(value) {\n        resolve(value);\n        done();\n      }, function _reject(err) {\n        reject(err);\n        done();\n      }, response);\n\n      // Clean up request\n      request = null;\n    }\n    if ('onloadend' in request) {\n      // Use onloadend if available\n      request.onloadend = onloadend;\n    } else {\n      // Listen for ready state to emulate onloadend\n      request.onreadystatechange = function handleLoad() {\n        if (!request || request.readyState !== 4) {\n          return;\n        }\n\n        // The request errored out and we didn't get a response, this will be\n        // handled by onerror instead\n        // With one exception: request that using file: protocol, most browsers\n        // will return status as 0 even though it's a successful request\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n          return;\n        }\n        // readystate handler is calling before onerror or ontimeout handlers,\n        // so we should call onloadend on the next 'tick'\n        setTimeout(onloadend);\n      };\n    }\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n      reject(new core_AxiosError('Request aborted', core_AxiosError.ECONNABORTED, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(new core_AxiosError('Network Error', core_AxiosError.ERR_NETWORK, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';\n      var transitional = config.transitional || defaults_transitional;\n      if (config.timeoutErrorMessage) {\n        timeoutErrorMessage = config.timeoutErrorMessage;\n      }\n      reject(new core_AxiosError(timeoutErrorMessage, transitional.clarifyTimeoutError ? core_AxiosError.ETIMEDOUT : core_AxiosError.ECONNABORTED, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (platform.hasStandardBrowserEnv) {\n      withXSRFToken && utils.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));\n      if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(fullPath)) {\n        // Add xsrf header\n        var xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies.read(config.xsrfCookieName);\n        if (xsrfValue) {\n          requestHeaders.set(config.xsrfHeaderName, xsrfValue);\n        }\n      }\n    }\n\n    // Remove Content-Type if data is undefined\n    requestData === undefined && requestHeaders.setContentType(null);\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {\n        request.setRequestHeader(key, val);\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (responseType && responseType !== 'json') {\n      request.responseType = config.responseType;\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', progressEventReducer(config.onDownloadProgress, true));\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', progressEventReducer(config.onUploadProgress));\n    }\n    if (config.cancelToken || config.signal) {\n      // Handle cancellation\n      // eslint-disable-next-line func-names\n      onCanceled = function onCanceled(cancel) {\n        if (!request) {\n          return;\n        }\n        reject(!cancel || cancel.type ? new cancel_CanceledError(null, config, request) : cancel);\n        request.abort();\n        request = null;\n      };\n      config.cancelToken && config.cancelToken.subscribe(onCanceled);\n      if (config.signal) {\n        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);\n      }\n    }\n    var protocol = parseProtocol(fullPath);\n    if (protocol && platform.protocols.indexOf(protocol) === -1) {\n      reject(new core_AxiosError('Unsupported protocol ' + protocol + ':', core_AxiosError.ERR_BAD_REQUEST, config));\n      return;\n    }\n\n    // Send the request\n    request.send(requestData || null);\n  });\n});\n;// CONCATENATED MODULE: ./node_modules/axios/lib/adapters/adapters.js\nfunction adapters_slicedToArray(arr, i) { return adapters_arrayWithHoles(arr) || adapters_iterableToArrayLimit(arr, i) || adapters_unsupportedIterableToArray(arr, i) || adapters_nonIterableRest(); }\nfunction adapters_nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction adapters_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return adapters_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return adapters_arrayLikeToArray(o, minLen); }\nfunction adapters_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction adapters_iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction adapters_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\nvar knownAdapters = {\n  http: helpers_null,\n  xhr: xhr\n};\nutils.forEach(knownAdapters, function (fn, value) {\n  if (fn) {\n    try {\n      Object.defineProperty(fn, 'name', {\n        value: value\n      });\n    } catch (e) {\n      // eslint-disable-next-line no-empty\n    }\n    Object.defineProperty(fn, 'adapterName', {\n      value: value\n    });\n  }\n});\nvar renderReason = function renderReason(reason) {\n  return \"- \".concat(reason);\n};\nvar isResolvedHandle = function isResolvedHandle(adapter) {\n  return utils.isFunction(adapter) || adapter === null || adapter === false;\n};\n/* harmony default export */ const adapters = ({\n  getAdapter: function getAdapter(adapters) {\n    adapters = utils.isArray(adapters) ? adapters : [adapters];\n    var _adapters = adapters,\n      length = _adapters.length;\n    var nameOrAdapter;\n    var adapter;\n    var rejectedReasons = {};\n    for (var i = 0; i < length; i++) {\n      nameOrAdapter = adapters[i];\n      var id = void 0;\n      adapter = nameOrAdapter;\n      if (!isResolvedHandle(nameOrAdapter)) {\n        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];\n        if (adapter === undefined) {\n          throw new core_AxiosError(\"Unknown adapter '\".concat(id, \"'\"));\n        }\n      }\n      if (adapter) {\n        break;\n      }\n      rejectedReasons[id || '#' + i] = adapter;\n    }\n    if (!adapter) {\n      var reasons = Object.entries(rejectedReasons).map(function (_ref) {\n        var _ref2 = adapters_slicedToArray(_ref, 2),\n          id = _ref2[0],\n          state = _ref2[1];\n        return \"adapter \".concat(id, \" \") + (state === false ? 'is not supported by the environment' : 'is not available in the build');\n      });\n      var s = length ? reasons.length > 1 ? 'since :\\n' + reasons.map(renderReason).join('\\n') : ' ' + renderReason(reasons[0]) : 'as no adapter specified';\n      throw new core_AxiosError(\"There is no suitable adapter to dispatch the request \" + s, 'ERR_NOT_SUPPORT');\n    }\n    return adapter;\n  },\n  adapters: knownAdapters\n});\n;// CONCATENATED MODULE: ./node_modules/axios/lib/core/dispatchRequest.js\n\n\n\n\n\n\n\n\n\n/**\n * Throws a `CanceledError` if cancellation has been requested.\n *\n * @param {Object} config The config that is to be used for the request\n *\n * @returns {void}\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n  if (config.signal && config.signal.aborted) {\n    throw new cancel_CanceledError(null, config);\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n *\n * @returns {Promise} The Promise to be fulfilled\n */\nfunction dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n  config.headers = core_AxiosHeaders.from(config.headers);\n\n  // Transform request data\n  config.data = transformData.call(config, config.transformRequest);\n  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {\n    config.headers.setContentType('application/x-www-form-urlencoded', false);\n  }\n  var adapter = adapters.getAdapter(config.adapter || lib_defaults.adapter);\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData.call(config, config.transformResponse, response);\n    response.headers = core_AxiosHeaders.from(response.headers);\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData.call(config, config.transformResponse, reason.response);\n        reason.response.headers = core_AxiosHeaders.from(reason.response.headers);\n      }\n    }\n    return Promise.reject(reason);\n  });\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/core/mergeConfig.js\n\n\n\n\nvar headersToObject = function headersToObject(thing) {\n  return thing instanceof core_AxiosHeaders ? thing.toJSON() : thing;\n};\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n *\n * @returns {Object} New object resulting from merging config2 to config1\n */\nfunction mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  var config = {};\n  function getMergedValue(target, source, caseless) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge.call({\n        caseless: caseless\n      }, target, source);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDeepProperties(a, b, caseless) {\n    if (!utils.isUndefined(b)) {\n      return getMergedValue(a, b, caseless);\n    } else if (!utils.isUndefined(a)) {\n      return getMergedValue(undefined, a, caseless);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function valueFromConfig2(a, b) {\n    if (!utils.isUndefined(b)) {\n      return getMergedValue(undefined, b);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function defaultToConfig2(a, b) {\n    if (!utils.isUndefined(b)) {\n      return getMergedValue(undefined, b);\n    } else if (!utils.isUndefined(a)) {\n      return getMergedValue(undefined, a);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDirectKeys(a, b, prop) {\n    if (prop in config2) {\n      return getMergedValue(a, b);\n    } else if (prop in config1) {\n      return getMergedValue(undefined, a);\n    }\n  }\n  var mergeMap = {\n    url: valueFromConfig2,\n    method: valueFromConfig2,\n    data: valueFromConfig2,\n    baseURL: defaultToConfig2,\n    transformRequest: defaultToConfig2,\n    transformResponse: defaultToConfig2,\n    paramsSerializer: defaultToConfig2,\n    timeout: defaultToConfig2,\n    timeoutMessage: defaultToConfig2,\n    withCredentials: defaultToConfig2,\n    withXSRFToken: defaultToConfig2,\n    adapter: defaultToConfig2,\n    responseType: defaultToConfig2,\n    xsrfCookieName: defaultToConfig2,\n    xsrfHeaderName: defaultToConfig2,\n    onUploadProgress: defaultToConfig2,\n    onDownloadProgress: defaultToConfig2,\n    decompress: defaultToConfig2,\n    maxContentLength: defaultToConfig2,\n    maxBodyLength: defaultToConfig2,\n    beforeRedirect: defaultToConfig2,\n    transport: defaultToConfig2,\n    httpAgent: defaultToConfig2,\n    httpsAgent: defaultToConfig2,\n    cancelToken: defaultToConfig2,\n    socketPath: defaultToConfig2,\n    responseEncoding: defaultToConfig2,\n    validateStatus: mergeDirectKeys,\n    headers: function headers(a, b) {\n      return mergeDeepProperties(headersToObject(a), headersToObject(b), true);\n    }\n  };\n  utils.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {\n    var merge = mergeMap[prop] || mergeDeepProperties;\n    var configValue = merge(config1[prop], config2[prop], prop);\n    utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);\n  });\n  return config;\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/env/data.js\nvar VERSION = \"1.6.2\";\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/validator.js\n\n\nfunction validator_typeof(o) { \"@babel/helpers - typeof\"; return validator_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, validator_typeof(o); }\n\n\nvar validators = {};\n\n// eslint-disable-next-line func-names\n['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function (type, i) {\n  validators[type] = function validator(thing) {\n    return validator_typeof(thing) === type || 'a' + (i < 1 ? 'n ' : ' ') + type;\n  };\n});\nvar deprecatedWarnings = {};\n\n/**\n * Transitional option validator\n *\n * @param {function|boolean?} validator - set to false if the transitional option has been removed\n * @param {string?} version - deprecated version / removed since version\n * @param {string?} message - some message with additional info\n *\n * @returns {function}\n */\nvalidators.transitional = function transitional(validator, version, message) {\n  function formatMessage(opt, desc) {\n    return '[Axios v' + VERSION + '] Transitional option \\'' + opt + '\\'' + desc + (message ? '. ' + message : '');\n  }\n\n  // eslint-disable-next-line func-names\n  return function (value, opt, opts) {\n    if (validator === false) {\n      throw new core_AxiosError(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')), core_AxiosError.ERR_DEPRECATED);\n    }\n    if (version && !deprecatedWarnings[opt]) {\n      deprecatedWarnings[opt] = true;\n      // eslint-disable-next-line no-console\n      console.warn(formatMessage(opt, ' has been deprecated since v' + version + ' and will be removed in the near future'));\n    }\n    return validator ? validator(value, opt, opts) : true;\n  };\n};\n\n/**\n * Assert object's properties type\n *\n * @param {object} options\n * @param {object} schema\n * @param {boolean?} allowUnknown\n *\n * @returns {object}\n */\n\nfunction assertOptions(options, schema, allowUnknown) {\n  if (validator_typeof(options) !== 'object') {\n    throw new core_AxiosError('options must be an object', core_AxiosError.ERR_BAD_OPTION_VALUE);\n  }\n  var keys = Object.keys(options);\n  var i = keys.length;\n  while (i-- > 0) {\n    var opt = keys[i];\n    var validator = schema[opt];\n    if (validator) {\n      var value = options[opt];\n      var result = value === undefined || validator(value, opt, options);\n      if (result !== true) {\n        throw new core_AxiosError('option ' + opt + ' must be ' + result, core_AxiosError.ERR_BAD_OPTION_VALUE);\n      }\n      continue;\n    }\n    if (allowUnknown !== true) {\n      throw new core_AxiosError('Unknown option ' + opt, core_AxiosError.ERR_BAD_OPTION);\n    }\n  }\n}\n/* harmony default export */ const validator = ({\n  assertOptions: assertOptions,\n  validators: validators\n});\n;// CONCATENATED MODULE: ./node_modules/axios/lib/core/Axios.js\n\n\nfunction Axios_typeof(o) { \"@babel/helpers - typeof\"; return Axios_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, Axios_typeof(o); }\nfunction Axios_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction Axios_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, Axios_toPropertyKey(descriptor.key), descriptor); } }\nfunction Axios_createClass(Constructor, protoProps, staticProps) { if (protoProps) Axios_defineProperties(Constructor.prototype, protoProps); if (staticProps) Axios_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction Axios_toPropertyKey(arg) { var key = Axios_toPrimitive(arg, \"string\"); return Axios_typeof(key) === \"symbol\" ? key : String(key); }\nfunction Axios_toPrimitive(input, hint) { if (Axios_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (Axios_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n\n\n\n\n\n\nvar Axios_validators = validator.validators;\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n *\n * @return {Axios} A new instance of Axios\n */\nvar Axios = /*#__PURE__*/function () {\n  function Axios(instanceConfig) {\n    Axios_classCallCheck(this, Axios);\n    this.defaults = instanceConfig;\n    this.interceptors = {\n      request: new core_InterceptorManager(),\n      response: new core_InterceptorManager()\n    };\n  }\n\n  /**\n   * Dispatch a request\n   *\n   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)\n   * @param {?Object} config\n   *\n   * @returns {Promise} The Promise to be fulfilled\n   */\n  Axios_createClass(Axios, [{\n    key: \"request\",\n    value: function request(configOrUrl, config) {\n      /*eslint no-param-reassign:0*/\n      // Allow for axios('example/url'[, config]) a la fetch API\n      if (typeof configOrUrl === 'string') {\n        config = config || {};\n        config.url = configOrUrl;\n      } else {\n        config = configOrUrl || {};\n      }\n      config = mergeConfig(this.defaults, config);\n      var _config = config,\n        transitional = _config.transitional,\n        paramsSerializer = _config.paramsSerializer,\n        headers = _config.headers;\n      if (transitional !== undefined) {\n        validator.assertOptions(transitional, {\n          silentJSONParsing: Axios_validators.transitional(Axios_validators[\"boolean\"]),\n          forcedJSONParsing: Axios_validators.transitional(Axios_validators[\"boolean\"]),\n          clarifyTimeoutError: Axios_validators.transitional(Axios_validators[\"boolean\"])\n        }, false);\n      }\n      if (paramsSerializer != null) {\n        if (utils.isFunction(paramsSerializer)) {\n          config.paramsSerializer = {\n            serialize: paramsSerializer\n          };\n        } else {\n          validator.assertOptions(paramsSerializer, {\n            encode: Axios_validators[\"function\"],\n            serialize: Axios_validators[\"function\"]\n          }, true);\n        }\n      }\n\n      // Set config.method\n      config.method = (config.method || this.defaults.method || 'get').toLowerCase();\n\n      // Flatten headers\n      var contextHeaders = headers && utils.merge(headers.common, headers[config.method]);\n      headers && utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function (method) {\n        delete headers[method];\n      });\n      config.headers = core_AxiosHeaders.concat(contextHeaders, headers);\n\n      // filter out skipped interceptors\n      var requestInterceptorChain = [];\n      var synchronousRequestInterceptors = true;\n      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n        if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {\n          return;\n        }\n        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n      });\n      var responseInterceptorChain = [];\n      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n      });\n      var promise;\n      var i = 0;\n      var len;\n      if (!synchronousRequestInterceptors) {\n        var chain = [dispatchRequest.bind(this), undefined];\n        chain.unshift.apply(chain, requestInterceptorChain);\n        chain.push.apply(chain, responseInterceptorChain);\n        len = chain.length;\n        promise = Promise.resolve(config);\n        while (i < len) {\n          promise = promise.then(chain[i++], chain[i++]);\n        }\n        return promise;\n      }\n      len = requestInterceptorChain.length;\n      var newConfig = config;\n      i = 0;\n      while (i < len) {\n        var onFulfilled = requestInterceptorChain[i++];\n        var onRejected = requestInterceptorChain[i++];\n        try {\n          newConfig = onFulfilled(newConfig);\n        } catch (error) {\n          onRejected.call(this, error);\n          break;\n        }\n      }\n      try {\n        promise = dispatchRequest.call(this, newConfig);\n      } catch (error) {\n        return Promise.reject(error);\n      }\n      i = 0;\n      len = responseInterceptorChain.length;\n      while (i < len) {\n        promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);\n      }\n      return promise;\n    }\n  }, {\n    key: \"getUri\",\n    value: function getUri(config) {\n      config = mergeConfig(this.defaults, config);\n      var fullPath = buildFullPath(config.baseURL, config.url);\n      return buildURL(fullPath, config.params, config.paramsSerializer);\n    }\n  }]);\n  return Axios;\n}(); // Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function (url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: (config || {}).data\n    }));\n  };\n});\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n\n  function generateHTTPMethod(isForm) {\n    return function httpMethod(url, data, config) {\n      return this.request(mergeConfig(config || {}, {\n        method: method,\n        headers: isForm ? {\n          'Content-Type': 'multipart/form-data'\n        } : {},\n        url: url,\n        data: data\n      }));\n    };\n  }\n  Axios.prototype[method] = generateHTTPMethod();\n  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);\n});\n/* harmony default export */ const core_Axios = (Axios);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/cancel/CancelToken.js\n\n\nfunction CancelToken_typeof(o) { \"@babel/helpers - typeof\"; return CancelToken_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, CancelToken_typeof(o); }\nfunction CancelToken_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction CancelToken_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, CancelToken_toPropertyKey(descriptor.key), descriptor); } }\nfunction CancelToken_createClass(Constructor, protoProps, staticProps) { if (protoProps) CancelToken_defineProperties(Constructor.prototype, protoProps); if (staticProps) CancelToken_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction CancelToken_toPropertyKey(arg) { var key = CancelToken_toPrimitive(arg, \"string\"); return CancelToken_typeof(key) === \"symbol\" ? key : String(key); }\nfunction CancelToken_toPrimitive(input, hint) { if (CancelToken_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (CancelToken_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @param {Function} executor The executor function.\n *\n * @returns {CancelToken}\n */\nvar CancelToken = /*#__PURE__*/function () {\n  function CancelToken(executor) {\n    CancelToken_classCallCheck(this, CancelToken);\n    if (typeof executor !== 'function') {\n      throw new TypeError('executor must be a function.');\n    }\n    var resolvePromise;\n    this.promise = new Promise(function promiseExecutor(resolve) {\n      resolvePromise = resolve;\n    });\n    var token = this;\n\n    // eslint-disable-next-line func-names\n    this.promise.then(function (cancel) {\n      if (!token._listeners) return;\n      var i = token._listeners.length;\n      while (i-- > 0) {\n        token._listeners[i](cancel);\n      }\n      token._listeners = null;\n    });\n\n    // eslint-disable-next-line func-names\n    this.promise.then = function (onfulfilled) {\n      var _resolve;\n      // eslint-disable-next-line func-names\n      var promise = new Promise(function (resolve) {\n        token.subscribe(resolve);\n        _resolve = resolve;\n      }).then(onfulfilled);\n      promise.cancel = function reject() {\n        token.unsubscribe(_resolve);\n      };\n      return promise;\n    };\n    executor(function cancel(message, config, request) {\n      if (token.reason) {\n        // Cancellation has already been requested\n        return;\n      }\n      token.reason = new cancel_CanceledError(message, config, request);\n      resolvePromise(token.reason);\n    });\n  }\n\n  /**\n   * Throws a `CanceledError` if cancellation has been requested.\n   */\n  CancelToken_createClass(CancelToken, [{\n    key: \"throwIfRequested\",\n    value: function throwIfRequested() {\n      if (this.reason) {\n        throw this.reason;\n      }\n    }\n\n    /**\n     * Subscribe to the cancel signal\n     */\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(listener) {\n      if (this.reason) {\n        listener(this.reason);\n        return;\n      }\n      if (this._listeners) {\n        this._listeners.push(listener);\n      } else {\n        this._listeners = [listener];\n      }\n    }\n\n    /**\n     * Unsubscribe from the cancel signal\n     */\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(listener) {\n      if (!this._listeners) {\n        return;\n      }\n      var index = this._listeners.indexOf(listener);\n      if (index !== -1) {\n        this._listeners.splice(index, 1);\n      }\n    }\n\n    /**\n     * Returns an object that contains a new `CancelToken` and a function that, when called,\n     * cancels the `CancelToken`.\n     */\n  }], [{\n    key: \"source\",\n    value: function source() {\n      var cancel;\n      var token = new CancelToken(function executor(c) {\n        cancel = c;\n      });\n      return {\n        token: token,\n        cancel: cancel\n      };\n    }\n  }]);\n  return CancelToken;\n}();\n/* harmony default export */ const cancel_CancelToken = (CancelToken);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/spread.js\n\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n *\n * @returns {Function}\n */\nfunction spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/isAxiosError.js\n\n\n\n\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n *\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nfunction isAxiosError(payload) {\n  return utils.isObject(payload) && payload.isAxiosError === true;\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/HttpStatusCode.js\nfunction HttpStatusCode_slicedToArray(arr, i) { return HttpStatusCode_arrayWithHoles(arr) || HttpStatusCode_iterableToArrayLimit(arr, i) || HttpStatusCode_unsupportedIterableToArray(arr, i) || HttpStatusCode_nonIterableRest(); }\nfunction HttpStatusCode_nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction HttpStatusCode_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return HttpStatusCode_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return HttpStatusCode_arrayLikeToArray(o, minLen); }\nfunction HttpStatusCode_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction HttpStatusCode_iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction HttpStatusCode_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar HttpStatusCode = {\n  Continue: 100,\n  SwitchingProtocols: 101,\n  Processing: 102,\n  EarlyHints: 103,\n  Ok: 200,\n  Created: 201,\n  Accepted: 202,\n  NonAuthoritativeInformation: 203,\n  NoContent: 204,\n  ResetContent: 205,\n  PartialContent: 206,\n  MultiStatus: 207,\n  AlreadyReported: 208,\n  ImUsed: 226,\n  MultipleChoices: 300,\n  MovedPermanently: 301,\n  Found: 302,\n  SeeOther: 303,\n  NotModified: 304,\n  UseProxy: 305,\n  Unused: 306,\n  TemporaryRedirect: 307,\n  PermanentRedirect: 308,\n  BadRequest: 400,\n  Unauthorized: 401,\n  PaymentRequired: 402,\n  Forbidden: 403,\n  NotFound: 404,\n  MethodNotAllowed: 405,\n  NotAcceptable: 406,\n  ProxyAuthenticationRequired: 407,\n  RequestTimeout: 408,\n  Conflict: 409,\n  Gone: 410,\n  LengthRequired: 411,\n  PreconditionFailed: 412,\n  PayloadTooLarge: 413,\n  UriTooLong: 414,\n  UnsupportedMediaType: 415,\n  RangeNotSatisfiable: 416,\n  ExpectationFailed: 417,\n  ImATeapot: 418,\n  MisdirectedRequest: 421,\n  UnprocessableEntity: 422,\n  Locked: 423,\n  FailedDependency: 424,\n  TooEarly: 425,\n  UpgradeRequired: 426,\n  PreconditionRequired: 428,\n  TooManyRequests: 429,\n  RequestHeaderFieldsTooLarge: 431,\n  UnavailableForLegalReasons: 451,\n  InternalServerError: 500,\n  NotImplemented: 501,\n  BadGateway: 502,\n  ServiceUnavailable: 503,\n  GatewayTimeout: 504,\n  HttpVersionNotSupported: 505,\n  VariantAlsoNegotiates: 506,\n  InsufficientStorage: 507,\n  LoopDetected: 508,\n  NotExtended: 510,\n  NetworkAuthenticationRequired: 511\n};\nObject.entries(HttpStatusCode).forEach(function (_ref) {\n  var _ref2 = HttpStatusCode_slicedToArray(_ref, 2),\n    key = _ref2[0],\n    value = _ref2[1];\n  HttpStatusCode[value] = key;\n});\n/* harmony default export */ const helpers_HttpStatusCode = (HttpStatusCode);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/axios.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n *\n * @returns {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new core_Axios(defaultConfig);\n  var instance = bind(core_Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, core_Axios.prototype, context, {\n    allOwnKeys: true\n  });\n\n  // Copy context to instance\n  utils.extend(instance, context, null, {\n    allOwnKeys: true\n  });\n\n  // Factory for creating new instances\n  instance.create = function create(instanceConfig) {\n    return createInstance(mergeConfig(defaultConfig, instanceConfig));\n  };\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(lib_defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = core_Axios;\n\n// Expose Cancel & CancelToken\naxios.CanceledError = cancel_CanceledError;\naxios.CancelToken = cancel_CancelToken;\naxios.isCancel = isCancel;\naxios.VERSION = VERSION;\naxios.toFormData = helpers_toFormData;\n\n// Expose AxiosError class\naxios.AxiosError = core_AxiosError;\n\n// alias for CanceledError for backward compatibility\naxios.Cancel = axios.CanceledError;\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = spread;\n\n// Expose isAxiosError\naxios.isAxiosError = isAxiosError;\n\n// Expose mergeConfig\naxios.mergeConfig = mergeConfig;\naxios.AxiosHeaders = core_AxiosHeaders;\naxios.formToJSON = function (thing) {\n  return helpers_formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);\n};\naxios.getAdapter = adapters.getAdapter;\naxios.HttpStatusCode = helpers_HttpStatusCode;\naxios[\"default\"] = axios;\n\n// this module should only have a default export\n/* harmony default export */ const lib_axios = (axios);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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S0FBSyxDQUFDLEdBQUdBLEtBQUssQ0FBQztBQUFBO0FBRWpHMHJCLEtBQUssQ0FBQ3hKLFVBQVUsR0FBR0MsUUFBUSxDQUFDRCxVQUFVO0FBRXRDd0osS0FBSyxDQUFDbEUsY0FBYyxHQUFHQSxzQkFBYztBQUVyQ2tFLEtBQUssV0FBUSxHQUFHQSxLQUFLOztBQUVyQjtBQUNBLGdEQUFlQSxLQUFLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVpbC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9iaW5kLmpzPzFkMmIiLCJ3ZWJwYWNrOi8vcXVpbC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanM/YzUzMiIsIndlYnBhY2s6Ly9xdWlsLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zRXJyb3IuanM/NzkxNyIsIndlYnBhY2s6Ly9xdWlsLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL251bGwuanM/NDU4MSIsIndlYnBhY2s6Ly9xdWlsLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3RvRm9ybURhdGEuanM/ZTQ2NyIsIndlYnBhY2s6Ly9xdWlsLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL0F4aW9zVVJMU2VhcmNoUGFyYW1zLmpzP2I5MjIiLCJ3ZWJwYWNrOi8vcXVpbC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9idWlsZFVSTC5qcz8zMGI1Iiwid2VicGFjazovL3F1aWwvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzP2Y2YjQiLCJ3ZWJwYWNrOi8vcXVpbC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvZGVmYXVsdHMvdHJhbnNpdGlvbmFsLmpzP2NhZmEiLCJ3ZWJwYWNrOi8vcXVpbC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvcGxhdGZvcm0vYnJvd3Nlci9jbGFzc2VzL1VSTFNlYXJjaFBhcmFtcy5qcz8yYWY2Iiwid2VicGFjazovL3F1aWwvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3BsYXRmb3JtL2Jyb3dzZXIvY2xhc3Nlcy9Gb3JtRGF0YS5qcz84MzI0Iiwid2VicGFjazovL3F1aWwvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3BsYXRmb3JtL2Jyb3dzZXIvY2xhc3Nlcy9CbG9iLmpzP2QyMTUiLCJ3ZWJwYWNrOi8vcXVpbC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvcGxhdGZvcm0vYnJvd3Nlci9pbmRleC5qcz9mM2JkIiwid2VicGFjazovL3F1aWwvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3BsYXRmb3JtL2NvbW1vbi91dGlscy5qcz9jZTY3Iiwid2VicGFjazovL3F1aWwvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3BsYXRmb3JtL2luZGV4LmpzPzRlZDQiLCJ3ZWJwYWNrOi8vcXVpbC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy90b1VSTEVuY29kZWRGb3JtLmpzP2U0MGMiLCJ3ZWJwYWNrOi8vcXVpbC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9mb3JtRGF0YVRvSlNPTi5qcz8wN2Y0Iiwid2VicGFjazovL3F1aWwvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzL2luZGV4LmpzPzRjM2QiLCJ3ZWJwYWNrOi8vcXVpbC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanM/YzM0NSIsIndlYnBhY2s6Ly9xdWlsLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zSGVhZGVycy5qcz9lZGQ1Iiwid2VicGFjazovL3F1aWwvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qcz9jNDAxIiwid2VicGFjazovL3F1aWwvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9pc0NhbmNlbC5qcz8yZTY3Iiwid2VicGFjazovL3F1aWwvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxlZEVycm9yLmpzP2ZiNjAiLCJ3ZWJwYWNrOi8vcXVpbC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9zZXR0bGUuanM/NDY3ZiIsIndlYnBhY2s6Ly9xdWlsLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2Nvb2tpZXMuanM/N2FhYyIsIndlYnBhY2s6Ly9xdWlsLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanM/ZDkyNSIsIndlYnBhY2s6Ly9xdWlsLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2NvbWJpbmVVUkxzLmpzP2U2ODMiLCJ3ZWJwYWNrOi8vcXVpbC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9idWlsZEZ1bGxQYXRoLmpzPzgzYjkiLCJ3ZWJwYWNrOi8vcXVpbC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc1VSTFNhbWVPcmlnaW4uanM/MzkzNCIsIndlYnBhY2s6Ly9xdWlsLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3BhcnNlUHJvdG9jb2wuanM/YjY4YSIsIndlYnBhY2s6Ly9xdWlsLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3NwZWVkb21ldGVyLmpzPzY3YmYiLCJ3ZWJwYWNrOi8vcXVpbC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYWRhcHRlcnMveGhyLmpzP2I1MGQiLCJ3ZWJwYWNrOi8vcXVpbC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYWRhcHRlcnMvYWRhcHRlcnMuanM/M2ExMSIsIndlYnBhY2s6Ly9xdWlsLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2Rpc3BhdGNoUmVxdWVzdC5qcz81MjcwIiwid2VicGFjazovL3F1aWwvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvbWVyZ2VDb25maWcuanM/NGE3YiIsIndlYnBhY2s6Ly9xdWlsLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9lbnYvZGF0YS5qcz81Y2NlIiwid2VicGFjazovL3F1aWwvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvdmFsaWRhdG9yLmpzPzg0OGIiLCJ3ZWJwYWNrOi8vcXVpbC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvcy5qcz8wYTA2Iiwid2VicGFjazovL3F1aWwvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcz84ZGY0Iiwid2VicGFjazovL3F1aWwvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3ByZWFkLmpzPzBkZjYiLCJ3ZWJwYWNrOi8vcXVpbC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0F4aW9zRXJyb3IuanM/NWYwMiIsIndlYnBhY2s6Ly9xdWlsLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL0h0dHBTdGF0dXNDb2RlLmpzP2JlZmEiLCJ3ZWJwYWNrOi8vcXVpbC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYXhpb3MuanM/Y2VlNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50cyk7XG4gIH07XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBiaW5kIGZyb20gJy4vaGVscGVycy9iaW5kLmpzJztcblxuLy8gdXRpbHMgaXMgYSBsaWJyYXJ5IG9mIGdlbmVyaWMgaGVscGVyIGZ1bmN0aW9ucyBub24tc3BlY2lmaWMgdG8gYXhpb3NcblxuY29uc3Qge3RvU3RyaW5nfSA9IE9iamVjdC5wcm90b3R5cGU7XG5jb25zdCB7Z2V0UHJvdG90eXBlT2Z9ID0gT2JqZWN0O1xuXG5jb25zdCBraW5kT2YgPSAoY2FjaGUgPT4gdGhpbmcgPT4ge1xuICAgIGNvbnN0IHN0ciA9IHRvU3RyaW5nLmNhbGwodGhpbmcpO1xuICAgIHJldHVybiBjYWNoZVtzdHJdIHx8IChjYWNoZVtzdHJdID0gc3RyLnNsaWNlKDgsIC0xKS50b0xvd2VyQ2FzZSgpKTtcbn0pKE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXG5jb25zdCBraW5kT2ZUZXN0ID0gKHR5cGUpID0+IHtcbiAgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuICh0aGluZykgPT4ga2luZE9mKHRoaW5nKSA9PT0gdHlwZVxufVxuXG5jb25zdCB0eXBlT2ZUZXN0ID0gdHlwZSA9PiB0aGluZyA9PiB0eXBlb2YgdGhpbmcgPT09IHR5cGU7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCB7aXNBcnJheX0gPSBBcnJheTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc1VuZGVmaW5lZCA9IHR5cGVPZlRlc3QoJ3VuZGVmaW5lZCcpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQnVmZmVyXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwpICYmIHZhbC5jb25zdHJ1Y3RvciAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsLmNvbnN0cnVjdG9yKVxuICAgICYmIGlzRnVuY3Rpb24odmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyKSAmJiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIodmFsKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0FycmF5QnVmZmVyID0ga2luZE9mVGVzdCgnQXJyYXlCdWZmZXInKTtcblxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG4gIGxldCByZXN1bHQ7XG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKGlzQXJyYXlCdWZmZXIodmFsLmJ1ZmZlcikpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJpbmdcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNTdHJpbmcgPSB0eXBlT2ZUZXN0KCdzdHJpbmcnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRnVuY3Rpb24sIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0Z1bmN0aW9uID0gdHlwZU9mVGVzdCgnZnVuY3Rpb24nKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIE51bWJlclxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc051bWJlciA9IHR5cGVPZlRlc3QoJ251bWJlcicpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7Kn0gdGhpbmcgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc09iamVjdCA9ICh0aGluZykgPT4gdGhpbmcgIT09IG51bGwgJiYgdHlwZW9mIHRoaW5nID09PSAnb2JqZWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJvb2xlYW5cbiAqXG4gKiBAcGFyYW0geyp9IHRoaW5nIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJvb2xlYW4sIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0Jvb2xlYW4gPSB0aGluZyA9PiB0aGluZyA9PT0gdHJ1ZSB8fCB0aGluZyA9PT0gZmFsc2U7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNQbGFpbk9iamVjdCA9ICh2YWwpID0+IHtcbiAgaWYgKGtpbmRPZih2YWwpICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKHZhbCk7XG4gIHJldHVybiAocHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG90eXBlKSA9PT0gbnVsbCkgJiYgIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsKSAmJiAhKFN5bWJvbC5pdGVyYXRvciBpbiB2YWwpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBEYXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNEYXRlID0ga2luZE9mVGVzdCgnRGF0ZScpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNGaWxlID0ga2luZE9mVGVzdCgnRmlsZScpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCbG9iLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNCbG9iID0ga2luZE9mVGVzdCgnQmxvYicpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZUxpc3RcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzRmlsZUxpc3QgPSBraW5kT2ZUZXN0KCdGaWxlTGlzdCcpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyZWFtXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmVhbSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzU3RyZWFtID0gKHZhbCkgPT4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC5waXBlKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHsqfSB0aGluZyBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEZvcm1EYXRhLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNGb3JtRGF0YSA9ICh0aGluZykgPT4ge1xuICBsZXQga2luZDtcbiAgcmV0dXJuIHRoaW5nICYmIChcbiAgICAodHlwZW9mIEZvcm1EYXRhID09PSAnZnVuY3Rpb24nICYmIHRoaW5nIGluc3RhbmNlb2YgRm9ybURhdGEpIHx8IChcbiAgICAgIGlzRnVuY3Rpb24odGhpbmcuYXBwZW5kKSAmJiAoXG4gICAgICAgIChraW5kID0ga2luZE9mKHRoaW5nKSkgPT09ICdmb3JtZGF0YScgfHxcbiAgICAgICAgLy8gZGV0ZWN0IGZvcm0tZGF0YSBpbnN0YW5jZVxuICAgICAgICAoa2luZCA9PT0gJ29iamVjdCcgJiYgaXNGdW5jdGlvbih0aGluZy50b1N0cmluZykgJiYgdGhpbmcudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgRm9ybURhdGFdJylcbiAgICAgIClcbiAgICApXG4gIClcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3RcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzVVJMU2VhcmNoUGFyYW1zID0ga2luZE9mVGVzdCgnVVJMU2VhcmNoUGFyYW1zJyk7XG5cbi8qKlxuICogVHJpbSBleGNlc3Mgd2hpdGVzcGFjZSBvZmYgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgU3RyaW5nIHRvIHRyaW1cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgU3RyaW5nIGZyZWVkIG9mIGV4Y2VzcyB3aGl0ZXNwYWNlXG4gKi9cbmNvbnN0IHRyaW0gPSAoc3RyKSA9PiBzdHIudHJpbSA/XG4gIHN0ci50cmltKCkgOiBzdHIucmVwbGFjZSgvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csICcnKTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYW4gQXJyYXkgb3IgYW4gT2JqZWN0IGludm9raW5nIGEgZnVuY3Rpb24gZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiBgb2JqYCBpcyBhbiBBcnJheSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGluZGV4LCBhbmQgY29tcGxldGUgYXJyYXkgZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiAnb2JqJyBpcyBhbiBPYmplY3QgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBrZXksIGFuZCBjb21wbGV0ZSBvYmplY3QgZm9yIGVhY2ggcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9iaiBUaGUgb2JqZWN0IHRvIGl0ZXJhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBjYWxsYmFjayB0byBpbnZva2UgZm9yIGVhY2ggaXRlbVxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FsbE93bktleXMgPSBmYWxzZV1cbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbiwge2FsbE93bktleXMgPSBmYWxzZX0gPSB7fSkge1xuICAvLyBEb24ndCBib3RoZXIgaWYgbm8gdmFsdWUgcHJvdmlkZWRcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBpO1xuICBsZXQgbDtcblxuICAvLyBGb3JjZSBhbiBhcnJheSBpZiBub3QgYWxyZWFkeSBzb21ldGhpbmcgaXRlcmFibGVcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgb2JqID0gW29ial07XG4gIH1cblxuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIGFycmF5IHZhbHVlc1xuICAgIGZvciAoaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIG9iamVjdCBrZXlzXG4gICAgY29uc3Qga2V5cyA9IGFsbE93bktleXMgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopIDogT2JqZWN0LmtleXMob2JqKTtcbiAgICBjb25zdCBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICBsZXQga2V5O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgZm4uY2FsbChudWxsLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kS2V5KG9iaiwga2V5KSB7XG4gIGtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcbiAgbGV0IF9rZXk7XG4gIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgX2tleSA9IGtleXNbaV07XG4gICAgaWYgKGtleSA9PT0gX2tleS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICByZXR1cm4gX2tleTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmNvbnN0IF9nbG9iYWwgPSAoKCkgPT4ge1xuICAvKmVzbGludCBuby11bmRlZjowKi9cbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZ2xvYmFsVGhpcztcbiAgcmV0dXJuIHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbClcbn0pKCk7XG5cbmNvbnN0IGlzQ29udGV4dERlZmluZWQgPSAoY29udGV4dCkgPT4gIWlzVW5kZWZpbmVkKGNvbnRleHQpICYmIGNvbnRleHQgIT09IF9nbG9iYWw7XG5cbi8qKlxuICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlc3VsdCBvZiBhbGwgbWVyZ2UgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtZXJnZSgvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi8pIHtcbiAgY29uc3Qge2Nhc2VsZXNzfSA9IGlzQ29udGV4dERlZmluZWQodGhpcykgJiYgdGhpcyB8fCB7fTtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGNvbnN0IGFzc2lnblZhbHVlID0gKHZhbCwga2V5KSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0S2V5ID0gY2FzZWxlc3MgJiYgZmluZEtleShyZXN1bHQsIGtleSkgfHwga2V5O1xuICAgIGlmIChpc1BsYWluT2JqZWN0KHJlc3VsdFt0YXJnZXRLZXldKSAmJiBpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gbWVyZ2UocmVzdWx0W3RhcmdldEtleV0sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gbWVyZ2Uoe30sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gdmFsLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGFyZ3VtZW50c1tpXSAmJiBmb3JFYWNoKGFyZ3VtZW50c1tpXSwgYXNzaWduVmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRXh0ZW5kcyBvYmplY3QgYSBieSBtdXRhYmx5IGFkZGluZyB0byBpdCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkXG4gKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyBUaGUgb2JqZWN0IHRvIGJpbmQgZnVuY3Rpb24gdG9cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFthbGxPd25LZXlzXVxuICogQHJldHVybnMge09iamVjdH0gVGhlIHJlc3VsdGluZyB2YWx1ZSBvZiBvYmplY3QgYVxuICovXG5jb25zdCBleHRlbmQgPSAoYSwgYiwgdGhpc0FyZywge2FsbE93bktleXN9PSB7fSkgPT4ge1xuICBmb3JFYWNoKGIsICh2YWwsIGtleSkgPT4ge1xuICAgIGlmICh0aGlzQXJnICYmIGlzRnVuY3Rpb24odmFsKSkge1xuICAgICAgYVtrZXldID0gYmluZCh2YWwsIHRoaXNBcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhW2tleV0gPSB2YWw7XG4gICAgfVxuICB9LCB7YWxsT3duS2V5c30pO1xuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYnl0ZSBvcmRlciBtYXJrZXIuIFRoaXMgY2F0Y2hlcyBFRiBCQiBCRiAodGhlIFVURi04IEJPTSlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCB3aXRoIEJPTVxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGNvbnRlbnQgdmFsdWUgd2l0aG91dCBCT01cbiAqL1xuY29uc3Qgc3RyaXBCT00gPSAoY29udGVudCkgPT4ge1xuICBpZiAoY29udGVudC5jaGFyQ29kZUF0KDApID09PSAweEZFRkYpIHtcbiAgICBjb250ZW50ID0gY29udGVudC5zbGljZSgxKTtcbiAgfVxuICByZXR1cm4gY29udGVudDtcbn1cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gW3Byb3BzXVxuICogQHBhcmFtIHtvYmplY3R9IFtkZXNjcmlwdG9yc11cbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuY29uc3QgaW5oZXJpdHMgPSAoY29uc3RydWN0b3IsIHN1cGVyQ29uc3RydWN0b3IsIHByb3BzLCBkZXNjcmlwdG9ycykgPT4ge1xuICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ29uc3RydWN0b3IucHJvdG90eXBlLCBkZXNjcmlwdG9ycyk7XG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29uc3RydWN0b3IsICdzdXBlcicsIHtcbiAgICB2YWx1ZTogc3VwZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGVcbiAgfSk7XG4gIHByb3BzICYmIE9iamVjdC5hc3NpZ24oY29uc3RydWN0b3IucHJvdG90eXBlLCBwcm9wcyk7XG59XG5cbi8qKlxuICogUmVzb2x2ZSBvYmplY3Qgd2l0aCBkZWVwIHByb3RvdHlwZSBjaGFpbiB0byBhIGZsYXQgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlT2JqIHNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZGVzdE9ial1cbiAqIEBwYXJhbSB7RnVuY3Rpb258Qm9vbGVhbn0gW2ZpbHRlcl1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9wRmlsdGVyXVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmNvbnN0IHRvRmxhdE9iamVjdCA9IChzb3VyY2VPYmosIGRlc3RPYmosIGZpbHRlciwgcHJvcEZpbHRlcikgPT4ge1xuICBsZXQgcHJvcHM7XG4gIGxldCBpO1xuICBsZXQgcHJvcDtcbiAgY29uc3QgbWVyZ2VkID0ge307XG5cbiAgZGVzdE9iaiA9IGRlc3RPYmogfHwge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lcS1udWxsLGVxZXFlcVxuICBpZiAoc291cmNlT2JqID09IG51bGwpIHJldHVybiBkZXN0T2JqO1xuXG4gIGRvIHtcbiAgICBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZU9iaik7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgaWYgKCghcHJvcEZpbHRlciB8fCBwcm9wRmlsdGVyKHByb3AsIHNvdXJjZU9iaiwgZGVzdE9iaikpICYmICFtZXJnZWRbcHJvcF0pIHtcbiAgICAgICAgZGVzdE9ialtwcm9wXSA9IHNvdXJjZU9ialtwcm9wXTtcbiAgICAgICAgbWVyZ2VkW3Byb3BdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc291cmNlT2JqID0gZmlsdGVyICE9PSBmYWxzZSAmJiBnZXRQcm90b3R5cGVPZihzb3VyY2VPYmopO1xuICB9IHdoaWxlIChzb3VyY2VPYmogJiYgKCFmaWx0ZXIgfHwgZmlsdGVyKHNvdXJjZU9iaiwgZGVzdE9iaikpICYmIHNvdXJjZU9iaiAhPT0gT2JqZWN0LnByb3RvdHlwZSk7XG5cbiAgcmV0dXJuIGRlc3RPYmo7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgc3RyaW5nIGVuZHMgd2l0aCB0aGUgY2hhcmFjdGVycyBvZiBhIHNwZWNpZmllZCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VhcmNoU3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gW3Bvc2l0aW9uPSAwXVxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBlbmRzV2l0aCA9IChzdHIsIHNlYXJjaFN0cmluZywgcG9zaXRpb24pID0+IHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChwb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHBvc2l0aW9uID4gc3RyLmxlbmd0aCkge1xuICAgIHBvc2l0aW9uID0gc3RyLmxlbmd0aDtcbiAgfVxuICBwb3NpdGlvbiAtPSBzZWFyY2hTdHJpbmcubGVuZ3RoO1xuICBjb25zdCBsYXN0SW5kZXggPSBzdHIuaW5kZXhPZihzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKTtcbiAgcmV0dXJuIGxhc3RJbmRleCAhPT0gLTEgJiYgbGFzdEluZGV4ID09PSBwb3NpdGlvbjtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgbmV3IGFycmF5IGZyb20gYXJyYXkgbGlrZSBvYmplY3Qgb3IgbnVsbCBpZiBmYWlsZWRcbiAqXG4gKiBAcGFyYW0geyp9IFt0aGluZ11cbiAqXG4gKiBAcmV0dXJucyB7P0FycmF5fVxuICovXG5jb25zdCB0b0FycmF5ID0gKHRoaW5nKSA9PiB7XG4gIGlmICghdGhpbmcpIHJldHVybiBudWxsO1xuICBpZiAoaXNBcnJheSh0aGluZykpIHJldHVybiB0aGluZztcbiAgbGV0IGkgPSB0aGluZy5sZW5ndGg7XG4gIGlmICghaXNOdW1iZXIoaSkpIHJldHVybiBudWxsO1xuICBjb25zdCBhcnIgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgYXJyW2ldID0gdGhpbmdbaV07XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuLyoqXG4gKiBDaGVja2luZyBpZiB0aGUgVWludDhBcnJheSBleGlzdHMgYW5kIGlmIGl0IGRvZXMsIGl0IHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiB0aGVcbiAqIHRoaW5nIHBhc3NlZCBpbiBpcyBhbiBpbnN0YW5jZSBvZiBVaW50OEFycmF5XG4gKlxuICogQHBhcmFtIHtUeXBlZEFycmF5fVxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbmNvbnN0IGlzVHlwZWRBcnJheSA9IChUeXBlZEFycmF5ID0+IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgcmV0dXJuIHRoaW5nID0+IHtcbiAgICByZXR1cm4gVHlwZWRBcnJheSAmJiB0aGluZyBpbnN0YW5jZW9mIFR5cGVkQXJyYXk7XG4gIH07XG59KSh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2V0UHJvdG90eXBlT2YoVWludDhBcnJheSkpO1xuXG4vKipcbiAqIEZvciBlYWNoIGVudHJ5IGluIHRoZSBvYmplY3QsIGNhbGwgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGtleSBhbmQgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtPYmplY3Q8YW55LCBhbnk+fSBvYmogLSBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggZW50cnkuXG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmNvbnN0IGZvckVhY2hFbnRyeSA9IChvYmosIGZuKSA9PiB7XG4gIGNvbnN0IGdlbmVyYXRvciA9IG9iaiAmJiBvYmpbU3ltYm9sLml0ZXJhdG9yXTtcblxuICBjb25zdCBpdGVyYXRvciA9IGdlbmVyYXRvci5jYWxsKG9iaik7XG5cbiAgbGV0IHJlc3VsdDtcblxuICB3aGlsZSAoKHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKSkgJiYgIXJlc3VsdC5kb25lKSB7XG4gICAgY29uc3QgcGFpciA9IHJlc3VsdC52YWx1ZTtcbiAgICBmbi5jYWxsKG9iaiwgcGFpclswXSwgcGFpclsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBJdCB0YWtlcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBhbmQgYSBzdHJpbmcsIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIGFsbCB0aGUgbWF0Y2hlc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdFeHAgLSBUaGUgcmVndWxhciBleHByZXNzaW9uIHRvIG1hdGNoIGFnYWluc3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gVGhlIHN0cmluZyB0byBzZWFyY2guXG4gKlxuICogQHJldHVybnMge0FycmF5PGJvb2xlYW4+fVxuICovXG5jb25zdCBtYXRjaEFsbCA9IChyZWdFeHAsIHN0cikgPT4ge1xuICBsZXQgbWF0Y2hlcztcbiAgY29uc3QgYXJyID0gW107XG5cbiAgd2hpbGUgKChtYXRjaGVzID0gcmVnRXhwLmV4ZWMoc3RyKSkgIT09IG51bGwpIHtcbiAgICBhcnIucHVzaChtYXRjaGVzKTtcbiAgfVxuXG4gIHJldHVybiBhcnI7XG59XG5cbi8qIENoZWNraW5nIGlmIHRoZSBraW5kT2ZUZXN0IGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSB3aGVuIHBhc3NlZCBhbiBIVE1MRm9ybUVsZW1lbnQuICovXG5jb25zdCBpc0hUTUxGb3JtID0ga2luZE9mVGVzdCgnSFRNTEZvcm1FbGVtZW50Jyk7XG5cbmNvbnN0IHRvQ2FtZWxDYXNlID0gc3RyID0+IHtcbiAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1stX1xcc10oW2EtelxcZF0pKFxcdyopL2csXG4gICAgZnVuY3Rpb24gcmVwbGFjZXIobSwgcDEsIHAyKSB7XG4gICAgICByZXR1cm4gcDEudG9VcHBlckNhc2UoKSArIHAyO1xuICAgIH1cbiAgKTtcbn07XG5cbi8qIENyZWF0aW5nIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGNoZWNrIGlmIGFuIG9iamVjdCBoYXMgYSBwcm9wZXJ0eS4gKi9cbmNvbnN0IGhhc093blByb3BlcnR5ID0gKCh7aGFzT3duUHJvcGVydHl9KSA9PiAob2JqLCBwcm9wKSA9PiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpKE9iamVjdC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgUmVnRXhwIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBSZWdFeHAgb2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNSZWdFeHAgPSBraW5kT2ZUZXN0KCdSZWdFeHAnKTtcblxuY29uc3QgcmVkdWNlRGVzY3JpcHRvcnMgPSAob2JqLCByZWR1Y2VyKSA9PiB7XG4gIGNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqKTtcbiAgY29uc3QgcmVkdWNlZERlc2NyaXB0b3JzID0ge307XG5cbiAgZm9yRWFjaChkZXNjcmlwdG9ycywgKGRlc2NyaXB0b3IsIG5hbWUpID0+IHtcbiAgICBsZXQgcmV0O1xuICAgIGlmICgocmV0ID0gcmVkdWNlcihkZXNjcmlwdG9yLCBuYW1lLCBvYmopKSAhPT0gZmFsc2UpIHtcbiAgICAgIHJlZHVjZWREZXNjcmlwdG9yc1tuYW1lXSA9IHJldCB8fCBkZXNjcmlwdG9yO1xuICAgIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMob2JqLCByZWR1Y2VkRGVzY3JpcHRvcnMpO1xufVxuXG4vKipcbiAqIE1ha2VzIGFsbCBtZXRob2RzIHJlYWQtb25seVxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICovXG5cbmNvbnN0IGZyZWV6ZU1ldGhvZHMgPSAob2JqKSA9PiB7XG4gIHJlZHVjZURlc2NyaXB0b3JzKG9iaiwgKGRlc2NyaXB0b3IsIG5hbWUpID0+IHtcbiAgICAvLyBza2lwIHJlc3RyaWN0ZWQgcHJvcHMgaW4gc3RyaWN0IG1vZGVcbiAgICBpZiAoaXNGdW5jdGlvbihvYmopICYmIFsnYXJndW1lbnRzJywgJ2NhbGxlcicsICdjYWxsZWUnXS5pbmRleE9mKG5hbWUpICE9PSAtMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbHVlID0gb2JqW25hbWVdO1xuXG4gICAgaWYgKCFpc0Z1bmN0aW9uKHZhbHVlKSkgcmV0dXJuO1xuXG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZmFsc2U7XG5cbiAgICBpZiAoJ3dyaXRhYmxlJyBpbiBkZXNjcmlwdG9yKSB7XG4gICAgICBkZXNjcmlwdG9yLndyaXRhYmxlID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFkZXNjcmlwdG9yLnNldCkge1xuICAgICAgZGVzY3JpcHRvci5zZXQgPSAoKSA9PiB7XG4gICAgICAgIHRocm93IEVycm9yKCdDYW4gbm90IHJld3JpdGUgcmVhZC1vbmx5IG1ldGhvZCBcXCcnICsgbmFtZSArICdcXCcnKTtcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbn1cblxuY29uc3QgdG9PYmplY3RTZXQgPSAoYXJyYXlPclN0cmluZywgZGVsaW1pdGVyKSA9PiB7XG4gIGNvbnN0IG9iaiA9IHt9O1xuXG4gIGNvbnN0IGRlZmluZSA9IChhcnIpID0+IHtcbiAgICBhcnIuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICBvYmpbdmFsdWVdID0gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIGlzQXJyYXkoYXJyYXlPclN0cmluZykgPyBkZWZpbmUoYXJyYXlPclN0cmluZykgOiBkZWZpbmUoU3RyaW5nKGFycmF5T3JTdHJpbmcpLnNwbGl0KGRlbGltaXRlcikpO1xuXG4gIHJldHVybiBvYmo7XG59XG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fVxuXG5jb25zdCB0b0Zpbml0ZU51bWJlciA9ICh2YWx1ZSwgZGVmYXVsdFZhbHVlKSA9PiB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKHZhbHVlKSA/IHZhbHVlIDogZGVmYXVsdFZhbHVlO1xufVxuXG5jb25zdCBBTFBIQSA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eidcblxuY29uc3QgRElHSVQgPSAnMDEyMzQ1Njc4OSc7XG5cbmNvbnN0IEFMUEhBQkVUID0ge1xuICBESUdJVCxcbiAgQUxQSEEsXG4gIEFMUEhBX0RJR0lUOiBBTFBIQSArIEFMUEhBLnRvVXBwZXJDYXNlKCkgKyBESUdJVFxufVxuXG5jb25zdCBnZW5lcmF0ZVN0cmluZyA9IChzaXplID0gMTYsIGFscGhhYmV0ID0gQUxQSEFCRVQuQUxQSEFfRElHSVQpID0+IHtcbiAgbGV0IHN0ciA9ICcnO1xuICBjb25zdCB7bGVuZ3RofSA9IGFscGhhYmV0O1xuICB3aGlsZSAoc2l6ZS0tKSB7XG4gICAgc3RyICs9IGFscGhhYmV0W01hdGgucmFuZG9tKCkgKiBsZW5ndGh8MF1cbiAgfVxuXG4gIHJldHVybiBzdHI7XG59XG5cbi8qKlxuICogSWYgdGhlIHRoaW5nIGlzIGEgRm9ybURhdGEgb2JqZWN0LCByZXR1cm4gdHJ1ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cbiAqXG4gKiBAcGFyYW0ge3Vua25vd259IHRoaW5nIC0gVGhlIHRoaW5nIHRvIGNoZWNrLlxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1NwZWNDb21wbGlhbnRGb3JtKHRoaW5nKSB7XG4gIHJldHVybiAhISh0aGluZyAmJiBpc0Z1bmN0aW9uKHRoaW5nLmFwcGVuZCkgJiYgdGhpbmdbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0Zvcm1EYXRhJyAmJiB0aGluZ1tTeW1ib2wuaXRlcmF0b3JdKTtcbn1cblxuY29uc3QgdG9KU09OT2JqZWN0ID0gKG9iaikgPT4ge1xuICBjb25zdCBzdGFjayA9IG5ldyBBcnJheSgxMCk7XG5cbiAgY29uc3QgdmlzaXQgPSAoc291cmNlLCBpKSA9PiB7XG5cbiAgICBpZiAoaXNPYmplY3Qoc291cmNlKSkge1xuICAgICAgaWYgKHN0YWNrLmluZGV4T2Yoc291cmNlKSA+PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYoISgndG9KU09OJyBpbiBzb3VyY2UpKSB7XG4gICAgICAgIHN0YWNrW2ldID0gc291cmNlO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBpc0FycmF5KHNvdXJjZSkgPyBbXSA6IHt9O1xuXG4gICAgICAgIGZvckVhY2goc291cmNlLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlZHVjZWRWYWx1ZSA9IHZpc2l0KHZhbHVlLCBpICsgMSk7XG4gICAgICAgICAgIWlzVW5kZWZpbmVkKHJlZHVjZWRWYWx1ZSkgJiYgKHRhcmdldFtrZXldID0gcmVkdWNlZFZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3RhY2tbaV0gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgcmV0dXJuIHZpc2l0KG9iaiwgMCk7XG59XG5cbmNvbnN0IGlzQXN5bmNGbiA9IGtpbmRPZlRlc3QoJ0FzeW5jRnVuY3Rpb24nKTtcblxuY29uc3QgaXNUaGVuYWJsZSA9ICh0aGluZykgPT5cbiAgdGhpbmcgJiYgKGlzT2JqZWN0KHRoaW5nKSB8fCBpc0Z1bmN0aW9uKHRoaW5nKSkgJiYgaXNGdW5jdGlvbih0aGluZy50aGVuKSAmJiBpc0Z1bmN0aW9uKHRoaW5nLmNhdGNoKTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBpc0FycmF5LFxuICBpc0FycmF5QnVmZmVyLFxuICBpc0J1ZmZlcixcbiAgaXNGb3JtRGF0YSxcbiAgaXNBcnJheUJ1ZmZlclZpZXcsXG4gIGlzU3RyaW5nLFxuICBpc051bWJlcixcbiAgaXNCb29sZWFuLFxuICBpc09iamVjdCxcbiAgaXNQbGFpbk9iamVjdCxcbiAgaXNVbmRlZmluZWQsXG4gIGlzRGF0ZSxcbiAgaXNGaWxlLFxuICBpc0Jsb2IsXG4gIGlzUmVnRXhwLFxuICBpc0Z1bmN0aW9uLFxuICBpc1N0cmVhbSxcbiAgaXNVUkxTZWFyY2hQYXJhbXMsXG4gIGlzVHlwZWRBcnJheSxcbiAgaXNGaWxlTGlzdCxcbiAgZm9yRWFjaCxcbiAgbWVyZ2UsXG4gIGV4dGVuZCxcbiAgdHJpbSxcbiAgc3RyaXBCT00sXG4gIGluaGVyaXRzLFxuICB0b0ZsYXRPYmplY3QsXG4gIGtpbmRPZixcbiAga2luZE9mVGVzdCxcbiAgZW5kc1dpdGgsXG4gIHRvQXJyYXksXG4gIGZvckVhY2hFbnRyeSxcbiAgbWF0Y2hBbGwsXG4gIGlzSFRNTEZvcm0sXG4gIGhhc093blByb3BlcnR5LFxuICBoYXNPd25Qcm9wOiBoYXNPd25Qcm9wZXJ0eSwgLy8gYW4gYWxpYXMgdG8gYXZvaWQgRVNMaW50IG5vLXByb3RvdHlwZS1idWlsdGlucyBkZXRlY3Rpb25cbiAgcmVkdWNlRGVzY3JpcHRvcnMsXG4gIGZyZWV6ZU1ldGhvZHMsXG4gIHRvT2JqZWN0U2V0LFxuICB0b0NhbWVsQ2FzZSxcbiAgbm9vcCxcbiAgdG9GaW5pdGVOdW1iZXIsXG4gIGZpbmRLZXksXG4gIGdsb2JhbDogX2dsb2JhbCxcbiAgaXNDb250ZXh0RGVmaW5lZCxcbiAgQUxQSEFCRVQsXG4gIGdlbmVyYXRlU3RyaW5nLFxuICBpc1NwZWNDb21wbGlhbnRGb3JtLFxuICB0b0pTT05PYmplY3QsXG4gIGlzQXN5bmNGbixcbiAgaXNUaGVuYWJsZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcblxuLyoqXG4gKiBDcmVhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UsIGNvbmZpZywgZXJyb3IgY29kZSwgcmVxdWVzdCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICpcbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbmZ1bmN0aW9uIEF4aW9zRXJyb3IobWVzc2FnZSwgY29kZSwgY29uZmlnLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICBFcnJvci5jYWxsKHRoaXMpO1xuXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrO1xuICB9XG5cbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgdGhpcy5uYW1lID0gJ0F4aW9zRXJyb3InO1xuICBjb2RlICYmICh0aGlzLmNvZGUgPSBjb2RlKTtcbiAgY29uZmlnICYmICh0aGlzLmNvbmZpZyA9IGNvbmZpZyk7XG4gIHJlcXVlc3QgJiYgKHRoaXMucmVxdWVzdCA9IHJlcXVlc3QpO1xuICByZXNwb25zZSAmJiAodGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlKTtcbn1cblxudXRpbHMuaW5oZXJpdHMoQXhpb3NFcnJvciwgRXJyb3IsIHtcbiAgdG9KU09OOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFN0YW5kYXJkXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAvLyBNaWNyb3NvZnRcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgICAgbnVtYmVyOiB0aGlzLm51bWJlcixcbiAgICAgIC8vIE1vemlsbGFcbiAgICAgIGZpbGVOYW1lOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxuICAgICAgY29sdW1uTnVtYmVyOiB0aGlzLmNvbHVtbk51bWJlcixcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgLy8gQXhpb3NcbiAgICAgIGNvbmZpZzogdXRpbHMudG9KU09OT2JqZWN0KHRoaXMuY29uZmlnKSxcbiAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgIHN0YXR1czogdGhpcy5yZXNwb25zZSAmJiB0aGlzLnJlc3BvbnNlLnN0YXR1cyA/IHRoaXMucmVzcG9uc2Uuc3RhdHVzIDogbnVsbFxuICAgIH07XG4gIH1cbn0pO1xuXG5jb25zdCBwcm90b3R5cGUgPSBBeGlvc0Vycm9yLnByb3RvdHlwZTtcbmNvbnN0IGRlc2NyaXB0b3JzID0ge307XG5cbltcbiAgJ0VSUl9CQURfT1BUSU9OX1ZBTFVFJyxcbiAgJ0VSUl9CQURfT1BUSU9OJyxcbiAgJ0VDT05OQUJPUlRFRCcsXG4gICdFVElNRURPVVQnLFxuICAnRVJSX05FVFdPUksnLFxuICAnRVJSX0ZSX1RPT19NQU5ZX1JFRElSRUNUUycsXG4gICdFUlJfREVQUkVDQVRFRCcsXG4gICdFUlJfQkFEX1JFU1BPTlNFJyxcbiAgJ0VSUl9CQURfUkVRVUVTVCcsXG4gICdFUlJfQ0FOQ0VMRUQnLFxuICAnRVJSX05PVF9TVVBQT1JUJyxcbiAgJ0VSUl9JTlZBTElEX1VSTCdcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5dLmZvckVhY2goY29kZSA9PiB7XG4gIGRlc2NyaXB0b3JzW2NvZGVdID0ge3ZhbHVlOiBjb2RlfTtcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhBeGlvc0Vycm9yLCBkZXNjcmlwdG9ycyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCAnaXNBeGlvc0Vycm9yJywge3ZhbHVlOiB0cnVlfSk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5BeGlvc0Vycm9yLmZyb20gPSAoZXJyb3IsIGNvZGUsIGNvbmZpZywgcmVxdWVzdCwgcmVzcG9uc2UsIGN1c3RvbVByb3BzKSA9PiB7XG4gIGNvbnN0IGF4aW9zRXJyb3IgPSBPYmplY3QuY3JlYXRlKHByb3RvdHlwZSk7XG5cbiAgdXRpbHMudG9GbGF0T2JqZWN0KGVycm9yLCBheGlvc0Vycm9yLCBmdW5jdGlvbiBmaWx0ZXIob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPT0gRXJyb3IucHJvdG90eXBlO1xuICB9LCBwcm9wID0+IHtcbiAgICByZXR1cm4gcHJvcCAhPT0gJ2lzQXhpb3NFcnJvcic7XG4gIH0pO1xuXG4gIEF4aW9zRXJyb3IuY2FsbChheGlvc0Vycm9yLCBlcnJvci5tZXNzYWdlLCBjb2RlLCBjb25maWcsIHJlcXVlc3QsIHJlc3BvbnNlKTtcblxuICBheGlvc0Vycm9yLmNhdXNlID0gZXJyb3I7XG5cbiAgYXhpb3NFcnJvci5uYW1lID0gZXJyb3IubmFtZTtcblxuICBjdXN0b21Qcm9wcyAmJiBPYmplY3QuYXNzaWduKGF4aW9zRXJyb3IsIGN1c3RvbVByb3BzKTtcblxuICByZXR1cm4gYXhpb3NFcnJvcjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEF4aW9zRXJyb3I7XG4iLCIvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc3RyaWN0XG5leHBvcnQgZGVmYXVsdCBudWxsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSAnLi4vY29yZS9BeGlvc0Vycm9yLmpzJztcbi8vIHRlbXBvcmFyeSBob3RmaXggdG8gYXZvaWQgY2lyY3VsYXIgcmVmZXJlbmNlcyB1bnRpbCBBeGlvc1VSTFNlYXJjaFBhcmFtcyBpcyByZWZhY3RvcmVkXG5pbXBvcnQgUGxhdGZvcm1Gb3JtRGF0YSBmcm9tICcuLi9wbGF0Zm9ybS9ub2RlL2NsYXNzZXMvRm9ybURhdGEuanMnO1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGdpdmVuIHRoaW5nIGlzIGEgYXJyYXkgb3IganMgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aGluZyAtIFRoZSBvYmplY3Qgb3IgYXJyYXkgdG8gYmUgdmlzaXRlZC5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNWaXNpdGFibGUodGhpbmcpIHtcbiAgcmV0dXJuIHV0aWxzLmlzUGxhaW5PYmplY3QodGhpbmcpIHx8IHV0aWxzLmlzQXJyYXkodGhpbmcpO1xufVxuXG4vKipcbiAqIEl0IHJlbW92ZXMgdGhlIGJyYWNrZXRzIGZyb20gdGhlIGVuZCBvZiBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IG9mIHRoZSBwYXJhbWV0ZXIuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gdGhlIGtleSB3aXRob3V0IHRoZSBicmFja2V0cy5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQnJhY2tldHMoa2V5KSB7XG4gIHJldHVybiB1dGlscy5lbmRzV2l0aChrZXksICdbXScpID8ga2V5LnNsaWNlKDAsIC0yKSA6IGtleTtcbn1cblxuLyoqXG4gKiBJdCB0YWtlcyBhIHBhdGgsIGEga2V5LCBhbmQgYSBib29sZWFuLCBhbmQgcmV0dXJucyBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gVGhlIHBhdGggdG8gdGhlIGN1cnJlbnQga2V5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGJlaW5nIGl0ZXJhdGVkIG92ZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gZG90cyAtIElmIHRydWUsIHRoZSBrZXkgd2lsbCBiZSByZW5kZXJlZCB3aXRoIGRvdHMgaW5zdGVhZCBvZiBicmFja2V0cy5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgcGF0aCB0byB0aGUgY3VycmVudCBrZXkuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlcktleShwYXRoLCBrZXksIGRvdHMpIHtcbiAgaWYgKCFwYXRoKSByZXR1cm4ga2V5O1xuICByZXR1cm4gcGF0aC5jb25jYXQoa2V5KS5tYXAoZnVuY3Rpb24gZWFjaCh0b2tlbiwgaSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHRva2VuID0gcmVtb3ZlQnJhY2tldHModG9rZW4pO1xuICAgIHJldHVybiAhZG90cyAmJiBpID8gJ1snICsgdG9rZW4gKyAnXScgOiB0b2tlbjtcbiAgfSkuam9pbihkb3RzID8gJy4nIDogJycpO1xufVxuXG4vKipcbiAqIElmIHRoZSBhcnJheSBpcyBhbiBhcnJheSBhbmQgbm9uZSBvZiBpdHMgZWxlbWVudHMgYXJlIHZpc2l0YWJsZSwgdGhlbiBpdCdzIGEgZmxhdCBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PGFueT59IGFyciAtIFRoZSBhcnJheSB0byBjaGVja1xuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZsYXRBcnJheShhcnIpIHtcbiAgcmV0dXJuIHV0aWxzLmlzQXJyYXkoYXJyKSAmJiAhYXJyLnNvbWUoaXNWaXNpdGFibGUpO1xufVxuXG5jb25zdCBwcmVkaWNhdGVzID0gdXRpbHMudG9GbGF0T2JqZWN0KHV0aWxzLCB7fSwgbnVsbCwgZnVuY3Rpb24gZmlsdGVyKHByb3ApIHtcbiAgcmV0dXJuIC9eaXNbQS1aXS8udGVzdChwcm9wKTtcbn0pO1xuXG4vKipcbiAqIENvbnZlcnQgYSBkYXRhIG9iamVjdCB0byBGb3JtRGF0YVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7P09iamVjdH0gW2Zvcm1EYXRhXVxuICogQHBhcmFtIHs/T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLnZpc2l0b3JdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1ldGFUb2tlbnMgPSB0cnVlXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5kb3RzID0gZmFsc2VdXG4gKiBAcGFyYW0gez9Cb29sZWFufSBbb3B0aW9ucy5pbmRleGVzID0gZmFsc2VdXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqKi9cblxuLyoqXG4gKiBJdCBjb252ZXJ0cyBhbiBvYmplY3QgaW50byBhIEZvcm1EYXRhIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0PGFueSwgYW55Pn0gb2JqIC0gVGhlIG9iamVjdCB0byBjb252ZXJ0IHRvIGZvcm0gZGF0YS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtRGF0YSAtIFRoZSBGb3JtRGF0YSBvYmplY3QgdG8gYXBwZW5kIHRvLlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBvcHRpb25zXG4gKlxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gdG9Gb3JtRGF0YShvYmosIGZvcm1EYXRhLCBvcHRpb25zKSB7XG4gIGlmICghdXRpbHMuaXNPYmplY3Qob2JqKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RhcmdldCBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGZvcm1EYXRhID0gZm9ybURhdGEgfHwgbmV3IChQbGF0Zm9ybUZvcm1EYXRhIHx8IEZvcm1EYXRhKSgpO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBvcHRpb25zID0gdXRpbHMudG9GbGF0T2JqZWN0KG9wdGlvbnMsIHtcbiAgICBtZXRhVG9rZW5zOiB0cnVlLFxuICAgIGRvdHM6IGZhbHNlLFxuICAgIGluZGV4ZXM6IGZhbHNlXG4gIH0sIGZhbHNlLCBmdW5jdGlvbiBkZWZpbmVkKG9wdGlvbiwgc291cmNlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsZXFlcWVxXG4gICAgcmV0dXJuICF1dGlscy5pc1VuZGVmaW5lZChzb3VyY2Vbb3B0aW9uXSk7XG4gIH0pO1xuXG4gIGNvbnN0IG1ldGFUb2tlbnMgPSBvcHRpb25zLm1ldGFUb2tlbnM7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxuICBjb25zdCB2aXNpdG9yID0gb3B0aW9ucy52aXNpdG9yIHx8IGRlZmF1bHRWaXNpdG9yO1xuICBjb25zdCBkb3RzID0gb3B0aW9ucy5kb3RzO1xuICBjb25zdCBpbmRleGVzID0gb3B0aW9ucy5pbmRleGVzO1xuICBjb25zdCBfQmxvYiA9IG9wdGlvbnMuQmxvYiB8fCB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgQmxvYjtcbiAgY29uc3QgdXNlQmxvYiA9IF9CbG9iICYmIHV0aWxzLmlzU3BlY0NvbXBsaWFudEZvcm0oZm9ybURhdGEpO1xuXG4gIGlmICghdXRpbHMuaXNGdW5jdGlvbih2aXNpdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Zpc2l0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBmdW5jdGlvbiBjb252ZXJ0VmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHJldHVybiAnJztcblxuICAgIGlmICh1dGlscy5pc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUudG9JU09TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBpZiAoIXVzZUJsb2IgJiYgdXRpbHMuaXNCbG9iKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoJ0Jsb2IgaXMgbm90IHN1cHBvcnRlZC4gVXNlIGEgQnVmZmVyIGluc3RlYWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXIodmFsdWUpIHx8IHV0aWxzLmlzVHlwZWRBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB1c2VCbG9iICYmIHR5cGVvZiBCbG9iID09PSAnZnVuY3Rpb24nID8gbmV3IEJsb2IoW3ZhbHVlXSkgOiBCdWZmZXIuZnJvbSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgdmlzaXRvci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGtleVxuICAgKiBAcGFyYW0ge0FycmF5PFN0cmluZ3xOdW1iZXI+fSBwYXRoXG4gICAqIEB0aGlzIHtGb3JtRGF0YX1cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHJldHVybiB0cnVlIHRvIHZpc2l0IHRoZSBlYWNoIHByb3Agb2YgdGhlIHZhbHVlIHJlY3Vyc2l2ZWx5XG4gICAqL1xuICBmdW5jdGlvbiBkZWZhdWx0VmlzaXRvcih2YWx1ZSwga2V5LCBwYXRoKSB7XG4gICAgbGV0IGFyciA9IHZhbHVlO1xuXG4gICAgaWYgKHZhbHVlICYmICFwYXRoICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmICh1dGlscy5lbmRzV2l0aChrZXksICd7fScpKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBrZXkgPSBtZXRhVG9rZW5zID8ga2V5IDoga2V5LnNsaWNlKDAsIC0yKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgKHV0aWxzLmlzQXJyYXkodmFsdWUpICYmIGlzRmxhdEFycmF5KHZhbHVlKSkgfHxcbiAgICAgICAgKCh1dGlscy5pc0ZpbGVMaXN0KHZhbHVlKSB8fCB1dGlscy5lbmRzV2l0aChrZXksICdbXScpKSAmJiAoYXJyID0gdXRpbHMudG9BcnJheSh2YWx1ZSkpXG4gICAgICAgICkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGtleSA9IHJlbW92ZUJyYWNrZXRzKGtleSk7XG5cbiAgICAgICAgYXJyLmZvckVhY2goZnVuY3Rpb24gZWFjaChlbCwgaW5kZXgpIHtcbiAgICAgICAgICAhKHV0aWxzLmlzVW5kZWZpbmVkKGVsKSB8fCBlbCA9PT0gbnVsbCkgJiYgZm9ybURhdGEuYXBwZW5kKFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgICAgICBpbmRleGVzID09PSB0cnVlID8gcmVuZGVyS2V5KFtrZXldLCBpbmRleCwgZG90cykgOiAoaW5kZXhlcyA9PT0gbnVsbCA/IGtleSA6IGtleSArICdbXScpLFxuICAgICAgICAgICAgY29udmVydFZhbHVlKGVsKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzVmlzaXRhYmxlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZm9ybURhdGEuYXBwZW5kKHJlbmRlcktleShwYXRoLCBrZXksIGRvdHMpLCBjb252ZXJ0VmFsdWUodmFsdWUpKTtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHN0YWNrID0gW107XG5cbiAgY29uc3QgZXhwb3NlZEhlbHBlcnMgPSBPYmplY3QuYXNzaWduKHByZWRpY2F0ZXMsIHtcbiAgICBkZWZhdWx0VmlzaXRvcixcbiAgICBjb252ZXJ0VmFsdWUsXG4gICAgaXNWaXNpdGFibGVcbiAgfSk7XG5cbiAgZnVuY3Rpb24gYnVpbGQodmFsdWUsIHBhdGgpIHtcbiAgICBpZiAodXRpbHMuaXNVbmRlZmluZWQodmFsdWUpKSByZXR1cm47XG5cbiAgICBpZiAoc3RhY2suaW5kZXhPZih2YWx1ZSkgIT09IC0xKSB7XG4gICAgICB0aHJvdyBFcnJvcignQ2lyY3VsYXIgcmVmZXJlbmNlIGRldGVjdGVkIGluICcgKyBwYXRoLmpvaW4oJy4nKSk7XG4gICAgfVxuXG4gICAgc3RhY2sucHVzaCh2YWx1ZSk7XG5cbiAgICB1dGlscy5mb3JFYWNoKHZhbHVlLCBmdW5jdGlvbiBlYWNoKGVsLCBrZXkpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9ICEodXRpbHMuaXNVbmRlZmluZWQoZWwpIHx8IGVsID09PSBudWxsKSAmJiB2aXNpdG9yLmNhbGwoXG4gICAgICAgIGZvcm1EYXRhLCBlbCwgdXRpbHMuaXNTdHJpbmcoa2V5KSA/IGtleS50cmltKCkgOiBrZXksIHBhdGgsIGV4cG9zZWRIZWxwZXJzXG4gICAgICApO1xuXG4gICAgICBpZiAocmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICAgIGJ1aWxkKGVsLCBwYXRoID8gcGF0aC5jb25jYXQoa2V5KSA6IFtrZXldKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHN0YWNrLnBvcCgpO1xuICB9XG5cbiAgaWYgKCF1dGlscy5pc09iamVjdChvYmopKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGF0YSBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICB9XG5cbiAgYnVpbGQob2JqKTtcblxuICByZXR1cm4gZm9ybURhdGE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRvRm9ybURhdGE7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB0b0Zvcm1EYXRhIGZyb20gJy4vdG9Gb3JtRGF0YS5qcyc7XG5cbi8qKlxuICogSXQgZW5jb2RlcyBhIHN0cmluZyBieSByZXBsYWNpbmcgYWxsIGNoYXJhY3RlcnMgdGhhdCBhcmUgbm90IGluIHRoZSB1bnJlc2VydmVkIHNldCB3aXRoXG4gKiB0aGVpciBwZXJjZW50LWVuY29kZWQgZXF1aXZhbGVudHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gVGhlIHN0cmluZyB0byBlbmNvZGUuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGVuY29kZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBlbmNvZGUoc3RyKSB7XG4gIGNvbnN0IGNoYXJNYXAgPSB7XG4gICAgJyEnOiAnJTIxJyxcbiAgICBcIidcIjogJyUyNycsXG4gICAgJygnOiAnJTI4JyxcbiAgICAnKSc6ICclMjknLFxuICAgICd+JzogJyU3RScsXG4gICAgJyUyMCc6ICcrJyxcbiAgICAnJTAwJzogJ1xceDAwJ1xuICB9O1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cikucmVwbGFjZSgvWyEnKCl+XXwlMjB8JTAwL2csIGZ1bmN0aW9uIHJlcGxhY2VyKG1hdGNoKSB7XG4gICAgcmV0dXJuIGNoYXJNYXBbbWF0Y2hdO1xuICB9KTtcbn1cblxuLyoqXG4gKiBJdCB0YWtlcyBhIHBhcmFtcyBvYmplY3QgYW5kIGNvbnZlcnRzIGl0IHRvIGEgRm9ybURhdGEgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyB0byBiZSBjb252ZXJ0ZWQgdG8gYSBGb3JtRGF0YSBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBvYmplY3QgcGFzc2VkIHRvIHRoZSBBeGlvcyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gQXhpb3NVUkxTZWFyY2hQYXJhbXMocGFyYW1zLCBvcHRpb25zKSB7XG4gIHRoaXMuX3BhaXJzID0gW107XG5cbiAgcGFyYW1zICYmIHRvRm9ybURhdGEocGFyYW1zLCB0aGlzLCBvcHRpb25zKTtcbn1cblxuY29uc3QgcHJvdG90eXBlID0gQXhpb3NVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlO1xuXG5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKG5hbWUsIHZhbHVlKSB7XG4gIHRoaXMuX3BhaXJzLnB1c2goW25hbWUsIHZhbHVlXSk7XG59O1xuXG5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhlbmNvZGVyKSB7XG4gIGNvbnN0IF9lbmNvZGUgPSBlbmNvZGVyID8gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZW5jb2Rlci5jYWxsKHRoaXMsIHZhbHVlLCBlbmNvZGUpO1xuICB9IDogZW5jb2RlO1xuXG4gIHJldHVybiB0aGlzLl9wYWlycy5tYXAoZnVuY3Rpb24gZWFjaChwYWlyKSB7XG4gICAgcmV0dXJuIF9lbmNvZGUocGFpclswXSkgKyAnPScgKyBfZW5jb2RlKHBhaXJbMV0pO1xuICB9LCAnJykuam9pbignJicpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQXhpb3NVUkxTZWFyY2hQYXJhbXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgQXhpb3NVUkxTZWFyY2hQYXJhbXMgZnJvbSAnLi4vaGVscGVycy9BeGlvc1VSTFNlYXJjaFBhcmFtcy5qcyc7XG5cbi8qKlxuICogSXQgcmVwbGFjZXMgYWxsIGluc3RhbmNlcyBvZiB0aGUgY2hhcmFjdGVycyBgOmAsIGAkYCwgYCxgLCBgK2AsIGBbYCwgYW5kIGBdYCB3aXRoIHRoZWlyXG4gKiBVUkkgZW5jb2RlZCBjb3VudGVycGFydHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsIFRoZSB2YWx1ZSB0byBiZSBlbmNvZGVkLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBlbmNvZGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBlbmNvZGUodmFsKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKS5cbiAgICByZXBsYWNlKC8lM0EvZ2ksICc6JykuXG4gICAgcmVwbGFjZSgvJTI0L2csICckJykuXG4gICAgcmVwbGFjZSgvJTJDL2dpLCAnLCcpLlxuICAgIHJlcGxhY2UoLyUyMC9nLCAnKycpLlxuICAgIHJlcGxhY2UoLyU1Qi9naSwgJ1snKS5cbiAgICByZXBsYWNlKC8lNUQvZ2ksICddJyk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBVUkwgYnkgYXBwZW5kaW5nIHBhcmFtcyB0byB0aGUgZW5kXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgYmFzZSBvZiB0aGUgdXJsIChlLmcuLCBodHRwOi8vd3d3Lmdvb2dsZS5jb20pXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc10gVGhlIHBhcmFtcyB0byBiZSBhcHBlbmRlZFxuICogQHBhcmFtIHs/b2JqZWN0fSBvcHRpb25zXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCB1cmxcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYnVpbGRVUkwodXJsLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBcbiAgY29uc3QgX2VuY29kZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5lbmNvZGUgfHwgZW5jb2RlO1xuXG4gIGNvbnN0IHNlcmlhbGl6ZUZuID0gb3B0aW9ucyAmJiBvcHRpb25zLnNlcmlhbGl6ZTtcblxuICBsZXQgc2VyaWFsaXplZFBhcmFtcztcblxuICBpZiAoc2VyaWFsaXplRm4pIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gc2VyaWFsaXplRm4ocGFyYW1zLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gdXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMocGFyYW1zKSA/XG4gICAgICBwYXJhbXMudG9TdHJpbmcoKSA6XG4gICAgICBuZXcgQXhpb3NVUkxTZWFyY2hQYXJhbXMocGFyYW1zLCBvcHRpb25zKS50b1N0cmluZyhfZW5jb2RlKTtcbiAgfVxuXG4gIGlmIChzZXJpYWxpemVkUGFyYW1zKSB7XG4gICAgY29uc3QgaGFzaG1hcmtJbmRleCA9IHVybC5pbmRleE9mKFwiI1wiKTtcblxuICAgIGlmIChoYXNobWFya0luZGV4ICE9PSAtMSkge1xuICAgICAgdXJsID0gdXJsLnNsaWNlKDAsIGhhc2htYXJrSW5kZXgpO1xuICAgIH1cbiAgICB1cmwgKz0gKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5cbmNsYXNzIEludGVyY2VwdG9yTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bGZpbGxlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGB0aGVuYCBmb3IgYSBgUHJvbWlzZWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBBbiBJRCB1c2VkIHRvIHJlbW92ZSBpbnRlcmNlcHRvciBsYXRlclxuICAgKi9cbiAgdXNlKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgICAgZnVsZmlsbGVkLFxuICAgICAgcmVqZWN0ZWQsXG4gICAgICBzeW5jaHJvbm91czogb3B0aW9ucyA/IG9wdGlvbnMuc3luY2hyb25vdXMgOiBmYWxzZSxcbiAgICAgIHJ1bldoZW46IG9wdGlvbnMgPyBvcHRpb25zLnJ1bldoZW4gOiBudWxsXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlcnMubGVuZ3RoIC0gMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gaW50ZXJjZXB0b3IgZnJvbSB0aGUgc3RhY2tcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGlkIFRoZSBJRCB0aGF0IHdhcyByZXR1cm5lZCBieSBgdXNlYFxuICAgKlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBpbnRlcmNlcHRvciB3YXMgcmVtb3ZlZCwgYGZhbHNlYCBvdGhlcndpc2VcbiAgICovXG4gIGVqZWN0KGlkKSB7XG4gICAgaWYgKHRoaXMuaGFuZGxlcnNbaWRdKSB7XG4gICAgICB0aGlzLmhhbmRsZXJzW2lkXSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBpbnRlcmNlcHRvcnMgZnJvbSB0aGUgc3RhY2tcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBjbGVhcigpIHtcbiAgICBpZiAodGhpcy5oYW5kbGVycykge1xuICAgICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBza2lwcGluZyBvdmVyIGFueVxuICAgKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaW50ZXJjZXB0b3JcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBmb3JFYWNoKGZuKSB7XG4gICAgdXRpbHMuZm9yRWFjaCh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbiBmb3JFYWNoSGFuZGxlcihoKSB7XG4gICAgICBpZiAoaCAhPT0gbnVsbCkge1xuICAgICAgICBmbihoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbnRlcmNlcHRvck1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgc2lsZW50SlNPTlBhcnNpbmc6IHRydWUsXG4gIGZvcmNlZEpTT05QYXJzaW5nOiB0cnVlLFxuICBjbGFyaWZ5VGltZW91dEVycm9yOiBmYWxzZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEF4aW9zVVJMU2VhcmNoUGFyYW1zIGZyb20gJy4uLy4uLy4uL2hlbHBlcnMvQXhpb3NVUkxTZWFyY2hQYXJhbXMuanMnO1xuZXhwb3J0IGRlZmF1bHQgdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gJ3VuZGVmaW5lZCcgPyBVUkxTZWFyY2hQYXJhbXMgOiBBeGlvc1VSTFNlYXJjaFBhcmFtcztcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0IGRlZmF1bHQgdHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJyA/IEZvcm1EYXRhIDogbnVsbDtcbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnQgZGVmYXVsdCB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgPyBCbG9iIDogbnVsbFxuIiwiaW1wb3J0IFVSTFNlYXJjaFBhcmFtcyBmcm9tICcuL2NsYXNzZXMvVVJMU2VhcmNoUGFyYW1zLmpzJ1xuaW1wb3J0IEZvcm1EYXRhIGZyb20gJy4vY2xhc3Nlcy9Gb3JtRGF0YS5qcydcbmltcG9ydCBCbG9iIGZyb20gJy4vY2xhc3Nlcy9CbG9iLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlzQnJvd3NlcjogdHJ1ZSxcbiAgY2xhc3Nlczoge1xuICAgIFVSTFNlYXJjaFBhcmFtcyxcbiAgICBGb3JtRGF0YSxcbiAgICBCbG9iXG4gIH0sXG4gIHByb3RvY29sczogWydodHRwJywgJ2h0dHBzJywgJ2ZpbGUnLCAnYmxvYicsICd1cmwnLCAnZGF0YSddXG59O1xuIiwiY29uc3QgaGFzQnJvd3NlckVudiA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50XG4gKlxuICogVGhpcyBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlciwgYW5kIHJlYWN0LW5hdGl2ZS5cbiAqIEJvdGggZW52aXJvbm1lbnRzIHN1cHBvcnQgWE1MSHR0cFJlcXVlc3QsIGJ1dCBub3QgZnVsbHkgc3RhbmRhcmQgZ2xvYmFscy5cbiAqXG4gKiB3ZWIgd29ya2VyczpcbiAqICB0eXBlb2Ygd2luZG93IC0+IHVuZGVmaW5lZFxuICogIHR5cGVvZiBkb2N1bWVudCAtPiB1bmRlZmluZWRcbiAqXG4gKiByZWFjdC1uYXRpdmU6XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ1JlYWN0TmF0aXZlJ1xuICogbmF0aXZlc2NyaXB0XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ05hdGl2ZVNjcmlwdCcgb3IgJ05TJ1xuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBoYXNTdGFuZGFyZEJyb3dzZXJFbnYgPSAoXG4gIChwcm9kdWN0KSA9PiB7XG4gICAgcmV0dXJuIGhhc0Jyb3dzZXJFbnYgJiYgWydSZWFjdE5hdGl2ZScsICdOYXRpdmVTY3JpcHQnLCAnTlMnXS5pbmRleE9mKHByb2R1Y3QpIDwgMFxuICB9KSh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IucHJvZHVjdCk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIHdlYldvcmtlciBlbnZpcm9ubWVudFxuICpcbiAqIEFsdGhvdWdoIHRoZSBgaXNTdGFuZGFyZEJyb3dzZXJFbnZgIG1ldGhvZCBpbmRpY2F0ZXMgdGhhdFxuICogYGFsbG93cyBheGlvcyB0byBydW4gaW4gYSB3ZWIgd29ya2VyYCwgdGhlIFdlYldvcmtlciB3aWxsIHN0aWxsIGJlXG4gKiBmaWx0ZXJlZCBvdXQgZHVlIHRvIGl0cyBqdWRnbWVudCBzdGFuZGFyZFxuICogYHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdgLlxuICogVGhpcyBsZWFkcyB0byBhIHByb2JsZW0gd2hlbiBheGlvcyBwb3N0IGBGb3JtRGF0YWAgaW4gd2ViV29ya2VyXG4gKi9cbmNvbnN0IGhhc1N0YW5kYXJkQnJvd3NlcldlYldvcmtlckVudiA9ICgoKSA9PiB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSAmJlxuICAgIHR5cGVvZiBzZWxmLmltcG9ydFNjcmlwdHMgPT09ICdmdW5jdGlvbidcbiAgKTtcbn0pKCk7XG5cbmV4cG9ydCB7XG4gIGhhc0Jyb3dzZXJFbnYsXG4gIGhhc1N0YW5kYXJkQnJvd3NlcldlYldvcmtlckVudixcbiAgaGFzU3RhbmRhcmRCcm93c2VyRW52XG59XG4iLCJpbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi9ub2RlL2luZGV4LmpzJztcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4vY29tbW9uL3V0aWxzLmpzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICAuLi51dGlscyxcbiAgLi4ucGxhdGZvcm1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCB0b0Zvcm1EYXRhIGZyb20gJy4vdG9Gb3JtRGF0YS5qcyc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0b1VSTEVuY29kZWRGb3JtKGRhdGEsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRvRm9ybURhdGEoZGF0YSwgbmV3IHBsYXRmb3JtLmNsYXNzZXMuVVJMU2VhcmNoUGFyYW1zKCksIE9iamVjdC5hc3NpZ24oe1xuICAgIHZpc2l0b3I6IGZ1bmN0aW9uKHZhbHVlLCBrZXksIHBhdGgsIGhlbHBlcnMpIHtcbiAgICAgIGlmIChwbGF0Zm9ybS5pc05vZGUgJiYgdXRpbHMuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKGtleSwgdmFsdWUudG9TdHJpbmcoJ2Jhc2U2NCcpKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGVscGVycy5kZWZhdWx0VmlzaXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfSwgb3B0aW9ucykpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuXG4vKipcbiAqIEl0IHRha2VzIGEgc3RyaW5nIGxpa2UgYGZvb1t4XVt5XVt6XWAgYW5kIHJldHVybnMgYW4gYXJyYXkgbGlrZSBgWydmb28nLCAneCcsICd5JywgJ3onXVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBzdHJpbmdzLlxuICovXG5mdW5jdGlvbiBwYXJzZVByb3BQYXRoKG5hbWUpIHtcbiAgLy8gZm9vW3hdW3ldW3pdXG4gIC8vIGZvby54LnkuelxuICAvLyBmb28teC15LXpcbiAgLy8gZm9vIHggeSB6XG4gIHJldHVybiB1dGlscy5tYXRjaEFsbCgvXFx3K3xcXFsoXFx3KildL2csIG5hbWUpLm1hcChtYXRjaCA9PiB7XG4gICAgcmV0dXJuIG1hdGNoWzBdID09PSAnW10nID8gJycgOiBtYXRjaFsxXSB8fCBtYXRjaFswXTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ29udmVydCBhbiBhcnJheSB0byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcnIgLSBUaGUgYXJyYXkgdG8gY29udmVydCB0byBhbiBvYmplY3QuXG4gKlxuICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBhbmQgdmFsdWVzIGFzIHRoZSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlUb09iamVjdChhcnIpIHtcbiAgY29uc3Qgb2JqID0ge307XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhhcnIpO1xuICBsZXQgaTtcbiAgY29uc3QgbGVuID0ga2V5cy5sZW5ndGg7XG4gIGxldCBrZXk7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgb2JqW2tleV0gPSBhcnJba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIEl0IHRha2VzIGEgRm9ybURhdGEgb2JqZWN0IGFuZCByZXR1cm5zIGEgSmF2YVNjcmlwdCBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9ybURhdGEgVGhlIEZvcm1EYXRhIG9iamVjdCB0byBjb252ZXJ0IHRvIEpTT04uXG4gKlxuICogQHJldHVybnMge09iamVjdDxzdHJpbmcsIGFueT4gfCBudWxsfSBUaGUgY29udmVydGVkIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZm9ybURhdGFUb0pTT04oZm9ybURhdGEpIHtcbiAgZnVuY3Rpb24gYnVpbGRQYXRoKHBhdGgsIHZhbHVlLCB0YXJnZXQsIGluZGV4KSB7XG4gICAgbGV0IG5hbWUgPSBwYXRoW2luZGV4KytdO1xuICAgIGNvbnN0IGlzTnVtZXJpY0tleSA9IE51bWJlci5pc0Zpbml0ZSgrbmFtZSk7XG4gICAgY29uc3QgaXNMYXN0ID0gaW5kZXggPj0gcGF0aC5sZW5ndGg7XG4gICAgbmFtZSA9ICFuYW1lICYmIHV0aWxzLmlzQXJyYXkodGFyZ2V0KSA/IHRhcmdldC5sZW5ndGggOiBuYW1lO1xuXG4gICAgaWYgKGlzTGFzdCkge1xuICAgICAgaWYgKHV0aWxzLmhhc093blByb3AodGFyZ2V0LCBuYW1lKSkge1xuICAgICAgICB0YXJnZXRbbmFtZV0gPSBbdGFyZ2V0W25hbWVdLCB2YWx1ZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICFpc051bWVyaWNLZXk7XG4gICAgfVxuXG4gICAgaWYgKCF0YXJnZXRbbmFtZV0gfHwgIXV0aWxzLmlzT2JqZWN0KHRhcmdldFtuYW1lXSkpIHtcbiAgICAgIHRhcmdldFtuYW1lXSA9IFtdO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IGJ1aWxkUGF0aChwYXRoLCB2YWx1ZSwgdGFyZ2V0W25hbWVdLCBpbmRleCk7XG5cbiAgICBpZiAocmVzdWx0ICYmIHV0aWxzLmlzQXJyYXkodGFyZ2V0W25hbWVdKSkge1xuICAgICAgdGFyZ2V0W25hbWVdID0gYXJyYXlUb09iamVjdCh0YXJnZXRbbmFtZV0pO1xuICAgIH1cblxuICAgIHJldHVybiAhaXNOdW1lcmljS2V5O1xuICB9XG5cbiAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZm9ybURhdGEpICYmIHV0aWxzLmlzRnVuY3Rpb24oZm9ybURhdGEuZW50cmllcykpIHtcbiAgICBjb25zdCBvYmogPSB7fTtcblxuICAgIHV0aWxzLmZvckVhY2hFbnRyeShmb3JtRGF0YSwgKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICBidWlsZFBhdGgocGFyc2VQcm9wUGF0aChuYW1lKSwgdmFsdWUsIG9iaiwgMCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZvcm1EYXRhVG9KU09OO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSAnLi4vY29yZS9BeGlvc0Vycm9yLmpzJztcbmltcG9ydCB0cmFuc2l0aW9uYWxEZWZhdWx0cyBmcm9tICcuL3RyYW5zaXRpb25hbC5qcyc7XG5pbXBvcnQgdG9Gb3JtRGF0YSBmcm9tICcuLi9oZWxwZXJzL3RvRm9ybURhdGEuanMnO1xuaW1wb3J0IHRvVVJMRW5jb2RlZEZvcm0gZnJvbSAnLi4vaGVscGVycy90b1VSTEVuY29kZWRGb3JtLmpzJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybS9pbmRleC5qcyc7XG5pbXBvcnQgZm9ybURhdGFUb0pTT04gZnJvbSAnLi4vaGVscGVycy9mb3JtRGF0YVRvSlNPTi5qcyc7XG5cbi8qKlxuICogSXQgdGFrZXMgYSBzdHJpbmcsIHRyaWVzIHRvIHBhcnNlIGl0LCBhbmQgaWYgaXQgZmFpbHMsIGl0IHJldHVybnMgdGhlIHN0cmluZ2lmaWVkIHZlcnNpb25cbiAqIG9mIHRoZSBpbnB1dFxuICpcbiAqIEBwYXJhbSB7YW55fSByYXdWYWx1ZSAtIFRoZSB2YWx1ZSB0byBiZSBzdHJpbmdpZmllZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBhcnNlciAtIEEgZnVuY3Rpb24gdGhhdCBwYXJzZXMgYSBzdHJpbmcgaW50byBhIEphdmFTY3JpcHQgb2JqZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZW5jb2RlciAtIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHZhbHVlIGFuZCByZXR1cm5zIGEgc3RyaW5nLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgc3RyaW5naWZpZWQgdmVyc2lvbiBvZiB0aGUgcmF3VmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeVNhZmVseShyYXdWYWx1ZSwgcGFyc2VyLCBlbmNvZGVyKSB7XG4gIGlmICh1dGlscy5pc1N0cmluZyhyYXdWYWx1ZSkpIHtcbiAgICB0cnkge1xuICAgICAgKHBhcnNlciB8fCBKU09OLnBhcnNlKShyYXdWYWx1ZSk7XG4gICAgICByZXR1cm4gdXRpbHMudHJpbShyYXdWYWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUubmFtZSAhPT0gJ1N5bnRheEVycm9yJykge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoZW5jb2RlciB8fCBKU09OLnN0cmluZ2lmeSkocmF3VmFsdWUpO1xufVxuXG5jb25zdCBkZWZhdWx0cyA9IHtcblxuICB0cmFuc2l0aW9uYWw6IHRyYW5zaXRpb25hbERlZmF1bHRzLFxuXG4gIGFkYXB0ZXI6IFsneGhyJywgJ2h0dHAnXSxcblxuICB0cmFuc2Zvcm1SZXF1ZXN0OiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVxdWVzdChkYXRhLCBoZWFkZXJzKSB7XG4gICAgY29uc3QgY29udGVudFR5cGUgPSBoZWFkZXJzLmdldENvbnRlbnRUeXBlKCkgfHwgJyc7XG4gICAgY29uc3QgaGFzSlNPTkNvbnRlbnRUeXBlID0gY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24vanNvbicpID4gLTE7XG4gICAgY29uc3QgaXNPYmplY3RQYXlsb2FkID0gdXRpbHMuaXNPYmplY3QoZGF0YSk7XG5cbiAgICBpZiAoaXNPYmplY3RQYXlsb2FkICYmIHV0aWxzLmlzSFRNTEZvcm0oZGF0YSkpIHtcbiAgICAgIGRhdGEgPSBuZXcgRm9ybURhdGEoZGF0YSk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNGb3JtRGF0YSA9IHV0aWxzLmlzRm9ybURhdGEoZGF0YSk7XG5cbiAgICBpZiAoaXNGb3JtRGF0YSkge1xuICAgICAgaWYgKCFoYXNKU09OQ29udGVudFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzSlNPTkNvbnRlbnRUeXBlID8gSlNPTi5zdHJpbmdpZnkoZm9ybURhdGFUb0pTT04oZGF0YSkpIDogZGF0YTtcbiAgICB9XG5cbiAgICBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzU3RyZWFtKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0ZpbGUoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQmxvYihkYXRhKVxuICAgICkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyVmlldyhkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGEuYnVmZmVyO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMoZGF0YSkpIHtcbiAgICAgIGhlYWRlcnMuc2V0Q29udGVudFR5cGUoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PXV0Zi04JywgZmFsc2UpO1xuICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBsZXQgaXNGaWxlTGlzdDtcblxuICAgIGlmIChpc09iamVjdFBheWxvYWQpIHtcbiAgICAgIGlmIChjb250ZW50VHlwZS5pbmRleE9mKCdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiB0b1VSTEVuY29kZWRGb3JtKGRhdGEsIHRoaXMuZm9ybVNlcmlhbGl6ZXIpLnRvU3RyaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICgoaXNGaWxlTGlzdCA9IHV0aWxzLmlzRmlsZUxpc3QoZGF0YSkpIHx8IGNvbnRlbnRUeXBlLmluZGV4T2YoJ211bHRpcGFydC9mb3JtLWRhdGEnKSA+IC0xKSB7XG4gICAgICAgIGNvbnN0IF9Gb3JtRGF0YSA9IHRoaXMuZW52ICYmIHRoaXMuZW52LkZvcm1EYXRhO1xuXG4gICAgICAgIHJldHVybiB0b0Zvcm1EYXRhKFxuICAgICAgICAgIGlzRmlsZUxpc3QgPyB7J2ZpbGVzW10nOiBkYXRhfSA6IGRhdGEsXG4gICAgICAgICAgX0Zvcm1EYXRhICYmIG5ldyBfRm9ybURhdGEoKSxcbiAgICAgICAgICB0aGlzLmZvcm1TZXJpYWxpemVyXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzT2JqZWN0UGF5bG9hZCB8fCBoYXNKU09OQ29udGVudFR5cGUgKSB7XG4gICAgICBoZWFkZXJzLnNldENvbnRlbnRUeXBlKCdhcHBsaWNhdGlvbi9qc29uJywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHN0cmluZ2lmeVNhZmVseShkYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgdHJhbnNmb3JtUmVzcG9uc2U6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXNwb25zZShkYXRhKSB7XG4gICAgY29uc3QgdHJhbnNpdGlvbmFsID0gdGhpcy50cmFuc2l0aW9uYWwgfHwgZGVmYXVsdHMudHJhbnNpdGlvbmFsO1xuICAgIGNvbnN0IGZvcmNlZEpTT05QYXJzaW5nID0gdHJhbnNpdGlvbmFsICYmIHRyYW5zaXRpb25hbC5mb3JjZWRKU09OUGFyc2luZztcbiAgICBjb25zdCBKU09OUmVxdWVzdGVkID0gdGhpcy5yZXNwb25zZVR5cGUgPT09ICdqc29uJztcblxuICAgIGlmIChkYXRhICYmIHV0aWxzLmlzU3RyaW5nKGRhdGEpICYmICgoZm9yY2VkSlNPTlBhcnNpbmcgJiYgIXRoaXMucmVzcG9uc2VUeXBlKSB8fCBKU09OUmVxdWVzdGVkKSkge1xuICAgICAgY29uc3Qgc2lsZW50SlNPTlBhcnNpbmcgPSB0cmFuc2l0aW9uYWwgJiYgdHJhbnNpdGlvbmFsLnNpbGVudEpTT05QYXJzaW5nO1xuICAgICAgY29uc3Qgc3RyaWN0SlNPTlBhcnNpbmcgPSAhc2lsZW50SlNPTlBhcnNpbmcgJiYgSlNPTlJlcXVlc3RlZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChzdHJpY3RKU09OUGFyc2luZykge1xuICAgICAgICAgIGlmIChlLm5hbWUgPT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgICAgIHRocm93IEF4aW9zRXJyb3IuZnJvbShlLCBBeGlvc0Vycm9yLkVSUl9CQURfUkVTUE9OU0UsIHRoaXMsIG51bGwsIHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIC8qKlxuICAgKiBBIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIGFib3J0IGEgcmVxdWVzdC4gSWYgc2V0IHRvIDAgKGRlZmF1bHQpIGFcbiAgICogdGltZW91dCBpcyBub3QgY3JlYXRlZC5cbiAgICovXG4gIHRpbWVvdXQ6IDAsXG5cbiAgeHNyZkNvb2tpZU5hbWU6ICdYU1JGLVRPS0VOJyxcbiAgeHNyZkhlYWRlck5hbWU6ICdYLVhTUkYtVE9LRU4nLFxuXG4gIG1heENvbnRlbnRMZW5ndGg6IC0xLFxuICBtYXhCb2R5TGVuZ3RoOiAtMSxcblxuICBlbnY6IHtcbiAgICBGb3JtRGF0YTogcGxhdGZvcm0uY2xhc3Nlcy5Gb3JtRGF0YSxcbiAgICBCbG9iOiBwbGF0Zm9ybS5jbGFzc2VzLkJsb2JcbiAgfSxcblxuICB2YWxpZGF0ZVN0YXR1czogZnVuY3Rpb24gdmFsaWRhdGVTdGF0dXMoc3RhdHVzKSB7XG4gICAgcmV0dXJuIHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwO1xuICB9LFxuXG4gIGhlYWRlcnM6IHtcbiAgICBjb21tb246IHtcbiAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJyxcbiAgICAgICdDb250ZW50LVR5cGUnOiB1bmRlZmluZWRcbiAgICB9XG4gIH1cbn07XG5cbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgKG1ldGhvZCkgPT4ge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB7fTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZhdWx0cztcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuXG4vLyBSYXdBeGlvc0hlYWRlcnMgd2hvc2UgZHVwbGljYXRlcyBhcmUgaWdub3JlZCBieSBub2RlXG4vLyBjLmYuIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJzXG5jb25zdCBpZ25vcmVEdXBsaWNhdGVPZiA9IHV0aWxzLnRvT2JqZWN0U2V0KFtcbiAgJ2FnZScsICdhdXRob3JpemF0aW9uJywgJ2NvbnRlbnQtbGVuZ3RoJywgJ2NvbnRlbnQtdHlwZScsICdldGFnJyxcbiAgJ2V4cGlyZXMnLCAnZnJvbScsICdob3N0JywgJ2lmLW1vZGlmaWVkLXNpbmNlJywgJ2lmLXVubW9kaWZpZWQtc2luY2UnLFxuICAnbGFzdC1tb2RpZmllZCcsICdsb2NhdGlvbicsICdtYXgtZm9yd2FyZHMnLCAncHJveHktYXV0aG9yaXphdGlvbicsXG4gICdyZWZlcmVyJywgJ3JldHJ5LWFmdGVyJywgJ3VzZXItYWdlbnQnXG5dKTtcblxuLyoqXG4gKiBQYXJzZSBoZWFkZXJzIGludG8gYW4gb2JqZWN0XG4gKlxuICogYGBgXG4gKiBEYXRlOiBXZWQsIDI3IEF1ZyAyMDE0IDA4OjU4OjQ5IEdNVFxuICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXG4gKiBDb25uZWN0aW9uOiBrZWVwLWFsaXZlXG4gKiBUcmFuc2Zlci1FbmNvZGluZzogY2h1bmtlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJhd0hlYWRlcnMgSGVhZGVycyBuZWVkaW5nIHRvIGJlIHBhcnNlZFxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IEhlYWRlcnMgcGFyc2VkIGludG8gYW4gb2JqZWN0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHJhd0hlYWRlcnMgPT4ge1xuICBjb25zdCBwYXJzZWQgPSB7fTtcbiAgbGV0IGtleTtcbiAgbGV0IHZhbDtcbiAgbGV0IGk7XG5cbiAgcmF3SGVhZGVycyAmJiByYXdIZWFkZXJzLnNwbGl0KCdcXG4nKS5mb3JFYWNoKGZ1bmN0aW9uIHBhcnNlcihsaW5lKSB7XG4gICAgaSA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGtleSA9IGxpbmUuc3Vic3RyaW5nKDAsIGkpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IGxpbmUuc3Vic3RyaW5nKGkgKyAxKS50cmltKCk7XG5cbiAgICBpZiAoIWtleSB8fCAocGFyc2VkW2tleV0gJiYgaWdub3JlRHVwbGljYXRlT2Zba2V5XSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgIGlmIChwYXJzZWRba2V5XSkge1xuICAgICAgICBwYXJzZWRba2V5XS5wdXNoKHZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWRba2V5XSA9IFt2YWxdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJzZWRba2V5XSA9IHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gKyAnLCAnICsgdmFsIDogdmFsO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgcGFyc2VIZWFkZXJzIGZyb20gJy4uL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzJztcblxuY29uc3QgJGludGVybmFscyA9IFN5bWJvbCgnaW50ZXJuYWxzJyk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlcihoZWFkZXIpIHtcbiAgcmV0dXJuIGhlYWRlciAmJiBTdHJpbmcoaGVhZGVyKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHV0aWxzLmlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKG5vcm1hbGl6ZVZhbHVlKSA6IFN0cmluZyh2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVG9rZW5zKHN0cikge1xuICBjb25zdCB0b2tlbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCB0b2tlbnNSRSA9IC8oW15cXHMsOz1dKylcXHMqKD86PVxccyooW14sO10rKSk/L2c7XG4gIGxldCBtYXRjaDtcblxuICB3aGlsZSAoKG1hdGNoID0gdG9rZW5zUkUuZXhlYyhzdHIpKSkge1xuICAgIHRva2Vuc1ttYXRjaFsxXV0gPSBtYXRjaFsyXTtcbiAgfVxuXG4gIHJldHVybiB0b2tlbnM7XG59XG5cbmNvbnN0IGlzVmFsaWRIZWFkZXJOYW1lID0gKHN0cikgPT4gL15bLV9hLXpBLVowLTleYHx+LCEjJCUmJyorLl0rJC8udGVzdChzdHIudHJpbSgpKTtcblxuZnVuY3Rpb24gbWF0Y2hIZWFkZXJWYWx1ZShjb250ZXh0LCB2YWx1ZSwgaGVhZGVyLCBmaWx0ZXIsIGlzSGVhZGVyTmFtZUZpbHRlcikge1xuICBpZiAodXRpbHMuaXNGdW5jdGlvbihmaWx0ZXIpKSB7XG4gICAgcmV0dXJuIGZpbHRlci5jYWxsKHRoaXMsIHZhbHVlLCBoZWFkZXIpO1xuICB9XG5cbiAgaWYgKGlzSGVhZGVyTmFtZUZpbHRlcikge1xuICAgIHZhbHVlID0gaGVhZGVyO1xuICB9XG5cbiAgaWYgKCF1dGlscy5pc1N0cmluZyh2YWx1ZSkpIHJldHVybjtcblxuICBpZiAodXRpbHMuaXNTdHJpbmcoZmlsdGVyKSkge1xuICAgIHJldHVybiB2YWx1ZS5pbmRleE9mKGZpbHRlcikgIT09IC0xO1xuICB9XG5cbiAgaWYgKHV0aWxzLmlzUmVnRXhwKGZpbHRlcikpIHtcbiAgICByZXR1cm4gZmlsdGVyLnRlc3QodmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEhlYWRlcihoZWFkZXIpIHtcbiAgcmV0dXJuIGhlYWRlci50cmltKClcbiAgICAudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8oW2EtelxcZF0pKFxcdyopL2csICh3LCBjaGFyLCBzdHIpID0+IHtcbiAgICAgIHJldHVybiBjaGFyLnRvVXBwZXJDYXNlKCkgKyBzdHI7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkQWNjZXNzb3JzKG9iaiwgaGVhZGVyKSB7XG4gIGNvbnN0IGFjY2Vzc29yTmFtZSA9IHV0aWxzLnRvQ2FtZWxDYXNlKCcgJyArIGhlYWRlcik7XG5cbiAgWydnZXQnLCAnc2V0JywgJ2hhcyddLmZvckVhY2gobWV0aG9kTmFtZSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgbWV0aG9kTmFtZSArIGFjY2Vzc29yTmFtZSwge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbbWV0aG9kTmFtZV0uY2FsbCh0aGlzLCBoZWFkZXIsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgICAgfSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9KTtcbn1cblxuY2xhc3MgQXhpb3NIZWFkZXJzIHtcbiAgY29uc3RydWN0b3IoaGVhZGVycykge1xuICAgIGhlYWRlcnMgJiYgdGhpcy5zZXQoaGVhZGVycyk7XG4gIH1cblxuICBzZXQoaGVhZGVyLCB2YWx1ZU9yUmV3cml0ZSwgcmV3cml0ZSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gc2V0SGVhZGVyKF92YWx1ZSwgX2hlYWRlciwgX3Jld3JpdGUpIHtcbiAgICAgIGNvbnN0IGxIZWFkZXIgPSBub3JtYWxpemVIZWFkZXIoX2hlYWRlcik7XG5cbiAgICAgIGlmICghbEhlYWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hlYWRlciBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGtleSA9IHV0aWxzLmZpbmRLZXkoc2VsZiwgbEhlYWRlcik7XG5cbiAgICAgIGlmKCFrZXkgfHwgc2VsZltrZXldID09PSB1bmRlZmluZWQgfHwgX3Jld3JpdGUgPT09IHRydWUgfHwgKF9yZXdyaXRlID09PSB1bmRlZmluZWQgJiYgc2VsZltrZXldICE9PSBmYWxzZSkpIHtcbiAgICAgICAgc2VsZltrZXkgfHwgX2hlYWRlcl0gPSBub3JtYWxpemVWYWx1ZShfdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNldEhlYWRlcnMgPSAoaGVhZGVycywgX3Jld3JpdGUpID0+XG4gICAgICB1dGlscy5mb3JFYWNoKGhlYWRlcnMsIChfdmFsdWUsIF9oZWFkZXIpID0+IHNldEhlYWRlcihfdmFsdWUsIF9oZWFkZXIsIF9yZXdyaXRlKSk7XG5cbiAgICBpZiAodXRpbHMuaXNQbGFpbk9iamVjdChoZWFkZXIpIHx8IGhlYWRlciBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3IpIHtcbiAgICAgIHNldEhlYWRlcnMoaGVhZGVyLCB2YWx1ZU9yUmV3cml0ZSlcbiAgICB9IGVsc2UgaWYodXRpbHMuaXNTdHJpbmcoaGVhZGVyKSAmJiAoaGVhZGVyID0gaGVhZGVyLnRyaW0oKSkgJiYgIWlzVmFsaWRIZWFkZXJOYW1lKGhlYWRlcikpIHtcbiAgICAgIHNldEhlYWRlcnMocGFyc2VIZWFkZXJzKGhlYWRlciksIHZhbHVlT3JSZXdyaXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZGVyICE9IG51bGwgJiYgc2V0SGVhZGVyKHZhbHVlT3JSZXdyaXRlLCBoZWFkZXIsIHJld3JpdGUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0KGhlYWRlciwgcGFyc2VyKSB7XG4gICAgaGVhZGVyID0gbm9ybWFsaXplSGVhZGVyKGhlYWRlcik7XG5cbiAgICBpZiAoaGVhZGVyKSB7XG4gICAgICBjb25zdCBrZXkgPSB1dGlscy5maW5kS2V5KHRoaXMsIGhlYWRlcik7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzW2tleV07XG5cbiAgICAgICAgaWYgKCFwYXJzZXIpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyc2VyID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5zKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKHBhcnNlcikpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VyLmNhbGwodGhpcywgdmFsdWUsIGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNSZWdFeHAocGFyc2VyKSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZXIuZXhlYyh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJzZXIgbXVzdCBiZSBib29sZWFufHJlZ2V4cHxmdW5jdGlvbicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhcyhoZWFkZXIsIG1hdGNoZXIpIHtcbiAgICBoZWFkZXIgPSBub3JtYWxpemVIZWFkZXIoaGVhZGVyKTtcblxuICAgIGlmIChoZWFkZXIpIHtcbiAgICAgIGNvbnN0IGtleSA9IHV0aWxzLmZpbmRLZXkodGhpcywgaGVhZGVyKTtcblxuICAgICAgcmV0dXJuICEhKGtleSAmJiB0aGlzW2tleV0gIT09IHVuZGVmaW5lZCAmJiAoIW1hdGNoZXIgfHwgbWF0Y2hIZWFkZXJWYWx1ZSh0aGlzLCB0aGlzW2tleV0sIGtleSwgbWF0Y2hlcikpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBkZWxldGUoaGVhZGVyLCBtYXRjaGVyKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgbGV0IGRlbGV0ZWQgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIGRlbGV0ZUhlYWRlcihfaGVhZGVyKSB7XG4gICAgICBfaGVhZGVyID0gbm9ybWFsaXplSGVhZGVyKF9oZWFkZXIpO1xuXG4gICAgICBpZiAoX2hlYWRlcikge1xuICAgICAgICBjb25zdCBrZXkgPSB1dGlscy5maW5kS2V5KHNlbGYsIF9oZWFkZXIpO1xuXG4gICAgICAgIGlmIChrZXkgJiYgKCFtYXRjaGVyIHx8IG1hdGNoSGVhZGVyVmFsdWUoc2VsZiwgc2VsZltrZXldLCBrZXksIG1hdGNoZXIpKSkge1xuICAgICAgICAgIGRlbGV0ZSBzZWxmW2tleV07XG5cbiAgICAgICAgICBkZWxldGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh1dGlscy5pc0FycmF5KGhlYWRlcikpIHtcbiAgICAgIGhlYWRlci5mb3JFYWNoKGRlbGV0ZUhlYWRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZUhlYWRlcihoZWFkZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWxldGVkO1xuICB9XG5cbiAgY2xlYXIobWF0Y2hlcikge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgICBsZXQgaSA9IGtleXMubGVuZ3RoO1xuICAgIGxldCBkZWxldGVkID0gZmFsc2U7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYoIW1hdGNoZXIgfHwgbWF0Y2hIZWFkZXJWYWx1ZSh0aGlzLCB0aGlzW2tleV0sIGtleSwgbWF0Y2hlciwgdHJ1ZSkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXNba2V5XTtcbiAgICAgICAgZGVsZXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlbGV0ZWQ7XG4gIH1cblxuICBub3JtYWxpemUoZm9ybWF0KSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3QgaGVhZGVycyA9IHt9O1xuXG4gICAgdXRpbHMuZm9yRWFjaCh0aGlzLCAodmFsdWUsIGhlYWRlcikgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gdXRpbHMuZmluZEtleShoZWFkZXJzLCBoZWFkZXIpO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHNlbGZba2V5XSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgZGVsZXRlIHNlbGZbaGVhZGVyXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBub3JtYWxpemVkID0gZm9ybWF0ID8gZm9ybWF0SGVhZGVyKGhlYWRlcikgOiBTdHJpbmcoaGVhZGVyKS50cmltKCk7XG5cbiAgICAgIGlmIChub3JtYWxpemVkICE9PSBoZWFkZXIpIHtcbiAgICAgICAgZGVsZXRlIHNlbGZbaGVhZGVyXTtcbiAgICAgIH1cblxuICAgICAgc2VsZltub3JtYWxpemVkXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcblxuICAgICAgaGVhZGVyc1tub3JtYWxpemVkXSA9IHRydWU7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGNvbmNhdCguLi50YXJnZXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuY29uY2F0KHRoaXMsIC4uLnRhcmdldHMpO1xuICB9XG5cbiAgdG9KU09OKGFzU3RyaW5ncykge1xuICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICB1dGlscy5mb3JFYWNoKHRoaXMsICh2YWx1ZSwgaGVhZGVyKSA9PiB7XG4gICAgICB2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSBmYWxzZSAmJiAob2JqW2hlYWRlcl0gPSBhc1N0cmluZ3MgJiYgdXRpbHMuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5qb2luKCcsICcpIDogdmFsdWUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyh0aGlzLnRvSlNPTigpKVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXModGhpcy50b0pTT04oKSkubWFwKChbaGVhZGVyLCB2YWx1ZV0pID0+IGhlYWRlciArICc6ICcgKyB2YWx1ZSkuam9pbignXFxuJyk7XG4gIH1cblxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuICdBeGlvc0hlYWRlcnMnO1xuICB9XG5cbiAgc3RhdGljIGZyb20odGhpbmcpIHtcbiAgICByZXR1cm4gdGhpbmcgaW5zdGFuY2VvZiB0aGlzID8gdGhpbmcgOiBuZXcgdGhpcyh0aGluZyk7XG4gIH1cblxuICBzdGF0aWMgY29uY2F0KGZpcnN0LCAuLi50YXJnZXRzKSB7XG4gICAgY29uc3QgY29tcHV0ZWQgPSBuZXcgdGhpcyhmaXJzdCk7XG5cbiAgICB0YXJnZXRzLmZvckVhY2goKHRhcmdldCkgPT4gY29tcHV0ZWQuc2V0KHRhcmdldCkpO1xuXG4gICAgcmV0dXJuIGNvbXB1dGVkO1xuICB9XG5cbiAgc3RhdGljIGFjY2Vzc29yKGhlYWRlcikge1xuICAgIGNvbnN0IGludGVybmFscyA9IHRoaXNbJGludGVybmFsc10gPSAodGhpc1skaW50ZXJuYWxzXSA9IHtcbiAgICAgIGFjY2Vzc29yczoge31cbiAgICB9KTtcblxuICAgIGNvbnN0IGFjY2Vzc29ycyA9IGludGVybmFscy5hY2Nlc3NvcnM7XG4gICAgY29uc3QgcHJvdG90eXBlID0gdGhpcy5wcm90b3R5cGU7XG5cbiAgICBmdW5jdGlvbiBkZWZpbmVBY2Nlc3NvcihfaGVhZGVyKSB7XG4gICAgICBjb25zdCBsSGVhZGVyID0gbm9ybWFsaXplSGVhZGVyKF9oZWFkZXIpO1xuXG4gICAgICBpZiAoIWFjY2Vzc29yc1tsSGVhZGVyXSkge1xuICAgICAgICBidWlsZEFjY2Vzc29ycyhwcm90b3R5cGUsIF9oZWFkZXIpO1xuICAgICAgICBhY2Nlc3NvcnNbbEhlYWRlcl0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHV0aWxzLmlzQXJyYXkoaGVhZGVyKSA/IGhlYWRlci5mb3JFYWNoKGRlZmluZUFjY2Vzc29yKSA6IGRlZmluZUFjY2Vzc29yKGhlYWRlcik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5BeGlvc0hlYWRlcnMuYWNjZXNzb3IoWydDb250ZW50LVR5cGUnLCAnQ29udGVudC1MZW5ndGgnLCAnQWNjZXB0JywgJ0FjY2VwdC1FbmNvZGluZycsICdVc2VyLUFnZW50JywgJ0F1dGhvcml6YXRpb24nXSk7XG5cbi8vIHJlc2VydmVkIG5hbWVzIGhvdGZpeFxudXRpbHMucmVkdWNlRGVzY3JpcHRvcnMoQXhpb3NIZWFkZXJzLnByb3RvdHlwZSwgKHt2YWx1ZX0sIGtleSkgPT4ge1xuICBsZXQgbWFwcGVkID0ga2V5WzBdLnRvVXBwZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSk7IC8vIG1hcCBgc2V0YCA9PiBgU2V0YFxuICByZXR1cm4ge1xuICAgIGdldDogKCkgPT4gdmFsdWUsXG4gICAgc2V0KGhlYWRlclZhbHVlKSB7XG4gICAgICB0aGlzW21hcHBlZF0gPSBoZWFkZXJWYWx1ZTtcbiAgICB9XG4gIH1cbn0pO1xuXG51dGlscy5mcmVlemVNZXRob2RzKEF4aW9zSGVhZGVycyk7XG5cbmV4cG9ydCBkZWZhdWx0IEF4aW9zSGVhZGVycztcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuaW1wb3J0IGRlZmF1bHRzIGZyb20gJy4uL2RlZmF1bHRzL2luZGV4LmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSAnLi4vY29yZS9BeGlvc0hlYWRlcnMuanMnO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgZGF0YSBmb3IgYSByZXF1ZXN0IG9yIGEgcmVzcG9uc2VcbiAqXG4gKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufSBmbnMgQSBzaW5nbGUgZnVuY3Rpb24gb3IgQXJyYXkgb2YgZnVuY3Rpb25zXG4gKiBAcGFyYW0gez9PYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZSBvYmplY3RcbiAqXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdGluZyB0cmFuc2Zvcm1lZCBkYXRhXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRyYW5zZm9ybURhdGEoZm5zLCByZXNwb25zZSkge1xuICBjb25zdCBjb25maWcgPSB0aGlzIHx8IGRlZmF1bHRzO1xuICBjb25zdCBjb250ZXh0ID0gcmVzcG9uc2UgfHwgY29uZmlnO1xuICBjb25zdCBoZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20oY29udGV4dC5oZWFkZXJzKTtcbiAgbGV0IGRhdGEgPSBjb250ZXh0LmRhdGE7XG5cbiAgdXRpbHMuZm9yRWFjaChmbnMsIGZ1bmN0aW9uIHRyYW5zZm9ybShmbikge1xuICAgIGRhdGEgPSBmbi5jYWxsKGNvbmZpZywgZGF0YSwgaGVhZGVycy5ub3JtYWxpemUoKSwgcmVzcG9uc2UgPyByZXNwb25zZS5zdGF0dXMgOiB1bmRlZmluZWQpO1xuICB9KTtcblxuICBoZWFkZXJzLm5vcm1hbGl6ZSgpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0NhbmNlbCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4uL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuXG4vKipcbiAqIEEgYENhbmNlbGVkRXJyb3JgIGlzIGFuIG9iamVjdCB0aGF0IGlzIHRocm93biB3aGVuIGFuIG9wZXJhdGlvbiBpcyBjYW5jZWxlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgVGhlIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge09iamVjdD19IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtPYmplY3Q9fSByZXF1ZXN0IFRoZSByZXF1ZXN0LlxuICpcbiAqIEByZXR1cm5zIHtDYW5jZWxlZEVycm9yfSBUaGUgY3JlYXRlZCBlcnJvci5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsZWRFcnJvcihtZXNzYWdlLCBjb25maWcsIHJlcXVlc3QpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsZXFlcWVxXG4gIEF4aW9zRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlID09IG51bGwgPyAnY2FuY2VsZWQnIDogbWVzc2FnZSwgQXhpb3NFcnJvci5FUlJfQ0FOQ0VMRUQsIGNvbmZpZywgcmVxdWVzdCk7XG4gIHRoaXMubmFtZSA9ICdDYW5jZWxlZEVycm9yJztcbn1cblxudXRpbHMuaW5oZXJpdHMoQ2FuY2VsZWRFcnJvciwgQXhpb3NFcnJvciwge1xuICBfX0NBTkNFTF9fOiB0cnVlXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQ2FuY2VsZWRFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSAnLi9BeGlvc0Vycm9yLmpzJztcblxuLyoqXG4gKiBSZXNvbHZlIG9yIHJlamVjdCBhIFByb21pc2UgYmFzZWQgb24gcmVzcG9uc2Ugc3RhdHVzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgQSBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IEEgZnVuY3Rpb24gdGhhdCByZWplY3RzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZS5cbiAqXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgcmVzcG9uc2UuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKSB7XG4gIGNvbnN0IHZhbGlkYXRlU3RhdHVzID0gcmVzcG9uc2UuY29uZmlnLnZhbGlkYXRlU3RhdHVzO1xuICBpZiAoIXJlc3BvbnNlLnN0YXR1cyB8fCAhdmFsaWRhdGVTdGF0dXMgfHwgdmFsaWRhdGVTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICB9IGVsc2Uge1xuICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcihcbiAgICAgICdSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICcgKyByZXNwb25zZS5zdGF0dXMsXG4gICAgICBbQXhpb3NFcnJvci5FUlJfQkFEX1JFUVVFU1QsIEF4aW9zRXJyb3IuRVJSX0JBRF9SRVNQT05TRV1bTWF0aC5mbG9vcihyZXNwb25zZS5zdGF0dXMgLyAxMDApIC0gNF0sXG4gICAgICByZXNwb25zZS5jb25maWcsXG4gICAgICByZXNwb25zZS5yZXF1ZXN0LFxuICAgICAgcmVzcG9uc2VcbiAgICApKTtcbiAgfVxufVxuIiwiaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3JtL2luZGV4LmpzJztcblxuZXhwb3J0IGRlZmF1bHQgcGxhdGZvcm0uaGFzU3RhbmRhcmRCcm93c2VyRW52ID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgc3VwcG9ydCBkb2N1bWVudC5jb29raWVcbiAge1xuICAgIHdyaXRlKG5hbWUsIHZhbHVlLCBleHBpcmVzLCBwYXRoLCBkb21haW4sIHNlY3VyZSkge1xuICAgICAgY29uc3QgY29va2llID0gW25hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpXTtcblxuICAgICAgdXRpbHMuaXNOdW1iZXIoZXhwaXJlcykgJiYgY29va2llLnB1c2goJ2V4cGlyZXM9JyArIG5ldyBEYXRlKGV4cGlyZXMpLnRvR01UU3RyaW5nKCkpO1xuXG4gICAgICB1dGlscy5pc1N0cmluZyhwYXRoKSAmJiBjb29raWUucHVzaCgncGF0aD0nICsgcGF0aCk7XG5cbiAgICAgIHV0aWxzLmlzU3RyaW5nKGRvbWFpbikgJiYgY29va2llLnB1c2goJ2RvbWFpbj0nICsgZG9tYWluKTtcblxuICAgICAgc2VjdXJlID09PSB0cnVlICYmIGNvb2tpZS5wdXNoKCdzZWN1cmUnKTtcblxuICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLmpvaW4oJzsgJyk7XG4gICAgfSxcblxuICAgIHJlYWQobmFtZSkge1xuICAgICAgY29uc3QgbWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2gobmV3IFJlZ0V4cCgnKF58O1xcXFxzKikoJyArIG5hbWUgKyAnKT0oW147XSopJykpO1xuICAgICAgcmV0dXJuIChtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFszXSkgOiBudWxsKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlKG5hbWUpIHtcbiAgICAgIHRoaXMud3JpdGUobmFtZSwgJycsIERhdGUubm93KCkgLSA4NjQwMDAwMCk7XG4gICAgfVxuICB9XG5cbiAgOlxuXG4gIC8vIE5vbi1zdGFuZGFyZCBicm93c2VyIGVudiAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAge1xuICAgIHdyaXRlKCkge30sXG4gICAgcmVhZCgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgcmVtb3ZlKCkge31cbiAgfTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0Fic29sdXRlVVJMKHVybCkge1xuICAvLyBBIFVSTCBpcyBjb25zaWRlcmVkIGFic29sdXRlIGlmIGl0IGJlZ2lucyB3aXRoIFwiPHNjaGVtZT46Ly9cIiBvciBcIi8vXCIgKHByb3RvY29sLXJlbGF0aXZlIFVSTCkuXG4gIC8vIFJGQyAzOTg2IGRlZmluZXMgc2NoZW1lIG5hbWUgYXMgYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIGJlZ2lubmluZyB3aXRoIGEgbGV0dGVyIGFuZCBmb2xsb3dlZFxuICAvLyBieSBhbnkgY29tYmluYXRpb24gb2YgbGV0dGVycywgZGlnaXRzLCBwbHVzLCBwZXJpb2QsIG9yIGh5cGhlbi5cbiAgcmV0dXJuIC9eKFthLXpdW2EtelxcZCtcXC0uXSo6KT9cXC9cXC8vaS50ZXN0KHVybCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBzcGVjaWZpZWQgVVJMc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0aXZlVVJMIFRoZSByZWxhdGl2ZSBVUkxcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgVVJMXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlbGF0aXZlVVJMKSB7XG4gIHJldHVybiByZWxhdGl2ZVVSTFxuICAgID8gYmFzZVVSTC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIHJlbGF0aXZlVVJMLnJlcGxhY2UoL15cXC8rLywgJycpXG4gICAgOiBiYXNlVVJMO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgaXNBYnNvbHV0ZVVSTCBmcm9tICcuLi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanMnO1xuaW1wb3J0IGNvbWJpbmVVUkxzIGZyb20gJy4uL2hlbHBlcnMvY29tYmluZVVSTHMuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgYmFzZVVSTCB3aXRoIHRoZSByZXF1ZXN0ZWRVUkwsXG4gKiBvbmx5IHdoZW4gdGhlIHJlcXVlc3RlZFVSTCBpcyBub3QgYWxyZWFkeSBhbiBhYnNvbHV0ZSBVUkwuXG4gKiBJZiB0aGUgcmVxdWVzdFVSTCBpcyBhYnNvbHV0ZSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSByZXF1ZXN0ZWRVUkwgdW50b3VjaGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlcXVlc3RlZFVSTCBBYnNvbHV0ZSBvciByZWxhdGl2ZSBVUkwgdG8gY29tYmluZVxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBmdWxsIHBhdGhcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYnVpbGRGdWxsUGF0aChiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpIHtcbiAgaWYgKGJhc2VVUkwgJiYgIWlzQWJzb2x1dGVVUkwocmVxdWVzdGVkVVJMKSkge1xuICAgIHJldHVybiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpO1xuICB9XG4gIHJldHVybiByZXF1ZXN0ZWRVUkw7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybS9pbmRleC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHBsYXRmb3JtLmhhc1N0YW5kYXJkQnJvd3NlckVudiA/XG5cbi8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBoYXZlIGZ1bGwgc3VwcG9ydCBvZiB0aGUgQVBJcyBuZWVkZWQgdG8gdGVzdFxuLy8gd2hldGhlciB0aGUgcmVxdWVzdCBVUkwgaXMgb2YgdGhlIHNhbWUgb3JpZ2luIGFzIGN1cnJlbnQgbG9jYXRpb24uXG4gIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgY29uc3QgbXNpZSA9IC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgY29uc3QgdXJsUGFyc2luZ05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgbGV0IG9yaWdpblVSTDtcblxuICAgIC8qKlxuICAgICogUGFyc2UgYSBVUkwgdG8gZGlzY292ZXIgaXRzIGNvbXBvbmVudHNcbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSBVUkwgdG8gYmUgcGFyc2VkXG4gICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICovXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVVSTCh1cmwpIHtcbiAgICAgIGxldCBocmVmID0gdXJsO1xuXG4gICAgICBpZiAobXNpZSkge1xuICAgICAgICAvLyBJRSBuZWVkcyBhdHRyaWJ1dGUgc2V0IHR3aWNlIHRvIG5vcm1hbGl6ZSBwcm9wZXJ0aWVzXG4gICAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuICAgICAgICBocmVmID0gdXJsUGFyc2luZ05vZGUuaHJlZjtcbiAgICAgIH1cblxuICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG5cbiAgICAgIC8vIHVybFBhcnNpbmdOb2RlIHByb3ZpZGVzIHRoZSBVcmxVdGlscyBpbnRlcmZhY2UgLSBodHRwOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsdXRpbHNcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhyZWY6IHVybFBhcnNpbmdOb2RlLmhyZWYsXG4gICAgICAgIHByb3RvY29sOiB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbCA/IHVybFBhcnNpbmdOb2RlLnByb3RvY29sLnJlcGxhY2UoLzokLywgJycpIDogJycsXG4gICAgICAgIGhvc3Q6IHVybFBhcnNpbmdOb2RlLmhvc3QsXG4gICAgICAgIHNlYXJjaDogdXJsUGFyc2luZ05vZGUuc2VhcmNoID8gdXJsUGFyc2luZ05vZGUuc2VhcmNoLnJlcGxhY2UoL15cXD8vLCAnJykgOiAnJyxcbiAgICAgICAgaGFzaDogdXJsUGFyc2luZ05vZGUuaGFzaCA/IHVybFBhcnNpbmdOb2RlLmhhc2gucmVwbGFjZSgvXiMvLCAnJykgOiAnJyxcbiAgICAgICAgaG9zdG5hbWU6IHVybFBhcnNpbmdOb2RlLmhvc3RuYW1lLFxuICAgICAgICBwb3J0OiB1cmxQYXJzaW5nTm9kZS5wb3J0LFxuICAgICAgICBwYXRobmFtZTogKHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSA/XG4gICAgICAgICAgdXJsUGFyc2luZ05vZGUucGF0aG5hbWUgOlxuICAgICAgICAgICcvJyArIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lXG4gICAgICB9O1xuICAgIH1cblxuICAgIG9yaWdpblVSTCA9IHJlc29sdmVVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuXG4gICAgLyoqXG4gICAgKiBEZXRlcm1pbmUgaWYgYSBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiBhcyB0aGUgY3VycmVudCBsb2NhdGlvblxuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0VVJMIFRoZSBVUkwgdG8gdGVzdFxuICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4sIG90aGVyd2lzZSBmYWxzZVxuICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbihyZXF1ZXN0VVJMKSB7XG4gICAgICBjb25zdCBwYXJzZWQgPSAodXRpbHMuaXNTdHJpbmcocmVxdWVzdFVSTCkpID8gcmVzb2x2ZVVSTChyZXF1ZXN0VVJMKSA6IHJlcXVlc3RVUkw7XG4gICAgICByZXR1cm4gKHBhcnNlZC5wcm90b2NvbCA9PT0gb3JpZ2luVVJMLnByb3RvY29sICYmXG4gICAgICAgICAgcGFyc2VkLmhvc3QgPT09IG9yaWdpblVSTC5ob3N0KTtcbiAgICB9O1xuICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnZzICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4oKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9KSgpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwYXJzZVByb3RvY29sKHVybCkge1xuICBjb25zdCBtYXRjaCA9IC9eKFstK1xcd117MSwyNX0pKDo/XFwvXFwvfDopLy5leGVjKHVybCk7XG4gIHJldHVybiBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDYWxjdWxhdGUgZGF0YSBtYXhSYXRlXG4gKiBAcGFyYW0ge051bWJlcn0gW3NhbXBsZXNDb3VudD0gMTBdXG4gKiBAcGFyYW0ge051bWJlcn0gW21pbj0gMTAwMF1cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gc3BlZWRvbWV0ZXIoc2FtcGxlc0NvdW50LCBtaW4pIHtcbiAgc2FtcGxlc0NvdW50ID0gc2FtcGxlc0NvdW50IHx8IDEwO1xuICBjb25zdCBieXRlcyA9IG5ldyBBcnJheShzYW1wbGVzQ291bnQpO1xuICBjb25zdCB0aW1lc3RhbXBzID0gbmV3IEFycmF5KHNhbXBsZXNDb3VudCk7XG4gIGxldCBoZWFkID0gMDtcbiAgbGV0IHRhaWwgPSAwO1xuICBsZXQgZmlyc3RTYW1wbGVUUztcblxuICBtaW4gPSBtaW4gIT09IHVuZGVmaW5lZCA/IG1pbiA6IDEwMDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHB1c2goY2h1bmtMZW5ndGgpIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuXG4gICAgY29uc3Qgc3RhcnRlZEF0ID0gdGltZXN0YW1wc1t0YWlsXTtcblxuICAgIGlmICghZmlyc3RTYW1wbGVUUykge1xuICAgICAgZmlyc3RTYW1wbGVUUyA9IG5vdztcbiAgICB9XG5cbiAgICBieXRlc1toZWFkXSA9IGNodW5rTGVuZ3RoO1xuICAgIHRpbWVzdGFtcHNbaGVhZF0gPSBub3c7XG5cbiAgICBsZXQgaSA9IHRhaWw7XG4gICAgbGV0IGJ5dGVzQ291bnQgPSAwO1xuXG4gICAgd2hpbGUgKGkgIT09IGhlYWQpIHtcbiAgICAgIGJ5dGVzQ291bnQgKz0gYnl0ZXNbaSsrXTtcbiAgICAgIGkgPSBpICUgc2FtcGxlc0NvdW50O1xuICAgIH1cblxuICAgIGhlYWQgPSAoaGVhZCArIDEpICUgc2FtcGxlc0NvdW50O1xuXG4gICAgaWYgKGhlYWQgPT09IHRhaWwpIHtcbiAgICAgIHRhaWwgPSAodGFpbCArIDEpICUgc2FtcGxlc0NvdW50O1xuICAgIH1cblxuICAgIGlmIChub3cgLSBmaXJzdFNhbXBsZVRTIDwgbWluKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcGFzc2VkID0gc3RhcnRlZEF0ICYmIG5vdyAtIHN0YXJ0ZWRBdDtcblxuICAgIHJldHVybiBwYXNzZWQgPyBNYXRoLnJvdW5kKGJ5dGVzQ291bnQgKiAxMDAwIC8gcGFzc2VkKSA6IHVuZGVmaW5lZDtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3BlZWRvbWV0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcbmltcG9ydCBzZXR0bGUgZnJvbSAnLi8uLi9jb3JlL3NldHRsZS5qcyc7XG5pbXBvcnQgY29va2llcyBmcm9tICcuLy4uL2hlbHBlcnMvY29va2llcy5qcyc7XG5pbXBvcnQgYnVpbGRVUkwgZnJvbSAnLi8uLi9oZWxwZXJzL2J1aWxkVVJMLmpzJztcbmltcG9ydCBidWlsZEZ1bGxQYXRoIGZyb20gJy4uL2NvcmUvYnVpbGRGdWxsUGF0aC5qcyc7XG5pbXBvcnQgaXNVUkxTYW1lT3JpZ2luIGZyb20gJy4vLi4vaGVscGVycy9pc1VSTFNhbWVPcmlnaW4uanMnO1xuaW1wb3J0IHRyYW5zaXRpb25hbERlZmF1bHRzIGZyb20gJy4uL2RlZmF1bHRzL3RyYW5zaXRpb25hbC5qcyc7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuLi9jb3JlL0F4aW9zRXJyb3IuanMnO1xuaW1wb3J0IENhbmNlbGVkRXJyb3IgZnJvbSAnLi4vY2FuY2VsL0NhbmNlbGVkRXJyb3IuanMnO1xuaW1wb3J0IHBhcnNlUHJvdG9jb2wgZnJvbSAnLi4vaGVscGVycy9wYXJzZVByb3RvY29sLmpzJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybS9pbmRleC5qcyc7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gJy4uL2NvcmUvQXhpb3NIZWFkZXJzLmpzJztcbmltcG9ydCBzcGVlZG9tZXRlciBmcm9tICcuLi9oZWxwZXJzL3NwZWVkb21ldGVyLmpzJztcblxuZnVuY3Rpb24gcHJvZ3Jlc3NFdmVudFJlZHVjZXIobGlzdGVuZXIsIGlzRG93bmxvYWRTdHJlYW0pIHtcbiAgbGV0IGJ5dGVzTm90aWZpZWQgPSAwO1xuICBjb25zdCBfc3BlZWRvbWV0ZXIgPSBzcGVlZG9tZXRlcig1MCwgMjUwKTtcblxuICByZXR1cm4gZSA9PiB7XG4gICAgY29uc3QgbG9hZGVkID0gZS5sb2FkZWQ7XG4gICAgY29uc3QgdG90YWwgPSBlLmxlbmd0aENvbXB1dGFibGUgPyBlLnRvdGFsIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHByb2dyZXNzQnl0ZXMgPSBsb2FkZWQgLSBieXRlc05vdGlmaWVkO1xuICAgIGNvbnN0IHJhdGUgPSBfc3BlZWRvbWV0ZXIocHJvZ3Jlc3NCeXRlcyk7XG4gICAgY29uc3QgaW5SYW5nZSA9IGxvYWRlZCA8PSB0b3RhbDtcblxuICAgIGJ5dGVzTm90aWZpZWQgPSBsb2FkZWQ7XG5cbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgbG9hZGVkLFxuICAgICAgdG90YWwsXG4gICAgICBwcm9ncmVzczogdG90YWwgPyAobG9hZGVkIC8gdG90YWwpIDogdW5kZWZpbmVkLFxuICAgICAgYnl0ZXM6IHByb2dyZXNzQnl0ZXMsXG4gICAgICByYXRlOiByYXRlID8gcmF0ZSA6IHVuZGVmaW5lZCxcbiAgICAgIGVzdGltYXRlZDogcmF0ZSAmJiB0b3RhbCAmJiBpblJhbmdlID8gKHRvdGFsIC0gbG9hZGVkKSAvIHJhdGUgOiB1bmRlZmluZWQsXG4gICAgICBldmVudDogZVxuICAgIH07XG5cbiAgICBkYXRhW2lzRG93bmxvYWRTdHJlYW0gPyAnZG93bmxvYWQnIDogJ3VwbG9hZCddID0gdHJ1ZTtcblxuICAgIGxpc3RlbmVyKGRhdGEpO1xuICB9O1xufVxuXG5jb25zdCBpc1hIUkFkYXB0ZXJTdXBwb3J0ZWQgPSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnO1xuXG5leHBvcnQgZGVmYXVsdCBpc1hIUkFkYXB0ZXJTdXBwb3J0ZWQgJiYgZnVuY3Rpb24gKGNvbmZpZykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZGlzcGF0Y2hYaHJSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xuICAgIGxldCByZXF1ZXN0RGF0YSA9IGNvbmZpZy5kYXRhO1xuICAgIGNvbnN0IHJlcXVlc3RIZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20oY29uZmlnLmhlYWRlcnMpLm5vcm1hbGl6ZSgpO1xuICAgIGxldCB7cmVzcG9uc2VUeXBlLCB3aXRoWFNSRlRva2VufSA9IGNvbmZpZztcbiAgICBsZXQgb25DYW5jZWxlZDtcbiAgICBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgICAgICBjb25maWcuY2FuY2VsVG9rZW4udW5zdWJzY3JpYmUob25DYW5jZWxlZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb25maWcuc2lnbmFsKSB7XG4gICAgICAgIGNvbmZpZy5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbkNhbmNlbGVkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgY29udGVudFR5cGU7XG5cbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShyZXF1ZXN0RGF0YSkpIHtcbiAgICAgIGlmIChwbGF0Zm9ybS5oYXNTdGFuZGFyZEJyb3dzZXJFbnYgfHwgcGxhdGZvcm0uaGFzU3RhbmRhcmRCcm93c2VyV2ViV29ya2VyRW52KSB7XG4gICAgICAgIHJlcXVlc3RIZWFkZXJzLnNldENvbnRlbnRUeXBlKGZhbHNlKTsgLy8gTGV0IHRoZSBicm93c2VyIHNldCBpdFxuICAgICAgfSBlbHNlIGlmICgoY29udGVudFR5cGUgPSByZXF1ZXN0SGVhZGVycy5nZXRDb250ZW50VHlwZSgpKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgLy8gZml4IHNlbWljb2xvbiBkdXBsaWNhdGlvbiBpc3N1ZSBmb3IgUmVhY3ROYXRpdmUgRm9ybURhdGEgaW1wbGVtZW50YXRpb25cbiAgICAgICAgY29uc3QgW3R5cGUsIC4uLnRva2Vuc10gPSBjb250ZW50VHlwZSA/IGNvbnRlbnRUeXBlLnNwbGl0KCc7JykubWFwKHRva2VuID0+IHRva2VuLnRyaW0oKSkuZmlsdGVyKEJvb2xlYW4pIDogW107XG4gICAgICAgIHJlcXVlc3RIZWFkZXJzLnNldENvbnRlbnRUeXBlKFt0eXBlIHx8ICdtdWx0aXBhcnQvZm9ybS1kYXRhJywgLi4udG9rZW5zXS5qb2luKCc7ICcpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgLy8gSFRUUCBiYXNpYyBhdXRoZW50aWNhdGlvblxuICAgIGlmIChjb25maWcuYXV0aCkge1xuICAgICAgY29uc3QgdXNlcm5hbWUgPSBjb25maWcuYXV0aC51c2VybmFtZSB8fCAnJztcbiAgICAgIGNvbnN0IHBhc3N3b3JkID0gY29uZmlnLmF1dGgucGFzc3dvcmQgPyB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoY29uZmlnLmF1dGgucGFzc3dvcmQpKSA6ICcnO1xuICAgICAgcmVxdWVzdEhlYWRlcnMuc2V0KCdBdXRob3JpemF0aW9uJywgJ0Jhc2ljICcgKyBidG9hKHVzZXJuYW1lICsgJzonICsgcGFzc3dvcmQpKTtcbiAgICB9XG5cbiAgICBjb25zdCBmdWxsUGF0aCA9IGJ1aWxkRnVsbFBhdGgoY29uZmlnLmJhc2VVUkwsIGNvbmZpZy51cmwpO1xuXG4gICAgcmVxdWVzdC5vcGVuKGNvbmZpZy5tZXRob2QudG9VcHBlckNhc2UoKSwgYnVpbGRVUkwoZnVsbFBhdGgsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKSwgdHJ1ZSk7XG5cbiAgICAvLyBTZXQgdGhlIHJlcXVlc3QgdGltZW91dCBpbiBNU1xuICAgIHJlcXVlc3QudGltZW91dCA9IGNvbmZpZy50aW1lb3V0O1xuXG4gICAgZnVuY3Rpb24gb25sb2FkZW5kKCkge1xuICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFByZXBhcmUgdGhlIHJlc3BvbnNlXG4gICAgICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuZnJvbShcbiAgICAgICAgJ2dldEFsbFJlc3BvbnNlSGVhZGVycycgaW4gcmVxdWVzdCAmJiByZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICApO1xuICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gIXJlc3BvbnNlVHlwZSB8fCByZXNwb25zZVR5cGUgPT09ICd0ZXh0JyB8fCByZXNwb25zZVR5cGUgPT09ICdqc29uJyA/XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUZXh0IDogcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlcXVlc3Quc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICBjb25maWcsXG4gICAgICAgIHJlcXVlc3RcbiAgICAgIH07XG5cbiAgICAgIHNldHRsZShmdW5jdGlvbiBfcmVzb2x2ZSh2YWx1ZSkge1xuICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSwgZnVuY3Rpb24gX3JlamVjdChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0sIHJlc3BvbnNlKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCdvbmxvYWRlbmQnIGluIHJlcXVlc3QpIHtcbiAgICAgIC8vIFVzZSBvbmxvYWRlbmQgaWYgYXZhaWxhYmxlXG4gICAgICByZXF1ZXN0Lm9ubG9hZGVuZCA9IG9ubG9hZGVuZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGlzdGVuIGZvciByZWFkeSBzdGF0ZSB0byBlbXVsYXRlIG9ubG9hZGVuZFxuICAgICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVMb2FkKCkge1xuICAgICAgICBpZiAoIXJlcXVlc3QgfHwgcmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHJlcXVlc3QgZXJyb3JlZCBvdXQgYW5kIHdlIGRpZG4ndCBnZXQgYSByZXNwb25zZSwgdGhpcyB3aWxsIGJlXG4gICAgICAgIC8vIGhhbmRsZWQgYnkgb25lcnJvciBpbnN0ZWFkXG4gICAgICAgIC8vIFdpdGggb25lIGV4Y2VwdGlvbjogcmVxdWVzdCB0aGF0IHVzaW5nIGZpbGU6IHByb3RvY29sLCBtb3N0IGJyb3dzZXJzXG4gICAgICAgIC8vIHdpbGwgcmV0dXJuIHN0YXR1cyBhcyAwIGV2ZW4gdGhvdWdoIGl0J3MgYSBzdWNjZXNzZnVsIHJlcXVlc3RcbiAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAwICYmICEocmVxdWVzdC5yZXNwb25zZVVSTCAmJiByZXF1ZXN0LnJlc3BvbnNlVVJMLmluZGV4T2YoJ2ZpbGU6JykgPT09IDApKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlYWR5c3RhdGUgaGFuZGxlciBpcyBjYWxsaW5nIGJlZm9yZSBvbmVycm9yIG9yIG9udGltZW91dCBoYW5kbGVycyxcbiAgICAgICAgLy8gc28gd2Ugc2hvdWxkIGNhbGwgb25sb2FkZW5kIG9uIHRoZSBuZXh0ICd0aWNrJ1xuICAgICAgICBzZXRUaW1lb3V0KG9ubG9hZGVuZCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBicm93c2VyIHJlcXVlc3QgY2FuY2VsbGF0aW9uIChhcyBvcHBvc2VkIHRvIGEgbWFudWFsIGNhbmNlbGxhdGlvbilcbiAgICByZXF1ZXN0Lm9uYWJvcnQgPSBmdW5jdGlvbiBoYW5kbGVBYm9ydCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcignUmVxdWVzdCBhYm9ydGVkJywgQXhpb3NFcnJvci5FQ09OTkFCT1JURUQsIGNvbmZpZywgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGxvdyBsZXZlbCBuZXR3b3JrIGVycm9yc1xuICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUVycm9yKCkge1xuICAgICAgLy8gUmVhbCBlcnJvcnMgYXJlIGhpZGRlbiBmcm9tIHVzIGJ5IHRoZSBicm93c2VyXG4gICAgICAvLyBvbmVycm9yIHNob3VsZCBvbmx5IGZpcmUgaWYgaXQncyBhIG5ldHdvcmsgZXJyb3JcbiAgICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcignTmV0d29yayBFcnJvcicsIEF4aW9zRXJyb3IuRVJSX05FVFdPUkssIGNvbmZpZywgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIHRpbWVvdXRcbiAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7XG4gICAgICBsZXQgdGltZW91dEVycm9yTWVzc2FnZSA9IGNvbmZpZy50aW1lb3V0ID8gJ3RpbWVvdXQgb2YgJyArIGNvbmZpZy50aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJyA6ICd0aW1lb3V0IGV4Y2VlZGVkJztcbiAgICAgIGNvbnN0IHRyYW5zaXRpb25hbCA9IGNvbmZpZy50cmFuc2l0aW9uYWwgfHwgdHJhbnNpdGlvbmFsRGVmYXVsdHM7XG4gICAgICBpZiAoY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdGltZW91dEVycm9yTWVzc2FnZSA9IGNvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlO1xuICAgICAgfVxuICAgICAgcmVqZWN0KG5ldyBBeGlvc0Vycm9yKFxuICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlLFxuICAgICAgICB0cmFuc2l0aW9uYWwuY2xhcmlmeVRpbWVvdXRFcnJvciA/IEF4aW9zRXJyb3IuRVRJTUVET1VUIDogQXhpb3NFcnJvci5FQ09OTkFCT1JURUQsXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgLy8gVGhpcyBpcyBvbmx5IGRvbmUgaWYgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gICAgLy8gU3BlY2lmaWNhbGx5IG5vdCBpZiB3ZSdyZSBpbiBhIHdlYiB3b3JrZXIsIG9yIHJlYWN0LW5hdGl2ZS5cbiAgICBpZihwbGF0Zm9ybS5oYXNTdGFuZGFyZEJyb3dzZXJFbnYpIHtcbiAgICAgIHdpdGhYU1JGVG9rZW4gJiYgdXRpbHMuaXNGdW5jdGlvbih3aXRoWFNSRlRva2VuKSAmJiAod2l0aFhTUkZUb2tlbiA9IHdpdGhYU1JGVG9rZW4oY29uZmlnKSk7XG5cbiAgICAgIGlmICh3aXRoWFNSRlRva2VuIHx8ICh3aXRoWFNSRlRva2VuICE9PSBmYWxzZSAmJiBpc1VSTFNhbWVPcmlnaW4oZnVsbFBhdGgpKSkge1xuICAgICAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAgICAgY29uc3QgeHNyZlZhbHVlID0gY29uZmlnLnhzcmZIZWFkZXJOYW1lICYmIGNvbmZpZy54c3JmQ29va2llTmFtZSAmJiBjb29raWVzLnJlYWQoY29uZmlnLnhzcmZDb29raWVOYW1lKTtcblxuICAgICAgICBpZiAoeHNyZlZhbHVlKSB7XG4gICAgICAgICAgcmVxdWVzdEhlYWRlcnMuc2V0KGNvbmZpZy54c3JmSGVhZGVyTmFtZSwgeHNyZlZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSBDb250ZW50LVR5cGUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgICByZXF1ZXN0RGF0YSA9PT0gdW5kZWZpbmVkICYmIHJlcXVlc3RIZWFkZXJzLnNldENvbnRlbnRUeXBlKG51bGwpO1xuXG4gICAgLy8gQWRkIGhlYWRlcnMgdG8gdGhlIHJlcXVlc3RcbiAgICBpZiAoJ3NldFJlcXVlc3RIZWFkZXInIGluIHJlcXVlc3QpIHtcbiAgICAgIHV0aWxzLmZvckVhY2gocmVxdWVzdEhlYWRlcnMudG9KU09OKCksIGZ1bmN0aW9uIHNldFJlcXVlc3RIZWFkZXIodmFsLCBrZXkpIHtcbiAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRoQ3JlZGVudGlhbHMgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMpKSB7XG4gICAgICByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9ICEhY29uZmlnLndpdGhDcmVkZW50aWFscztcbiAgICB9XG5cbiAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKHJlc3BvbnNlVHlwZSAmJiByZXNwb25zZVR5cGUgIT09ICdqc29uJykge1xuICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBwcm9ncmVzcyBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBwcm9ncmVzc0V2ZW50UmVkdWNlcihjb25maWcub25Eb3dubG9hZFByb2dyZXNzLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHVwbG9hZCBldmVudHNcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nICYmIHJlcXVlc3QudXBsb2FkKSB7XG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIHByb2dyZXNzRXZlbnRSZWR1Y2VyKGNvbmZpZy5vblVwbG9hZFByb2dyZXNzKSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbiB8fCBjb25maWcuc2lnbmFsKSB7XG4gICAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgICAgb25DYW5jZWxlZCA9IGNhbmNlbCA9PiB7XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZWplY3QoIWNhbmNlbCB8fCBjYW5jZWwudHlwZSA/IG5ldyBDYW5jZWxlZEVycm9yKG51bGwsIGNvbmZpZywgcmVxdWVzdCkgOiBjYW5jZWwpO1xuICAgICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgY29uZmlnLmNhbmNlbFRva2VuICYmIGNvbmZpZy5jYW5jZWxUb2tlbi5zdWJzY3JpYmUob25DYW5jZWxlZCk7XG4gICAgICBpZiAoY29uZmlnLnNpZ25hbCkge1xuICAgICAgICBjb25maWcuc2lnbmFsLmFib3J0ZWQgPyBvbkNhbmNlbGVkKCkgOiBjb25maWcuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb25DYW5jZWxlZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcHJvdG9jb2wgPSBwYXJzZVByb3RvY29sKGZ1bGxQYXRoKTtcblxuICAgIGlmIChwcm90b2NvbCAmJiBwbGF0Zm9ybS5wcm90b2NvbHMuaW5kZXhPZihwcm90b2NvbCkgPT09IC0xKSB7XG4gICAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoJ1Vuc3VwcG9ydGVkIHByb3RvY29sICcgKyBwcm90b2NvbCArICc6JywgQXhpb3NFcnJvci5FUlJfQkFEX1JFUVVFU1QsIGNvbmZpZykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSB8fCBudWxsKTtcbiAgfSk7XG59XG4iLCJpbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IGh0dHBBZGFwdGVyIGZyb20gJy4vaHR0cC5qcyc7XG5pbXBvcnQgeGhyQWRhcHRlciBmcm9tICcuL3hoci5qcyc7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tIFwiLi4vY29yZS9BeGlvc0Vycm9yLmpzXCI7XG5cbmNvbnN0IGtub3duQWRhcHRlcnMgPSB7XG4gIGh0dHA6IGh0dHBBZGFwdGVyLFxuICB4aHI6IHhockFkYXB0ZXJcbn1cblxudXRpbHMuZm9yRWFjaChrbm93bkFkYXB0ZXJzLCAoZm4sIHZhbHVlKSA9PiB7XG4gIGlmIChmbikge1xuICAgIHRyeSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sICduYW1lJywge3ZhbHVlfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgJ2FkYXB0ZXJOYW1lJywge3ZhbHVlfSk7XG4gIH1cbn0pO1xuXG5jb25zdCByZW5kZXJSZWFzb24gPSAocmVhc29uKSA9PiBgLSAke3JlYXNvbn1gO1xuXG5jb25zdCBpc1Jlc29sdmVkSGFuZGxlID0gKGFkYXB0ZXIpID0+IHV0aWxzLmlzRnVuY3Rpb24oYWRhcHRlcikgfHwgYWRhcHRlciA9PT0gbnVsbCB8fCBhZGFwdGVyID09PSBmYWxzZTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBnZXRBZGFwdGVyOiAoYWRhcHRlcnMpID0+IHtcbiAgICBhZGFwdGVycyA9IHV0aWxzLmlzQXJyYXkoYWRhcHRlcnMpID8gYWRhcHRlcnMgOiBbYWRhcHRlcnNdO1xuXG4gICAgY29uc3Qge2xlbmd0aH0gPSBhZGFwdGVycztcbiAgICBsZXQgbmFtZU9yQWRhcHRlcjtcbiAgICBsZXQgYWRhcHRlcjtcblxuICAgIGNvbnN0IHJlamVjdGVkUmVhc29ucyA9IHt9O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgbmFtZU9yQWRhcHRlciA9IGFkYXB0ZXJzW2ldO1xuICAgICAgbGV0IGlkO1xuXG4gICAgICBhZGFwdGVyID0gbmFtZU9yQWRhcHRlcjtcblxuICAgICAgaWYgKCFpc1Jlc29sdmVkSGFuZGxlKG5hbWVPckFkYXB0ZXIpKSB7XG4gICAgICAgIGFkYXB0ZXIgPSBrbm93bkFkYXB0ZXJzWyhpZCA9IFN0cmluZyhuYW1lT3JBZGFwdGVyKSkudG9Mb3dlckNhc2UoKV07XG5cbiAgICAgICAgaWYgKGFkYXB0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKGBVbmtub3duIGFkYXB0ZXIgJyR7aWR9J2ApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGFwdGVyKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZWplY3RlZFJlYXNvbnNbaWQgfHwgJyMnICsgaV0gPSBhZGFwdGVyO1xuICAgIH1cblxuICAgIGlmICghYWRhcHRlcikge1xuXG4gICAgICBjb25zdCByZWFzb25zID0gT2JqZWN0LmVudHJpZXMocmVqZWN0ZWRSZWFzb25zKVxuICAgICAgICAubWFwKChbaWQsIHN0YXRlXSkgPT4gYGFkYXB0ZXIgJHtpZH0gYCArXG4gICAgICAgICAgKHN0YXRlID09PSBmYWxzZSA/ICdpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBlbnZpcm9ubWVudCcgOiAnaXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgYnVpbGQnKVxuICAgICAgICApO1xuXG4gICAgICBsZXQgcyA9IGxlbmd0aCA/XG4gICAgICAgIChyZWFzb25zLmxlbmd0aCA+IDEgPyAnc2luY2UgOlxcbicgKyByZWFzb25zLm1hcChyZW5kZXJSZWFzb24pLmpvaW4oJ1xcbicpIDogJyAnICsgcmVuZGVyUmVhc29uKHJlYXNvbnNbMF0pKSA6XG4gICAgICAgICdhcyBubyBhZGFwdGVyIHNwZWNpZmllZCc7XG5cbiAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKFxuICAgICAgICBgVGhlcmUgaXMgbm8gc3VpdGFibGUgYWRhcHRlciB0byBkaXNwYXRjaCB0aGUgcmVxdWVzdCBgICsgcyxcbiAgICAgICAgJ0VSUl9OT1RfU1VQUE9SVCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkYXB0ZXI7XG4gIH0sXG4gIGFkYXB0ZXJzOiBrbm93bkFkYXB0ZXJzXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB0cmFuc2Zvcm1EYXRhIGZyb20gJy4vdHJhbnNmb3JtRGF0YS5qcyc7XG5pbXBvcnQgaXNDYW5jZWwgZnJvbSAnLi4vY2FuY2VsL2lzQ2FuY2VsLmpzJztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICcuLi9kZWZhdWx0cy9pbmRleC5qcyc7XG5pbXBvcnQgQ2FuY2VsZWRFcnJvciBmcm9tICcuLi9jYW5jZWwvQ2FuY2VsZWRFcnJvci5qcyc7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gJy4uL2NvcmUvQXhpb3NIZWFkZXJzLmpzJztcbmltcG9ydCBhZGFwdGVycyBmcm9tIFwiLi4vYWRhcHRlcnMvYWRhcHRlcnMuanNcIjtcblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsZWRFcnJvcmAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcgdGhhdCBpcyB0byBiZSB1c2VkIGZvciB0aGUgcmVxdWVzdFxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZykge1xuICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgY29uZmlnLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKTtcbiAgfVxuXG4gIGlmIChjb25maWcuc2lnbmFsICYmIGNvbmZpZy5zaWduYWwuYWJvcnRlZCkge1xuICAgIHRocm93IG5ldyBDYW5jZWxlZEVycm9yKG51bGwsIGNvbmZpZyk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB1c2luZyB0aGUgY29uZmlndXJlZCBhZGFwdGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyB0aGF0IGlzIHRvIGJlIHVzZWQgZm9yIHRoZSByZXF1ZXN0XG4gKlxuICogQHJldHVybnMge1Byb21pc2V9IFRoZSBQcm9taXNlIHRvIGJlIGZ1bGZpbGxlZFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkaXNwYXRjaFJlcXVlc3QoY29uZmlnKSB7XG4gIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICBjb25maWcuaGVhZGVycyA9IEF4aW9zSGVhZGVycy5mcm9tKGNvbmZpZy5oZWFkZXJzKTtcblxuICAvLyBUcmFuc2Zvcm0gcmVxdWVzdCBkYXRhXG4gIGNvbmZpZy5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgIGNvbmZpZyxcbiAgICBjb25maWcudHJhbnNmb3JtUmVxdWVzdFxuICApO1xuXG4gIGlmIChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10uaW5kZXhPZihjb25maWcubWV0aG9kKSAhPT0gLTEpIHtcbiAgICBjb25maWcuaGVhZGVycy5zZXRDb250ZW50VHlwZSgnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJywgZmFsc2UpO1xuICB9XG5cbiAgY29uc3QgYWRhcHRlciA9IGFkYXB0ZXJzLmdldEFkYXB0ZXIoY29uZmlnLmFkYXB0ZXIgfHwgZGVmYXVsdHMuYWRhcHRlcik7XG5cbiAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKGZ1bmN0aW9uIG9uQWRhcHRlclJlc29sdXRpb24ocmVzcG9uc2UpIHtcbiAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgICBjb25maWcsXG4gICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2UsXG4gICAgICByZXNwb25zZVxuICAgICk7XG5cbiAgICByZXNwb25zZS5oZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20ocmVzcG9uc2UuaGVhZGVycyk7XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0sIGZ1bmN0aW9uIG9uQWRhcHRlclJlamVjdGlvbihyZWFzb24pIHtcbiAgICBpZiAoIWlzQ2FuY2VsKHJlYXNvbikpIHtcbiAgICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICAgIGlmIChyZWFzb24gJiYgcmVhc29uLnJlc3BvbnNlKSB7XG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2UsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlXG4gICAgICAgICk7XG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5oZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20ocmVhc29uLnJlc3BvbnNlLmhlYWRlcnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xuICB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSBcIi4vQXhpb3NIZWFkZXJzLmpzXCI7XG5cbmNvbnN0IGhlYWRlcnNUb09iamVjdCA9ICh0aGluZykgPT4gdGhpbmcgaW5zdGFuY2VvZiBBeGlvc0hlYWRlcnMgPyB0aGluZy50b0pTT04oKSA6IHRoaW5nO1xuXG4vKipcbiAqIENvbmZpZy1zcGVjaWZpYyBtZXJnZS1mdW5jdGlvbiB3aGljaCBjcmVhdGVzIGEgbmV3IGNvbmZpZy1vYmplY3RcbiAqIGJ5IG1lcmdpbmcgdHdvIGNvbmZpZ3VyYXRpb24gb2JqZWN0cyB0b2dldGhlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMVxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzJcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBOZXcgb2JqZWN0IHJlc3VsdGluZyBmcm9tIG1lcmdpbmcgY29uZmlnMiB0byBjb25maWcxXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlQ29uZmlnKGNvbmZpZzEsIGNvbmZpZzIpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGNvbmZpZzIgPSBjb25maWcyIHx8IHt9O1xuICBjb25zdCBjb25maWcgPSB7fTtcblxuICBmdW5jdGlvbiBnZXRNZXJnZWRWYWx1ZSh0YXJnZXQsIHNvdXJjZSwgY2FzZWxlc3MpIHtcbiAgICBpZiAodXRpbHMuaXNQbGFpbk9iamVjdCh0YXJnZXQpICYmIHV0aWxzLmlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlLmNhbGwoe2Nhc2VsZXNzfSwgdGFyZ2V0LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2Uoe30sIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiBzb3VyY2Uuc2xpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBmdW5jdGlvbiBtZXJnZURlZXBQcm9wZXJ0aWVzKGEsIGIsIGNhc2VsZXNzKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChiKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKGEsIGIsIGNhc2VsZXNzKTtcbiAgICB9IGVsc2UgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChhKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgYSwgY2FzZWxlc3MpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBmdW5jdGlvbiB2YWx1ZUZyb21Db25maWcyKGEsIGIpIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGIpKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBiKTtcbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgZnVuY3Rpb24gZGVmYXVsdFRvQ29uZmlnMihhLCBiKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChiKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgYik7XG4gICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoYSkpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGEpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBmdW5jdGlvbiBtZXJnZURpcmVjdEtleXMoYSwgYiwgcHJvcCkge1xuICAgIGlmIChwcm9wIGluIGNvbmZpZzIpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZShhLCBiKTtcbiAgICB9IGVsc2UgaWYgKHByb3AgaW4gY29uZmlnMSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgYSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgbWVyZ2VNYXAgPSB7XG4gICAgdXJsOiB2YWx1ZUZyb21Db25maWcyLFxuICAgIG1ldGhvZDogdmFsdWVGcm9tQ29uZmlnMixcbiAgICBkYXRhOiB2YWx1ZUZyb21Db25maWcyLFxuICAgIGJhc2VVUkw6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgdHJhbnNmb3JtUmVxdWVzdDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB0cmFuc2Zvcm1SZXNwb25zZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBwYXJhbXNTZXJpYWxpemVyOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHRpbWVvdXQ6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgdGltZW91dE1lc3NhZ2U6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgd2l0aENyZWRlbnRpYWxzOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHdpdGhYU1JGVG9rZW46IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgYWRhcHRlcjogZGVmYXVsdFRvQ29uZmlnMixcbiAgICByZXNwb25zZVR5cGU6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgeHNyZkNvb2tpZU5hbWU6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgeHNyZkhlYWRlck5hbWU6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgb25VcGxvYWRQcm9ncmVzczogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBvbkRvd25sb2FkUHJvZ3Jlc3M6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgZGVjb21wcmVzczogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBtYXhDb250ZW50TGVuZ3RoOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIG1heEJvZHlMZW5ndGg6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgYmVmb3JlUmVkaXJlY3Q6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgdHJhbnNwb3J0OiBkZWZhdWx0VG9Db25maWcyLFxuICAgIGh0dHBBZ2VudDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBodHRwc0FnZW50OiBkZWZhdWx0VG9Db25maWcyLFxuICAgIGNhbmNlbFRva2VuOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHNvY2tldFBhdGg6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgcmVzcG9uc2VFbmNvZGluZzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB2YWxpZGF0ZVN0YXR1czogbWVyZ2VEaXJlY3RLZXlzLFxuICAgIGhlYWRlcnM6IChhLCBiKSA9PiBtZXJnZURlZXBQcm9wZXJ0aWVzKGhlYWRlcnNUb09iamVjdChhKSwgaGVhZGVyc1RvT2JqZWN0KGIpLCB0cnVlKVxuICB9O1xuXG4gIHV0aWxzLmZvckVhY2goT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnMSwgY29uZmlnMikpLCBmdW5jdGlvbiBjb21wdXRlQ29uZmlnVmFsdWUocHJvcCkge1xuICAgIGNvbnN0IG1lcmdlID0gbWVyZ2VNYXBbcHJvcF0gfHwgbWVyZ2VEZWVwUHJvcGVydGllcztcbiAgICBjb25zdCBjb25maWdWYWx1ZSA9IG1lcmdlKGNvbmZpZzFbcHJvcF0sIGNvbmZpZzJbcHJvcF0sIHByb3ApO1xuICAgICh1dGlscy5pc1VuZGVmaW5lZChjb25maWdWYWx1ZSkgJiYgbWVyZ2UgIT09IG1lcmdlRGlyZWN0S2V5cykgfHwgKGNvbmZpZ1twcm9wXSA9IGNvbmZpZ1ZhbHVlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGNvbmZpZztcbn1cbiIsImV4cG9ydCBjb25zdCBWRVJTSU9OID0gXCIxLjYuMlwiOyIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHtWRVJTSU9OfSBmcm9tICcuLi9lbnYvZGF0YS5qcyc7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuLi9jb3JlL0F4aW9zRXJyb3IuanMnO1xuXG5jb25zdCB2YWxpZGF0b3JzID0ge307XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5bJ29iamVjdCcsICdib29sZWFuJywgJ251bWJlcicsICdmdW5jdGlvbicsICdzdHJpbmcnLCAnc3ltYm9sJ10uZm9yRWFjaCgodHlwZSwgaSkgPT4ge1xuICB2YWxpZGF0b3JzW3R5cGVdID0gZnVuY3Rpb24gdmFsaWRhdG9yKHRoaW5nKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGluZyA9PT0gdHlwZSB8fCAnYScgKyAoaSA8IDEgPyAnbiAnIDogJyAnKSArIHR5cGU7XG4gIH07XG59KTtcblxuY29uc3QgZGVwcmVjYXRlZFdhcm5pbmdzID0ge307XG5cbi8qKlxuICogVHJhbnNpdGlvbmFsIG9wdGlvbiB2YWxpZGF0b3JcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufGJvb2xlYW4/fSB2YWxpZGF0b3IgLSBzZXQgdG8gZmFsc2UgaWYgdGhlIHRyYW5zaXRpb25hbCBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZFxuICogQHBhcmFtIHtzdHJpbmc/fSB2ZXJzaW9uIC0gZGVwcmVjYXRlZCB2ZXJzaW9uIC8gcmVtb3ZlZCBzaW5jZSB2ZXJzaW9uXG4gKiBAcGFyYW0ge3N0cmluZz99IG1lc3NhZ2UgLSBzb21lIG1lc3NhZ2Ugd2l0aCBhZGRpdGlvbmFsIGluZm9cbiAqXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259XG4gKi9cbnZhbGlkYXRvcnMudHJhbnNpdGlvbmFsID0gZnVuY3Rpb24gdHJhbnNpdGlvbmFsKHZhbGlkYXRvciwgdmVyc2lvbiwgbWVzc2FnZSkge1xuICBmdW5jdGlvbiBmb3JtYXRNZXNzYWdlKG9wdCwgZGVzYykge1xuICAgIHJldHVybiAnW0F4aW9zIHYnICsgVkVSU0lPTiArICddIFRyYW5zaXRpb25hbCBvcHRpb24gXFwnJyArIG9wdCArICdcXCcnICsgZGVzYyArIChtZXNzYWdlID8gJy4gJyArIG1lc3NhZ2UgOiAnJyk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICByZXR1cm4gKHZhbHVlLCBvcHQsIG9wdHMpID0+IHtcbiAgICBpZiAodmFsaWRhdG9yID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoXG4gICAgICAgIGZvcm1hdE1lc3NhZ2Uob3B0LCAnIGhhcyBiZWVuIHJlbW92ZWQnICsgKHZlcnNpb24gPyAnIGluICcgKyB2ZXJzaW9uIDogJycpKSxcbiAgICAgICAgQXhpb3NFcnJvci5FUlJfREVQUkVDQVRFRFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbiAmJiAhZGVwcmVjYXRlZFdhcm5pbmdzW29wdF0pIHtcbiAgICAgIGRlcHJlY2F0ZWRXYXJuaW5nc1tvcHRdID0gdHJ1ZTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICAgb3B0LFxuICAgICAgICAgICcgaGFzIGJlZW4gZGVwcmVjYXRlZCBzaW5jZSB2JyArIHZlcnNpb24gKyAnIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5lYXIgZnV0dXJlJ1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB2YWxpZGF0b3IgPyB2YWxpZGF0b3IodmFsdWUsIG9wdCwgb3B0cykgOiB0cnVlO1xuICB9O1xufTtcblxuLyoqXG4gKiBBc3NlcnQgb2JqZWN0J3MgcHJvcGVydGllcyB0eXBlXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7b2JqZWN0fSBzY2hlbWFcbiAqIEBwYXJhbSB7Ym9vbGVhbj99IGFsbG93VW5rbm93blxuICpcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBzY2hlbWEsIGFsbG93VW5rbm93bikge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnLCBBeGlvc0Vycm9yLkVSUl9CQURfT1BUSU9OX1ZBTFVFKTtcbiAgfVxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyk7XG4gIGxldCBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgY29uc3Qgb3B0ID0ga2V5c1tpXTtcbiAgICBjb25zdCB2YWxpZGF0b3IgPSBzY2hlbWFbb3B0XTtcbiAgICBpZiAodmFsaWRhdG9yKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG9wdGlvbnNbb3B0XTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsaWRhdG9yKHZhbHVlLCBvcHQsIG9wdGlvbnMpO1xuICAgICAgaWYgKHJlc3VsdCAhPT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcignb3B0aW9uICcgKyBvcHQgKyAnIG11c3QgYmUgJyArIHJlc3VsdCwgQXhpb3NFcnJvci5FUlJfQkFEX09QVElPTl9WQUxVRSk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGFsbG93VW5rbm93biAhPT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoJ1Vua25vd24gb3B0aW9uICcgKyBvcHQsIEF4aW9zRXJyb3IuRVJSX0JBRF9PUFRJT04pO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGFzc2VydE9wdGlvbnMsXG4gIHZhbGlkYXRvcnNcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcbmltcG9ydCBidWlsZFVSTCBmcm9tICcuLi9oZWxwZXJzL2J1aWxkVVJMLmpzJztcbmltcG9ydCBJbnRlcmNlcHRvck1hbmFnZXIgZnJvbSAnLi9JbnRlcmNlcHRvck1hbmFnZXIuanMnO1xuaW1wb3J0IGRpc3BhdGNoUmVxdWVzdCBmcm9tICcuL2Rpc3BhdGNoUmVxdWVzdC5qcyc7XG5pbXBvcnQgbWVyZ2VDb25maWcgZnJvbSAnLi9tZXJnZUNvbmZpZy5qcyc7XG5pbXBvcnQgYnVpbGRGdWxsUGF0aCBmcm9tICcuL2J1aWxkRnVsbFBhdGguanMnO1xuaW1wb3J0IHZhbGlkYXRvciBmcm9tICcuLi9oZWxwZXJzL3ZhbGlkYXRvci5qcyc7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gJy4vQXhpb3NIZWFkZXJzLmpzJztcblxuY29uc3QgdmFsaWRhdG9ycyA9IHZhbGlkYXRvci52YWxpZGF0b3JzO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0YW5jZUNvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICpcbiAqIEByZXR1cm4ge0F4aW9zfSBBIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICovXG5jbGFzcyBBeGlvcyB7XG4gIGNvbnN0cnVjdG9yKGluc3RhbmNlQ29uZmlnKSB7XG4gICAgdGhpcy5kZWZhdWx0cyA9IGluc3RhbmNlQ29uZmlnO1xuICAgIHRoaXMuaW50ZXJjZXB0b3JzID0ge1xuICAgICAgcmVxdWVzdDogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpLFxuICAgICAgcmVzcG9uc2U6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2ggYSByZXF1ZXN0XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gY29uZmlnT3JVcmwgVGhlIGNvbmZpZyBzcGVjaWZpYyBmb3IgdGhpcyByZXF1ZXN0IChtZXJnZWQgd2l0aCB0aGlzLmRlZmF1bHRzKVxuICAgKiBAcGFyYW0gez9PYmplY3R9IGNvbmZpZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIFByb21pc2UgdG8gYmUgZnVsZmlsbGVkXG4gICAqL1xuICByZXF1ZXN0KGNvbmZpZ09yVXJsLCBjb25maWcpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICAvLyBBbGxvdyBmb3IgYXhpb3MoJ2V4YW1wbGUvdXJsJ1ssIGNvbmZpZ10pIGEgbGEgZmV0Y2ggQVBJXG4gICAgaWYgKHR5cGVvZiBjb25maWdPclVybCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICAgIGNvbmZpZy51cmwgPSBjb25maWdPclVybDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uZmlnID0gY29uZmlnT3JVcmwgfHwge307XG4gICAgfVxuXG4gICAgY29uZmlnID0gbWVyZ2VDb25maWcodGhpcy5kZWZhdWx0cywgY29uZmlnKTtcblxuICAgIGNvbnN0IHt0cmFuc2l0aW9uYWwsIHBhcmFtc1NlcmlhbGl6ZXIsIGhlYWRlcnN9ID0gY29uZmlnO1xuXG4gICAgaWYgKHRyYW5zaXRpb25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWxpZGF0b3IuYXNzZXJ0T3B0aW9ucyh0cmFuc2l0aW9uYWwsIHtcbiAgICAgICAgc2lsZW50SlNPTlBhcnNpbmc6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbiksXG4gICAgICAgIGZvcmNlZEpTT05QYXJzaW5nOiB2YWxpZGF0b3JzLnRyYW5zaXRpb25hbCh2YWxpZGF0b3JzLmJvb2xlYW4pLFxuICAgICAgICBjbGFyaWZ5VGltZW91dEVycm9yOiB2YWxpZGF0b3JzLnRyYW5zaXRpb25hbCh2YWxpZGF0b3JzLmJvb2xlYW4pXG4gICAgICB9LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtc1NlcmlhbGl6ZXIgIT0gbnVsbCkge1xuICAgICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24ocGFyYW1zU2VyaWFsaXplcikpIHtcbiAgICAgICAgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIgPSB7XG4gICAgICAgICAgc2VyaWFsaXplOiBwYXJhbXNTZXJpYWxpemVyXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbGlkYXRvci5hc3NlcnRPcHRpb25zKHBhcmFtc1NlcmlhbGl6ZXIsIHtcbiAgICAgICAgICBlbmNvZGU6IHZhbGlkYXRvcnMuZnVuY3Rpb24sXG4gICAgICAgICAgc2VyaWFsaXplOiB2YWxpZGF0b3JzLmZ1bmN0aW9uXG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldCBjb25maWcubWV0aG9kXG4gICAgY29uZmlnLm1ldGhvZCA9IChjb25maWcubWV0aG9kIHx8IHRoaXMuZGVmYXVsdHMubWV0aG9kIHx8ICdnZXQnKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gRmxhdHRlbiBoZWFkZXJzXG4gICAgbGV0IGNvbnRleHRIZWFkZXJzID0gaGVhZGVycyAmJiB1dGlscy5tZXJnZShcbiAgICAgIGhlYWRlcnMuY29tbW9uLFxuICAgICAgaGVhZGVyc1tjb25maWcubWV0aG9kXVxuICAgICk7XG5cbiAgICBoZWFkZXJzICYmIHV0aWxzLmZvckVhY2goXG4gICAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdjb21tb24nXSxcbiAgICAgIChtZXRob2QpID0+IHtcbiAgICAgICAgZGVsZXRlIGhlYWRlcnNbbWV0aG9kXTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgY29uZmlnLmhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuY29uY2F0KGNvbnRleHRIZWFkZXJzLCBoZWFkZXJzKTtcblxuICAgIC8vIGZpbHRlciBvdXQgc2tpcHBlZCBpbnRlcmNlcHRvcnNcbiAgICBjb25zdCByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbiA9IFtdO1xuICAgIGxldCBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgPSB0cnVlO1xuICAgIHRoaXMuaW50ZXJjZXB0b3JzLnJlcXVlc3QuZm9yRWFjaChmdW5jdGlvbiB1bnNoaWZ0UmVxdWVzdEludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgICAgaWYgKHR5cGVvZiBpbnRlcmNlcHRvci5ydW5XaGVuID09PSAnZnVuY3Rpb24nICYmIGludGVyY2VwdG9yLnJ1bldoZW4oY29uZmlnKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgPSBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgJiYgaW50ZXJjZXB0b3Iuc3luY2hyb25vdXM7XG5cbiAgICAgIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLnVuc2hpZnQoaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4gPSBbXTtcbiAgICB0aGlzLmludGVyY2VwdG9ycy5yZXNwb25zZS5mb3JFYWNoKGZ1bmN0aW9uIHB1c2hSZXNwb25zZUludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgICAgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLnB1c2goaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gICAgfSk7XG5cbiAgICBsZXQgcHJvbWlzZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGxlbjtcblxuICAgIGlmICghc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzKSB7XG4gICAgICBjb25zdCBjaGFpbiA9IFtkaXNwYXRjaFJlcXVlc3QuYmluZCh0aGlzKSwgdW5kZWZpbmVkXTtcbiAgICAgIGNoYWluLnVuc2hpZnQuYXBwbHkoY2hhaW4sIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluKTtcbiAgICAgIGNoYWluLnB1c2guYXBwbHkoY2hhaW4sIHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbik7XG4gICAgICBsZW4gPSBjaGFpbi5sZW5ndGg7XG5cbiAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoY29uZmlnKTtcblxuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihjaGFpbltpKytdLCBjaGFpbltpKytdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuXG4gICAgbGVuID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4ubGVuZ3RoO1xuXG4gICAgbGV0IG5ld0NvbmZpZyA9IGNvbmZpZztcblxuICAgIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIGNvbnN0IG9uRnVsZmlsbGVkID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW5baSsrXTtcbiAgICAgIGNvbnN0IG9uUmVqZWN0ZWQgPSByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbltpKytdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3Q29uZmlnID0gb25GdWxmaWxsZWQobmV3Q29uZmlnKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIG9uUmVqZWN0ZWQuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBwcm9taXNlID0gZGlzcGF0Y2hSZXF1ZXN0LmNhbGwodGhpcywgbmV3Q29uZmlnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG5cbiAgICBpID0gMDtcbiAgICBsZW4gPSByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4ubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4ocmVzcG9uc2VJbnRlcmNlcHRvckNoYWluW2krK10sIHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbltpKytdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIGdldFVyaShjb25maWcpIHtcbiAgICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuICAgIGNvbnN0IGZ1bGxQYXRoID0gYnVpbGRGdWxsUGF0aChjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCk7XG4gICAgcmV0dXJuIGJ1aWxkVVJMKGZ1bGxQYXRoLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplcik7XG4gIH1cbn1cblxuLy8gUHJvdmlkZSBhbGlhc2VzIGZvciBzdXBwb3J0ZWQgcmVxdWVzdCBtZXRob2RzXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ29wdGlvbnMnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2QsXG4gICAgICB1cmwsXG4gICAgICBkYXRhOiAoY29uZmlnIHx8IHt9KS5kYXRhXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVIVFRQTWV0aG9kKGlzRm9ybSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBodHRwTWV0aG9kKHVybCwgZGF0YSwgY29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgICBtZXRob2QsXG4gICAgICAgIGhlYWRlcnM6IGlzRm9ybSA/IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ211bHRpcGFydC9mb3JtLWRhdGEnXG4gICAgICAgIH0gOiB7fSxcbiAgICAgICAgdXJsLFxuICAgICAgICBkYXRhXG4gICAgICB9KSk7XG4gICAgfTtcbiAgfVxuXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZ2VuZXJhdGVIVFRQTWV0aG9kKCk7XG5cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZCArICdGb3JtJ10gPSBnZW5lcmF0ZUhUVFBNZXRob2QodHJ1ZSk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQXhpb3M7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBDYW5jZWxlZEVycm9yIGZyb20gJy4vQ2FuY2VsZWRFcnJvci5qcyc7XG5cbi8qKlxuICogQSBgQ2FuY2VsVG9rZW5gIGlzIGFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlcXVlc3QgY2FuY2VsbGF0aW9uIG9mIGFuIG9wZXJhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjdXRvciBUaGUgZXhlY3V0b3IgZnVuY3Rpb24uXG4gKlxuICogQHJldHVybnMge0NhbmNlbFRva2VufVxuICovXG5jbGFzcyBDYW5jZWxUb2tlbiB7XG4gIGNvbnN0cnVjdG9yKGV4ZWN1dG9yKSB7XG4gICAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhlY3V0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIGxldCByZXNvbHZlUHJvbWlzZTtcblxuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIHByb21pc2VFeGVjdXRvcihyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgfSk7XG5cbiAgICBjb25zdCB0b2tlbiA9IHRoaXM7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgIHRoaXMucHJvbWlzZS50aGVuKGNhbmNlbCA9PiB7XG4gICAgICBpZiAoIXRva2VuLl9saXN0ZW5lcnMpIHJldHVybjtcblxuICAgICAgbGV0IGkgPSB0b2tlbi5fbGlzdGVuZXJzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgdG9rZW4uX2xpc3RlbmVyc1tpXShjYW5jZWwpO1xuICAgICAgfVxuICAgICAgdG9rZW4uX2xpc3RlbmVycyA9IG51bGw7XG4gICAgfSk7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgIHRoaXMucHJvbWlzZS50aGVuID0gb25mdWxmaWxsZWQgPT4ge1xuICAgICAgbGV0IF9yZXNvbHZlO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgdG9rZW4uc3Vic2NyaWJlKHJlc29sdmUpO1xuICAgICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICB9KS50aGVuKG9uZnVsZmlsbGVkKTtcblxuICAgICAgcHJvbWlzZS5jYW5jZWwgPSBmdW5jdGlvbiByZWplY3QoKSB7XG4gICAgICAgIHRva2VuLnVuc3Vic2NyaWJlKF9yZXNvbHZlKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG5cbiAgICBleGVjdXRvcihmdW5jdGlvbiBjYW5jZWwobWVzc2FnZSwgY29uZmlnLCByZXF1ZXN0KSB7XG4gICAgICBpZiAodG9rZW4ucmVhc29uKSB7XG4gICAgICAgIC8vIENhbmNlbGxhdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRva2VuLnJlYXNvbiA9IG5ldyBDYW5jZWxlZEVycm9yKG1lc3NhZ2UsIGNvbmZpZywgcmVxdWVzdCk7XG4gICAgICByZXNvbHZlUHJvbWlzZSh0b2tlbi5yZWFzb24pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRocm93cyBhIGBDYW5jZWxlZEVycm9yYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICAgKi9cbiAgdGhyb3dJZlJlcXVlc3RlZCgpIHtcbiAgICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICAgIHRocm93IHRoaXMucmVhc29uO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgdG8gdGhlIGNhbmNlbCBzaWduYWxcbiAgICovXG5cbiAgc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgICBsaXN0ZW5lcih0aGlzLnJlYXNvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xpc3RlbmVycykge1xuICAgICAgdGhpcy5fbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbbGlzdGVuZXJdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZSBmcm9tIHRoZSBjYW5jZWwgc2lnbmFsXG4gICAqL1xuXG4gIHVuc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgaWYgKCF0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9saXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5fbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBuZXcgYENhbmNlbFRva2VuYCBhbmQgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCxcbiAgICogY2FuY2VscyB0aGUgYENhbmNlbFRva2VuYC5cbiAgICovXG4gIHN0YXRpYyBzb3VyY2UoKSB7XG4gICAgbGV0IGNhbmNlbDtcbiAgICBjb25zdCB0b2tlbiA9IG5ldyBDYW5jZWxUb2tlbihmdW5jdGlvbiBleGVjdXRvcihjKSB7XG4gICAgICBjYW5jZWwgPSBjO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICB0b2tlbixcbiAgICAgIGNhbmNlbFxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2FuY2VsVG9rZW47XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU3ludGFjdGljIHN1Z2FyIGZvciBpbnZva2luZyBhIGZ1bmN0aW9uIGFuZCBleHBhbmRpbmcgYW4gYXJyYXkgZm9yIGFyZ3VtZW50cy5cbiAqXG4gKiBDb21tb24gdXNlIGNhc2Ugd291bGQgYmUgdG8gdXNlIGBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHlgLlxuICpcbiAqICBgYGBqc1xuICogIGZ1bmN0aW9uIGYoeCwgeSwgeikge31cbiAqICB2YXIgYXJncyA9IFsxLCAyLCAzXTtcbiAqICBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICogIGBgYFxuICpcbiAqIFdpdGggYHNwcmVhZGAgdGhpcyBleGFtcGxlIGNhbiBiZSByZS13cml0dGVuLlxuICpcbiAqICBgYGBqc1xuICogIHNwcmVhZChmdW5jdGlvbih4LCB5LCB6KSB7fSkoWzEsIDIsIDNdKTtcbiAqICBgYGBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc3ByZWFkKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKGFycikge1xuICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBhcnIpO1xuICB9O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvc1xuICpcbiAqIEBwYXJhbSB7Kn0gcGF5bG9hZCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvcywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzQXhpb3NFcnJvcihwYXlsb2FkKSB7XG4gIHJldHVybiB1dGlscy5pc09iamVjdChwYXlsb2FkKSAmJiAocGF5bG9hZC5pc0F4aW9zRXJyb3IgPT09IHRydWUpO1xufVxuIiwiY29uc3QgSHR0cFN0YXR1c0NvZGUgPSB7XG4gIENvbnRpbnVlOiAxMDAsXG4gIFN3aXRjaGluZ1Byb3RvY29sczogMTAxLFxuICBQcm9jZXNzaW5nOiAxMDIsXG4gIEVhcmx5SGludHM6IDEwMyxcbiAgT2s6IDIwMCxcbiAgQ3JlYXRlZDogMjAxLFxuICBBY2NlcHRlZDogMjAyLFxuICBOb25BdXRob3JpdGF0aXZlSW5mb3JtYXRpb246IDIwMyxcbiAgTm9Db250ZW50OiAyMDQsXG4gIFJlc2V0Q29udGVudDogMjA1LFxuICBQYXJ0aWFsQ29udGVudDogMjA2LFxuICBNdWx0aVN0YXR1czogMjA3LFxuICBBbHJlYWR5UmVwb3J0ZWQ6IDIwOCxcbiAgSW1Vc2VkOiAyMjYsXG4gIE11bHRpcGxlQ2hvaWNlczogMzAwLFxuICBNb3ZlZFBlcm1hbmVudGx5OiAzMDEsXG4gIEZvdW5kOiAzMDIsXG4gIFNlZU90aGVyOiAzMDMsXG4gIE5vdE1vZGlmaWVkOiAzMDQsXG4gIFVzZVByb3h5OiAzMDUsXG4gIFVudXNlZDogMzA2LFxuICBUZW1wb3JhcnlSZWRpcmVjdDogMzA3LFxuICBQZXJtYW5lbnRSZWRpcmVjdDogMzA4LFxuICBCYWRSZXF1ZXN0OiA0MDAsXG4gIFVuYXV0aG9yaXplZDogNDAxLFxuICBQYXltZW50UmVxdWlyZWQ6IDQwMixcbiAgRm9yYmlkZGVuOiA0MDMsXG4gIE5vdEZvdW5kOiA0MDQsXG4gIE1ldGhvZE5vdEFsbG93ZWQ6IDQwNSxcbiAgTm90QWNjZXB0YWJsZTogNDA2LFxuICBQcm94eUF1dGhlbnRpY2F0aW9uUmVxdWlyZWQ6IDQwNyxcbiAgUmVxdWVzdFRpbWVvdXQ6IDQwOCxcbiAgQ29uZmxpY3Q6IDQwOSxcbiAgR29uZTogNDEwLFxuICBMZW5ndGhSZXF1aXJlZDogNDExLFxuICBQcmVjb25kaXRpb25GYWlsZWQ6IDQxMixcbiAgUGF5bG9hZFRvb0xhcmdlOiA0MTMsXG4gIFVyaVRvb0xvbmc6IDQxNCxcbiAgVW5zdXBwb3J0ZWRNZWRpYVR5cGU6IDQxNSxcbiAgUmFuZ2VOb3RTYXRpc2ZpYWJsZTogNDE2LFxuICBFeHBlY3RhdGlvbkZhaWxlZDogNDE3LFxuICBJbUFUZWFwb3Q6IDQxOCxcbiAgTWlzZGlyZWN0ZWRSZXF1ZXN0OiA0MjEsXG4gIFVucHJvY2Vzc2FibGVFbnRpdHk6IDQyMixcbiAgTG9ja2VkOiA0MjMsXG4gIEZhaWxlZERlcGVuZGVuY3k6IDQyNCxcbiAgVG9vRWFybHk6IDQyNSxcbiAgVXBncmFkZVJlcXVpcmVkOiA0MjYsXG4gIFByZWNvbmRpdGlvblJlcXVpcmVkOiA0MjgsXG4gIFRvb01hbnlSZXF1ZXN0czogNDI5LFxuICBSZXF1ZXN0SGVhZGVyRmllbGRzVG9vTGFyZ2U6IDQzMSxcbiAgVW5hdmFpbGFibGVGb3JMZWdhbFJlYXNvbnM6IDQ1MSxcbiAgSW50ZXJuYWxTZXJ2ZXJFcnJvcjogNTAwLFxuICBOb3RJbXBsZW1lbnRlZDogNTAxLFxuICBCYWRHYXRld2F5OiA1MDIsXG4gIFNlcnZpY2VVbmF2YWlsYWJsZTogNTAzLFxuICBHYXRld2F5VGltZW91dDogNTA0LFxuICBIdHRwVmVyc2lvbk5vdFN1cHBvcnRlZDogNTA1LFxuICBWYXJpYW50QWxzb05lZ290aWF0ZXM6IDUwNixcbiAgSW5zdWZmaWNpZW50U3RvcmFnZTogNTA3LFxuICBMb29wRGV0ZWN0ZWQ6IDUwOCxcbiAgTm90RXh0ZW5kZWQ6IDUxMCxcbiAgTmV0d29ya0F1dGhlbnRpY2F0aW9uUmVxdWlyZWQ6IDUxMSxcbn07XG5cbk9iamVjdC5lbnRyaWVzKEh0dHBTdGF0dXNDb2RlKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgSHR0cFN0YXR1c0NvZGVbdmFsdWVdID0ga2V5O1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEh0dHBTdGF0dXNDb2RlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgYmluZCBmcm9tICcuL2hlbHBlcnMvYmluZC5qcyc7XG5pbXBvcnQgQXhpb3MgZnJvbSAnLi9jb3JlL0F4aW9zLmpzJztcbmltcG9ydCBtZXJnZUNvbmZpZyBmcm9tICcuL2NvcmUvbWVyZ2VDb25maWcuanMnO1xuaW1wb3J0IGRlZmF1bHRzIGZyb20gJy4vZGVmYXVsdHMvaW5kZXguanMnO1xuaW1wb3J0IGZvcm1EYXRhVG9KU09OIGZyb20gJy4vaGVscGVycy9mb3JtRGF0YVRvSlNPTi5qcyc7XG5pbXBvcnQgQ2FuY2VsZWRFcnJvciBmcm9tICcuL2NhbmNlbC9DYW5jZWxlZEVycm9yLmpzJztcbmltcG9ydCBDYW5jZWxUb2tlbiBmcm9tICcuL2NhbmNlbC9DYW5jZWxUb2tlbi5qcyc7XG5pbXBvcnQgaXNDYW5jZWwgZnJvbSAnLi9jYW5jZWwvaXNDYW5jZWwuanMnO1xuaW1wb3J0IHtWRVJTSU9OfSBmcm9tICcuL2Vudi9kYXRhLmpzJztcbmltcG9ydCB0b0Zvcm1EYXRhIGZyb20gJy4vaGVscGVycy90b0Zvcm1EYXRhLmpzJztcbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4vY29yZS9BeGlvc0Vycm9yLmpzJztcbmltcG9ydCBzcHJlYWQgZnJvbSAnLi9oZWxwZXJzL3NwcmVhZC5qcyc7XG5pbXBvcnQgaXNBeGlvc0Vycm9yIGZyb20gJy4vaGVscGVycy9pc0F4aW9zRXJyb3IuanMnO1xuaW1wb3J0IEF4aW9zSGVhZGVycyBmcm9tIFwiLi9jb3JlL0F4aW9zSGVhZGVycy5qc1wiO1xuaW1wb3J0IGFkYXB0ZXJzIGZyb20gJy4vYWRhcHRlcnMvYWRhcHRlcnMuanMnO1xuaW1wb3J0IEh0dHBTdGF0dXNDb2RlIGZyb20gJy4vaGVscGVycy9IdHRwU3RhdHVzQ29kZS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqXG4gKiBAcmV0dXJucyB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRDb25maWcpIHtcbiAgY29uc3QgY29udGV4dCA9IG5ldyBBeGlvcyhkZWZhdWx0Q29uZmlnKTtcbiAgY29uc3QgaW5zdGFuY2UgPSBiaW5kKEF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0LCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGF4aW9zLnByb3RvdHlwZSB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIEF4aW9zLnByb3RvdHlwZSwgY29udGV4dCwge2FsbE93bktleXM6IHRydWV9KTtcblxuICAvLyBDb3B5IGNvbnRleHQgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBjb250ZXh0LCBudWxsLCB7YWxsT3duS2V5czogdHJ1ZX0pO1xuXG4gIC8vIEZhY3RvcnkgZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXNcbiAgaW5zdGFuY2UuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGluc3RhbmNlQ29uZmlnKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUluc3RhbmNlKG1lcmdlQ29uZmlnKGRlZmF1bHRDb25maWcsIGluc3RhbmNlQ29uZmlnKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG4vLyBDcmVhdGUgdGhlIGRlZmF1bHQgaW5zdGFuY2UgdG8gYmUgZXhwb3J0ZWRcbmNvbnN0IGF4aW9zID0gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdHMpO1xuXG4vLyBFeHBvc2UgQXhpb3MgY2xhc3MgdG8gYWxsb3cgY2xhc3MgaW5oZXJpdGFuY2VcbmF4aW9zLkF4aW9zID0gQXhpb3M7XG5cbi8vIEV4cG9zZSBDYW5jZWwgJiBDYW5jZWxUb2tlblxuYXhpb3MuQ2FuY2VsZWRFcnJvciA9IENhbmNlbGVkRXJyb3I7XG5heGlvcy5DYW5jZWxUb2tlbiA9IENhbmNlbFRva2VuO1xuYXhpb3MuaXNDYW5jZWwgPSBpc0NhbmNlbDtcbmF4aW9zLlZFUlNJT04gPSBWRVJTSU9OO1xuYXhpb3MudG9Gb3JtRGF0YSA9IHRvRm9ybURhdGE7XG5cbi8vIEV4cG9zZSBBeGlvc0Vycm9yIGNsYXNzXG5heGlvcy5BeGlvc0Vycm9yID0gQXhpb3NFcnJvcjtcblxuLy8gYWxpYXMgZm9yIENhbmNlbGVkRXJyb3IgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbmF4aW9zLkNhbmNlbCA9IGF4aW9zLkNhbmNlbGVkRXJyb3I7XG5cbi8vIEV4cG9zZSBhbGwvc3ByZWFkXG5heGlvcy5hbGwgPSBmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbn07XG5cbmF4aW9zLnNwcmVhZCA9IHNwcmVhZDtcblxuLy8gRXhwb3NlIGlzQXhpb3NFcnJvclxuYXhpb3MuaXNBeGlvc0Vycm9yID0gaXNBeGlvc0Vycm9yO1xuXG4vLyBFeHBvc2UgbWVyZ2VDb25maWdcbmF4aW9zLm1lcmdlQ29uZmlnID0gbWVyZ2VDb25maWc7XG5cbmF4aW9zLkF4aW9zSGVhZGVycyA9IEF4aW9zSGVhZGVycztcblxuYXhpb3MuZm9ybVRvSlNPTiA9IHRoaW5nID0+IGZvcm1EYXRhVG9KU09OKHV0aWxzLmlzSFRNTEZvcm0odGhpbmcpID8gbmV3IEZvcm1EYXRhKHRoaW5nKSA6IHRoaW5nKTtcblxuYXhpb3MuZ2V0QWRhcHRlciA9IGFkYXB0ZXJzLmdldEFkYXB0ZXI7XG5cbmF4aW9zLkh0dHBTdGF0dXNDb2RlID0gSHR0cFN0YXR1c0NvZGU7XG5cbmF4aW9zLmRlZmF1bHQgPSBheGlvcztcblxuLy8gdGhpcyBtb2R1bGUgc2hvdWxkIG9ubHkgaGF2ZSBhIGRlZmF1bHQgZXhwb3J0XG5leHBvcnQgZGVmYXVsdCBheGlvc1xuIl0sIm5hbWVzIjpbImJpbmQiLCJmbiIsInRoaXNBcmciLCJ3cmFwIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwia2luZE9mIiwiY2FjaGUiLCJ0aGluZyIsInN0ciIsImNhbGwiLCJzbGljZSIsInRvTG93ZXJDYXNlIiwiY3JlYXRlIiwia2luZE9mVGVzdCIsInR5cGUiLCJ0eXBlT2ZUZXN0IiwiaXNBcnJheSIsIkFycmF5IiwiaXNVbmRlZmluZWQiLCJpc0J1ZmZlciIsInZhbCIsImlzRnVuY3Rpb24iLCJpc0FycmF5QnVmZmVyIiwiaXNBcnJheUJ1ZmZlclZpZXciLCJyZXN1bHQiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImJ1ZmZlciIsImlzU3RyaW5nIiwiaXNOdW1iZXIiLCJpc09iamVjdCIsImlzQm9vbGVhbiIsImlzUGxhaW5PYmplY3QiLCJ0b1N0cmluZ1RhZyIsImlzRGF0ZSIsImlzRmlsZSIsImlzQmxvYiIsImlzRmlsZUxpc3QiLCJpc1N0cmVhbSIsInBpcGUiLCJpc0Zvcm1EYXRhIiwia2luZCIsIkZvcm1EYXRhIiwiYXBwZW5kIiwiaXNVUkxTZWFyY2hQYXJhbXMiLCJ0cmltIiwicmVwbGFjZSIsImZvckVhY2giLCJvYmoiLCJfcmVmIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiX3JlZiRhbGxPd25LZXlzIiwiYWxsT3duS2V5cyIsImkiLCJsIiwia2V5cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJsZW4iLCJrZXkiLCJmaW5kS2V5IiwiX2tleSIsIl9nbG9iYWwiLCJnbG9iYWxUaGlzIiwic2VsZiIsIndpbmRvdyIsImdsb2JhbCIsImlzQ29udGV4dERlZmluZWQiLCJjb250ZXh0IiwibWVyZ2UiLCJfcmVmMiIsImNhc2VsZXNzIiwiYXNzaWduVmFsdWUiLCJ0YXJnZXRLZXkiLCJleHRlbmQiLCJhIiwiYiIsIl9yZWYzIiwic3RyaXBCT00iLCJjb250ZW50IiwiY2hhckNvZGVBdCIsImluaGVyaXRzIiwic3VwZXJDb25zdHJ1Y3RvciIsInByb3BzIiwiZGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwiYXNzaWduIiwidG9GbGF0T2JqZWN0Iiwic291cmNlT2JqIiwiZGVzdE9iaiIsImZpbHRlciIsInByb3BGaWx0ZXIiLCJwcm9wIiwibWVyZ2VkIiwiZW5kc1dpdGgiLCJzZWFyY2hTdHJpbmciLCJwb3NpdGlvbiIsIlN0cmluZyIsImxhc3RJbmRleCIsImluZGV4T2YiLCJ0b0FycmF5IiwiYXJyIiwiaXNUeXBlZEFycmF5IiwiVHlwZWRBcnJheSIsIlVpbnQ4QXJyYXkiLCJmb3JFYWNoRW50cnkiLCJnZW5lcmF0b3IiLCJuZXh0IiwiZG9uZSIsInBhaXIiLCJtYXRjaEFsbCIsInJlZ0V4cCIsIm1hdGNoZXMiLCJleGVjIiwicHVzaCIsImlzSFRNTEZvcm0iLCJ0b0NhbWVsQ2FzZSIsInJlcGxhY2VyIiwibSIsInAxIiwicDIiLCJ0b1VwcGVyQ2FzZSIsImhhc093blByb3BlcnR5IiwiX3JlZjQiLCJpc1JlZ0V4cCIsInJlZHVjZURlc2NyaXB0b3JzIiwicmVkdWNlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJyZWR1Y2VkRGVzY3JpcHRvcnMiLCJkZXNjcmlwdG9yIiwibmFtZSIsInJldCIsImRlZmluZVByb3BlcnRpZXMiLCJmcmVlemVNZXRob2RzIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwic2V0IiwiRXJyb3IiLCJ0b09iamVjdFNldCIsImFycmF5T3JTdHJpbmciLCJkZWxpbWl0ZXIiLCJkZWZpbmUiLCJzcGxpdCIsIm5vb3AiLCJ0b0Zpbml0ZU51bWJlciIsImRlZmF1bHRWYWx1ZSIsIk51bWJlciIsImlzRmluaXRlIiwiQUxQSEEiLCJESUdJVCIsIkFMUEhBQkVUIiwiQUxQSEFfRElHSVQiLCJnZW5lcmF0ZVN0cmluZyIsInNpemUiLCJhbHBoYWJldCIsIk1hdGgiLCJyYW5kb20iLCJpc1NwZWNDb21wbGlhbnRGb3JtIiwidG9KU09OT2JqZWN0Iiwic3RhY2siLCJ2aXNpdCIsInNvdXJjZSIsInRhcmdldCIsInJlZHVjZWRWYWx1ZSIsImlzQXN5bmNGbiIsImlzVGhlbmFibGUiLCJ0aGVuIiwiaGFzT3duUHJvcCIsInV0aWxzIiwiQXhpb3NFcnJvciIsIm1lc3NhZ2UiLCJjb2RlIiwiY29uZmlnIiwicmVxdWVzdCIsInJlc3BvbnNlIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJ0b0pTT04iLCJkZXNjcmlwdGlvbiIsIm51bWJlciIsImZpbGVOYW1lIiwibGluZU51bWJlciIsImNvbHVtbk51bWJlciIsInN0YXR1cyIsImZyb20iLCJlcnJvciIsImN1c3RvbVByb3BzIiwiYXhpb3NFcnJvciIsImNhdXNlIiwiUGxhdGZvcm1Gb3JtRGF0YSIsImlzVmlzaXRhYmxlIiwicmVtb3ZlQnJhY2tldHMiLCJyZW5kZXJLZXkiLCJwYXRoIiwiZG90cyIsImNvbmNhdCIsIm1hcCIsImVhY2giLCJ0b2tlbiIsImpvaW4iLCJpc0ZsYXRBcnJheSIsInNvbWUiLCJwcmVkaWNhdGVzIiwidGVzdCIsInRvRm9ybURhdGEiLCJmb3JtRGF0YSIsIm9wdGlvbnMiLCJUeXBlRXJyb3IiLCJtZXRhVG9rZW5zIiwiaW5kZXhlcyIsImRlZmluZWQiLCJvcHRpb24iLCJ2aXNpdG9yIiwiZGVmYXVsdFZpc2l0b3IiLCJfQmxvYiIsIkJsb2IiLCJ1c2VCbG9iIiwiY29udmVydFZhbHVlIiwidG9JU09TdHJpbmciLCJCdWZmZXIiLCJKU09OIiwic3RyaW5naWZ5IiwiZWwiLCJpbmRleCIsImV4cG9zZWRIZWxwZXJzIiwiYnVpbGQiLCJwb3AiLCJlbmNvZGUiLCJjaGFyTWFwIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwibWF0Y2giLCJBeGlvc1VSTFNlYXJjaFBhcmFtcyIsInBhcmFtcyIsIl9wYWlycyIsImVuY29kZXIiLCJfZW5jb2RlIiwiYnVpbGRVUkwiLCJ1cmwiLCJzZXJpYWxpemVGbiIsInNlcmlhbGl6ZSIsInNlcmlhbGl6ZWRQYXJhbXMiLCJoYXNobWFya0luZGV4IiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwiY29uZmlndXJhYmxlIiwiX3RvUHJvcGVydHlLZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJhcmciLCJfdG9QcmltaXRpdmUiLCJpbnB1dCIsImhpbnQiLCJwcmltIiwidG9QcmltaXRpdmUiLCJyZXMiLCJJbnRlcmNlcHRvck1hbmFnZXIiLCJoYW5kbGVycyIsInVzZSIsImZ1bGZpbGxlZCIsInJlamVjdGVkIiwic3luY2hyb25vdXMiLCJydW5XaGVuIiwiZWplY3QiLCJpZCIsImNsZWFyIiwiZm9yRWFjaEhhbmRsZXIiLCJoIiwic2lsZW50SlNPTlBhcnNpbmciLCJmb3JjZWRKU09OUGFyc2luZyIsImNsYXJpZnlUaW1lb3V0RXJyb3IiLCJVUkxTZWFyY2hQYXJhbXMiLCJpc0Jyb3dzZXIiLCJjbGFzc2VzIiwicHJvdG9jb2xzIiwiaGFzQnJvd3NlckVudiIsImRvY3VtZW50IiwiaGFzU3RhbmRhcmRCcm93c2VyRW52IiwicHJvZHVjdCIsIm5hdmlnYXRvciIsImhhc1N0YW5kYXJkQnJvd3NlcldlYldvcmtlckVudiIsIldvcmtlckdsb2JhbFNjb3BlIiwiaW1wb3J0U2NyaXB0cyIsInBsYXRmb3JtIiwiX29iamVjdFNwcmVhZCIsInRvVVJMRW5jb2RlZEZvcm0iLCJkYXRhIiwiaGVscGVycyIsImlzTm9kZSIsInBhcnNlUHJvcFBhdGgiLCJhcnJheVRvT2JqZWN0IiwiZm9ybURhdGFUb0pTT04iLCJidWlsZFBhdGgiLCJpc051bWVyaWNLZXkiLCJpc0xhc3QiLCJlbnRyaWVzIiwidHJhbnNpdGlvbmFsRGVmYXVsdHMiLCJzdHJpbmdpZnlTYWZlbHkiLCJyYXdWYWx1ZSIsInBhcnNlciIsInBhcnNlIiwiZSIsImRlZmF1bHRzIiwidHJhbnNpdGlvbmFsIiwiYWRhcHRlciIsInRyYW5zZm9ybVJlcXVlc3QiLCJoZWFkZXJzIiwiY29udGVudFR5cGUiLCJnZXRDb250ZW50VHlwZSIsImhhc0pTT05Db250ZW50VHlwZSIsImlzT2JqZWN0UGF5bG9hZCIsInNldENvbnRlbnRUeXBlIiwiZm9ybVNlcmlhbGl6ZXIiLCJfRm9ybURhdGEiLCJlbnYiLCJ0cmFuc2Zvcm1SZXNwb25zZSIsIkpTT05SZXF1ZXN0ZWQiLCJyZXNwb25zZVR5cGUiLCJzdHJpY3RKU09OUGFyc2luZyIsIkVSUl9CQURfUkVTUE9OU0UiLCJ0aW1lb3V0IiwieHNyZkNvb2tpZU5hbWUiLCJ4c3JmSGVhZGVyTmFtZSIsIm1heENvbnRlbnRMZW5ndGgiLCJtYXhCb2R5TGVuZ3RoIiwidmFsaWRhdGVTdGF0dXMiLCJjb21tb24iLCJtZXRob2QiLCJpZ25vcmVEdXBsaWNhdGVPZiIsInJhd0hlYWRlcnMiLCJwYXJzZWQiLCJsaW5lIiwic3Vic3RyaW5nIiwiX3NsaWNlZFRvQXJyYXkiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVSZXN0IiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJuIiwiYXJyMiIsInIiLCJ0IiwidSIsImYiLCJwYXJzZUhlYWRlcnMiLCIkaW50ZXJuYWxzIiwibm9ybWFsaXplSGVhZGVyIiwiaGVhZGVyIiwibm9ybWFsaXplVmFsdWUiLCJwYXJzZVRva2VucyIsInRva2VucyIsInRva2Vuc1JFIiwiaXNWYWxpZEhlYWRlck5hbWUiLCJtYXRjaEhlYWRlclZhbHVlIiwiaXNIZWFkZXJOYW1lRmlsdGVyIiwiZm9ybWF0SGVhZGVyIiwidyIsImNoYXIiLCJidWlsZEFjY2Vzc29ycyIsImFjY2Vzc29yTmFtZSIsIm1ldGhvZE5hbWUiLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJBeGlvc0hlYWRlcnMiLCJfU3ltYm9sJGl0ZXJhdG9yIiwiX1N5bWJvbCR0b1N0cmluZ1RhZyIsInZhbHVlT3JSZXdyaXRlIiwicmV3cml0ZSIsInNldEhlYWRlciIsIl92YWx1ZSIsIl9oZWFkZXIiLCJfcmV3cml0ZSIsImxIZWFkZXIiLCJzZXRIZWFkZXJzIiwiZ2V0IiwiaGFzIiwibWF0Y2hlciIsIl9kZWxldGUiLCJkZWxldGVkIiwiZGVsZXRlSGVhZGVyIiwibm9ybWFsaXplIiwiZm9ybWF0Iiwibm9ybWFsaXplZCIsIl90aGlzJGNvbnN0cnVjdG9yIiwiX2xlbiIsInRhcmdldHMiLCJhc1N0cmluZ3MiLCJmaXJzdCIsImNvbXB1dGVkIiwiX2xlbjIiLCJfa2V5MiIsImFjY2Vzc29yIiwiaW50ZXJuYWxzIiwiYWNjZXNzb3JzIiwiZGVmaW5lQWNjZXNzb3IiLCJtYXBwZWQiLCJoZWFkZXJWYWx1ZSIsInRyYW5zZm9ybURhdGEiLCJmbnMiLCJ0cmFuc2Zvcm0iLCJpc0NhbmNlbCIsIl9fQ0FOQ0VMX18iLCJDYW5jZWxlZEVycm9yIiwiRVJSX0NBTkNFTEVEIiwic2V0dGxlIiwicmVzb2x2ZSIsInJlamVjdCIsIkVSUl9CQURfUkVRVUVTVCIsImZsb29yIiwid3JpdGUiLCJleHBpcmVzIiwiZG9tYWluIiwic2VjdXJlIiwiY29va2llIiwiRGF0ZSIsInRvR01UU3RyaW5nIiwicmVhZCIsIlJlZ0V4cCIsImRlY29kZVVSSUNvbXBvbmVudCIsInJlbW92ZSIsIm5vdyIsImlzQWJzb2x1dGVVUkwiLCJjb21iaW5lVVJMcyIsImJhc2VVUkwiLCJyZWxhdGl2ZVVSTCIsImJ1aWxkRnVsbFBhdGgiLCJyZXF1ZXN0ZWRVUkwiLCJzdGFuZGFyZEJyb3dzZXJFbnYiLCJtc2llIiwidXNlckFnZW50IiwidXJsUGFyc2luZ05vZGUiLCJjcmVhdGVFbGVtZW50Iiwib3JpZ2luVVJMIiwicmVzb2x2ZVVSTCIsImhyZWYiLCJzZXRBdHRyaWJ1dGUiLCJwcm90b2NvbCIsImhvc3QiLCJzZWFyY2giLCJoYXNoIiwiaG9zdG5hbWUiLCJwb3J0IiwicGF0aG5hbWUiLCJjaGFyQXQiLCJsb2NhdGlvbiIsImlzVVJMU2FtZU9yaWdpbiIsInJlcXVlc3RVUkwiLCJub25TdGFuZGFyZEJyb3dzZXJFbnYiLCJwYXJzZVByb3RvY29sIiwic3BlZWRvbWV0ZXIiLCJzYW1wbGVzQ291bnQiLCJtaW4iLCJieXRlcyIsInRpbWVzdGFtcHMiLCJoZWFkIiwidGFpbCIsImZpcnN0U2FtcGxlVFMiLCJjaHVua0xlbmd0aCIsInN0YXJ0ZWRBdCIsImJ5dGVzQ291bnQiLCJwYXNzZWQiLCJyb3VuZCIsIl90b0NvbnN1bWFibGVBcnJheSIsIl9hcnJheVdpdGhvdXRIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVTcHJlYWQiLCJfdG9BcnJheSIsIml0ZXIiLCJjb29raWVzIiwicHJvZ3Jlc3NFdmVudFJlZHVjZXIiLCJsaXN0ZW5lciIsImlzRG93bmxvYWRTdHJlYW0iLCJieXRlc05vdGlmaWVkIiwiX3NwZWVkb21ldGVyIiwibG9hZGVkIiwidG90YWwiLCJsZW5ndGhDb21wdXRhYmxlIiwicHJvZ3Jlc3NCeXRlcyIsInJhdGUiLCJpblJhbmdlIiwicHJvZ3Jlc3MiLCJlc3RpbWF0ZWQiLCJldmVudCIsImlzWEhSQWRhcHRlclN1cHBvcnRlZCIsIlhNTEh0dHBSZXF1ZXN0IiwiUHJvbWlzZSIsImRpc3BhdGNoWGhyUmVxdWVzdCIsInJlcXVlc3REYXRhIiwicmVxdWVzdEhlYWRlcnMiLCJ3aXRoWFNSRlRva2VuIiwib25DYW5jZWxlZCIsImNhbmNlbFRva2VuIiwidW5zdWJzY3JpYmUiLCJzaWduYWwiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiQm9vbGVhbiIsImF1dGgiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwidW5lc2NhcGUiLCJidG9hIiwiZnVsbFBhdGgiLCJvcGVuIiwicGFyYW1zU2VyaWFsaXplciIsIm9ubG9hZGVuZCIsInJlc3BvbnNlSGVhZGVycyIsImdldEFsbFJlc3BvbnNlSGVhZGVycyIsInJlc3BvbnNlRGF0YSIsInJlc3BvbnNlVGV4dCIsInN0YXR1c1RleHQiLCJfcmVzb2x2ZSIsIl9yZWplY3QiLCJlcnIiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJoYW5kbGVMb2FkIiwicmVhZHlTdGF0ZSIsInJlc3BvbnNlVVJMIiwic2V0VGltZW91dCIsIm9uYWJvcnQiLCJoYW5kbGVBYm9ydCIsIkVDT05OQUJPUlRFRCIsIm9uZXJyb3IiLCJoYW5kbGVFcnJvciIsIkVSUl9ORVRXT1JLIiwib250aW1lb3V0IiwiaGFuZGxlVGltZW91dCIsInRpbWVvdXRFcnJvck1lc3NhZ2UiLCJFVElNRURPVVQiLCJ4c3JmVmFsdWUiLCJzZXRSZXF1ZXN0SGVhZGVyIiwid2l0aENyZWRlbnRpYWxzIiwib25Eb3dubG9hZFByb2dyZXNzIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uVXBsb2FkUHJvZ3Jlc3MiLCJ1cGxvYWQiLCJjYW5jZWwiLCJhYm9ydCIsInN1YnNjcmliZSIsImFib3J0ZWQiLCJzZW5kIiwiaHR0cEFkYXB0ZXIiLCJ4aHJBZGFwdGVyIiwia25vd25BZGFwdGVycyIsImh0dHAiLCJ4aHIiLCJyZW5kZXJSZWFzb24iLCJyZWFzb24iLCJpc1Jlc29sdmVkSGFuZGxlIiwiZ2V0QWRhcHRlciIsImFkYXB0ZXJzIiwiX2FkYXB0ZXJzIiwibmFtZU9yQWRhcHRlciIsInJlamVjdGVkUmVhc29ucyIsInJlYXNvbnMiLCJzdGF0ZSIsInMiLCJ0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkIiwidGhyb3dJZlJlcXVlc3RlZCIsImRpc3BhdGNoUmVxdWVzdCIsIm9uQWRhcHRlclJlc29sdXRpb24iLCJvbkFkYXB0ZXJSZWplY3Rpb24iLCJoZWFkZXJzVG9PYmplY3QiLCJtZXJnZUNvbmZpZyIsImNvbmZpZzEiLCJjb25maWcyIiwiZ2V0TWVyZ2VkVmFsdWUiLCJtZXJnZURlZXBQcm9wZXJ0aWVzIiwidmFsdWVGcm9tQ29uZmlnMiIsImRlZmF1bHRUb0NvbmZpZzIiLCJtZXJnZURpcmVjdEtleXMiLCJtZXJnZU1hcCIsInRpbWVvdXRNZXNzYWdlIiwiZGVjb21wcmVzcyIsImJlZm9yZVJlZGlyZWN0IiwidHJhbnNwb3J0IiwiaHR0cEFnZW50IiwiaHR0cHNBZ2VudCIsInNvY2tldFBhdGgiLCJyZXNwb25zZUVuY29kaW5nIiwiY29tcHV0ZUNvbmZpZ1ZhbHVlIiwiY29uZmlnVmFsdWUiLCJWRVJTSU9OIiwidmFsaWRhdG9ycyIsInZhbGlkYXRvciIsImRlcHJlY2F0ZWRXYXJuaW5ncyIsInZlcnNpb24iLCJmb3JtYXRNZXNzYWdlIiwib3B0IiwiZGVzYyIsIm9wdHMiLCJFUlJfREVQUkVDQVRFRCIsImNvbnNvbGUiLCJ3YXJuIiwiYXNzZXJ0T3B0aW9ucyIsInNjaGVtYSIsImFsbG93VW5rbm93biIsIkVSUl9CQURfT1BUSU9OX1ZBTFVFIiwiRVJSX0JBRF9PUFRJT04iLCJBeGlvcyIsImluc3RhbmNlQ29uZmlnIiwiaW50ZXJjZXB0b3JzIiwiY29uZmlnT3JVcmwiLCJfY29uZmlnIiwiY29udGV4dEhlYWRlcnMiLCJyZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbiIsInN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyIsInVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzIiwiaW50ZXJjZXB0b3IiLCJ1bnNoaWZ0IiwicmVzcG9uc2VJbnRlcmNlcHRvckNoYWluIiwicHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzIiwicHJvbWlzZSIsImNoYWluIiwibmV3Q29uZmlnIiwib25GdWxmaWxsZWQiLCJvblJlamVjdGVkIiwiZ2V0VXJpIiwiZm9yRWFjaE1ldGhvZE5vRGF0YSIsImZvckVhY2hNZXRob2RXaXRoRGF0YSIsImdlbmVyYXRlSFRUUE1ldGhvZCIsImlzRm9ybSIsImh0dHBNZXRob2QiLCJDYW5jZWxUb2tlbiIsImV4ZWN1dG9yIiwicmVzb2x2ZVByb21pc2UiLCJwcm9taXNlRXhlY3V0b3IiLCJfbGlzdGVuZXJzIiwib25mdWxmaWxsZWQiLCJzcGxpY2UiLCJjIiwic3ByZWFkIiwiY2FsbGJhY2siLCJpc0F4aW9zRXJyb3IiLCJwYXlsb2FkIiwiSHR0cFN0YXR1c0NvZGUiLCJDb250aW51ZSIsIlN3aXRjaGluZ1Byb3RvY29scyIsIlByb2Nlc3NpbmciLCJFYXJseUhpbnRzIiwiT2siLCJDcmVhdGVkIiwiQWNjZXB0ZWQiLCJOb25BdXRob3JpdGF0aXZlSW5mb3JtYXRpb24iLCJOb0NvbnRlbnQiLCJSZXNldENvbnRlbnQiLCJQYXJ0aWFsQ29udGVudCIsIk11bHRpU3RhdHVzIiwiQWxyZWFkeVJlcG9ydGVkIiwiSW1Vc2VkIiwiTXVsdGlwbGVDaG9pY2VzIiwiTW92ZWRQZXJtYW5lbnRseSIsIkZvdW5kIiwiU2VlT3RoZXIiLCJOb3RNb2RpZmllZCIsIlVzZVByb3h5IiwiVW51c2VkIiwiVGVtcG9yYXJ5UmVkaXJlY3QiLCJQZXJtYW5lbnRSZWRpcmVjdCIsIkJhZFJlcXVlc3QiLCJVbmF1dGhvcml6ZWQiLCJQYXltZW50UmVxdWlyZWQiLCJGb3JiaWRkZW4iLCJOb3RGb3VuZCIsIk1ldGhvZE5vdEFsbG93ZWQiLCJOb3RBY2NlcHRhYmxlIiwiUHJveHlBdXRoZW50aWNhdGlvblJlcXVpcmVkIiwiUmVxdWVzdFRpbWVvdXQiLCJDb25mbGljdCIsIkdvbmUiLCJMZW5ndGhSZXF1aXJlZCIsIlByZWNvbmRpdGlvbkZhaWxlZCIsIlBheWxvYWRUb29MYXJnZSIsIlVyaVRvb0xvbmciLCJVbnN1cHBvcnRlZE1lZGlhVHlwZSIsIlJhbmdlTm90U2F0aXNmaWFibGUiLCJFeHBlY3RhdGlvbkZhaWxlZCIsIkltQVRlYXBvdCIsIk1pc2RpcmVjdGVkUmVxdWVzdCIsIlVucHJvY2Vzc2FibGVFbnRpdHkiLCJMb2NrZWQiLCJGYWlsZWREZXBlbmRlbmN5IiwiVG9vRWFybHkiLCJVcGdyYWRlUmVxdWlyZWQiLCJQcmVjb25kaXRpb25SZXF1aXJlZCIsIlRvb01hbnlSZXF1ZXN0cyIsIlJlcXVlc3RIZWFkZXJGaWVsZHNUb29MYXJnZSIsIlVuYXZhaWxhYmxlRm9yTGVnYWxSZWFzb25zIiwiSW50ZXJuYWxTZXJ2ZXJFcnJvciIsIk5vdEltcGxlbWVudGVkIiwiQmFkR2F0ZXdheSIsIlNlcnZpY2VVbmF2YWlsYWJsZSIsIkdhdGV3YXlUaW1lb3V0IiwiSHR0cFZlcnNpb25Ob3RTdXBwb3J0ZWQiLCJWYXJpYW50QWxzb05lZ290aWF0ZXMiLCJJbnN1ZmZpY2llbnRTdG9yYWdlIiwiTG9vcERldGVjdGVkIiwiTm90RXh0ZW5kZWQiLCJOZXR3b3JrQXV0aGVudGljYXRpb25SZXF1aXJlZCIsImNyZWF0ZUluc3RhbmNlIiwiZGVmYXVsdENvbmZpZyIsImF4aW9zIiwiQ2FuY2VsIiwiYWxsIiwicHJvbWlzZXMiLCJmb3JtVG9KU09OIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///708\n")}}]);